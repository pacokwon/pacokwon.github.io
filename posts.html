<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><title>Paco Kwon&#x27;s Blog Posts</title><meta property="og:title" content="Paco Kwon&#x27;s Blog Posts"/><meta property="og:site_name" content="Paco Kwon&#x27;s Blog"/><meta name="next-head-count" content="5"/><link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark.min.css"/><link id="hljs-light" rel="alternative stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css" disabled=""/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/689295c571d1513e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/689295c571d1513e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-97515393dccb2e54.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-164f91e3b1a225f8.js" defer=""></script><script src="/_next/static/chunks/pages/_app-570540608ca7ace4.js" defer=""></script><script src="/_next/static/chunks/392-079b0eace61ca2f5.js" defer=""></script><script src="/_next/static/chunks/pages/posts-ef970ed3e5f52117.js" defer=""></script><script src="/_next/static/rua-Pj8yobcYBXhnGGnm0/_buildManifest.js" defer=""></script><script src="/_next/static/rua-Pj8yobcYBXhnGGnm0/_ssgManifest.js" defer=""></script><style data-emotion="css-global 12ldfex">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:#fff;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;background-color:#121212;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#121212;}*{padding:0;margin:0;}html{overflow-x:hidden;}body{overflow-x:hidden;position:relative;line-height:1.6;}:root{--fs-800:3rem;--fs-700:2rem;--fs-600:1.5rem;--fs-500:1.25rem;--fs-400:1.125rem;--fs-300:1rem;--fs-200:0.8rem;}</style><style data-emotion="css 670439 1lgdpai dy3din zjuml4 1ps3nxk vubbuv 6ipc24 mfiwgy 16as864 3iet4t 2jualf k1vdy4 bu9fp5 1tze5wd ofq6s5 11qjisw 1vx0m01 1lcvsa9 l2f45e 1uthhvt 18ldivb 1pjtbja">.css-670439{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;}.css-670439::-moz-focus-inner{border-style:none;}.css-670439.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-670439{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-670439:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-670439:hover{background-color:transparent;}}.css-670439.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-1lgdpai{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;box-shadow:0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);background-image:linear-gradient(rgba(255, 255, 255, 0.09), rgba(255, 255, 255, 0.09));display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:static;}.css-1lgdpai.MuiAppBar-root{background-image:unset;}.css-1lgdpai.MuiAppBar-colorPrimary{box-shadow:none;background-color:#121212;color:#fff;}.css-dy3din{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:56px;}@media (min-width:0px){@media (orientation: landscape){.css-dy3din{min-height:48px;}}}@media (min-width:600px){.css-dy3din{min-height:64px;}}.css-dy3din.MuiToolbar-root{padding:0px 32px;}@media (max-width:599.95px){.css-dy3din.MuiToolbar-root{padding:0px 16px;}}@media (min-width:0px){.css-zjuml4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}@media (min-width:600px){.css-zjuml4{display:none;}}.css-1ps3nxk{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;padding:12px;font-size:1.75rem;}.css-1ps3nxk::-moz-focus-inner{border-style:none;}.css-1ps3nxk.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1ps3nxk{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1ps3nxk:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-1ps3nxk:hover{background-color:transparent;}}.css-1ps3nxk.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}.css-6ipc24{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1.25rem;line-height:1.334;color:#90caf9;-webkit-text-decoration:none;text-decoration:none;}@media (min-width:600px){.css-6ipc24{font-size:1.3118rem;}}@media (min-width:960px){.css-6ipc24{font-size:1.4993rem;}}@media (min-width:1280px){.css-6ipc24{font-size:1.4993rem;}}.css-6ipc24:hover{-webkit-text-decoration:underline;text-decoration:underline;}@media (min-width:0px){.css-6ipc24{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;margin-left:16px;}}@media (min-width:600px){.css-6ipc24{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;margin-right:32px;}}.css-6ipc24.MuiLink-root,.css-6ipc24.MuiLink-underlineHover{color:#4db6ac;font-weight:700;}.css-mfiwgy{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}@media (min-width:0px){.css-mfiwgy{display:none;}}@media (min-width:600px){.css-mfiwgy{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}.css-16as864{margin:0;font-family:inherit;font-weight:inherit;font-size:inherit;line-height:inherit;letter-spacing:inherit;color:#90caf9;-webkit-text-decoration:underline;text-decoration:underline;text-decoration-color:rgba(144, 202, 249, 0.4);margin-right:16px;-webkit-text-decoration:none;text-decoration:none;color:#fff;}.css-16as864:hover{text-decoration-color:inherit;}.css-16as864:hover{-webkit-text-decoration:underline;text-decoration:underline;}.css-3iet4t{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;}.css-2jualf{width:100%;margin-left:auto;box-sizing:border-box;margin-right:auto;display:block;padding-left:16px;padding-right:16px;}@media (min-width:600px){.css-2jualf{padding-left:24px;padding-right:24px;}}@media (min-width:1280px){.css-2jualf{max-width:1280px;}}.css-k1vdy4.BreakpointMasonry-masonry-grid{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}.css-k1vdy4 .BreakpointMasonry-masonry-item>a{margin-bottom:8px;margin-right:8px;}.css-bu9fp5{display:block;}.css-bu9fp5:link{-webkit-text-decoration:none;text-decoration:none;}.css-bu9fp5:visited{-webkit-text-decoration:none;text-decoration:none;}.css-1tze5wd{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12);background-image:linear-gradient(rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.05));overflow:hidden;cursor:pointer;-webkit-transition:-webkit-transform 200ms cubic-bezier(0.0, 0, 0.2, 1) 0ms;transition:transform 200ms cubic-bezier(0.0, 0, 0.2, 1) 0ms;}.css-1tze5wd:hover{-webkit-transform:translateY(-4px);-moz-transform:translateY(-4px);-ms-transform:translateY(-4px);transform:translateY(-4px);}.css-ofq6s5{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:16px;}.css-ofq6s5 .MuiCardHeader-title{font-weight:bold;}.css-11qjisw{-webkit-flex:1 1 auto;-ms-flex:1 1 auto;flex:1 1 auto;}.css-1vx0m01{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1.25rem;line-height:1.334;display:block;}@media (min-width:600px){.css-1vx0m01{font-size:1.3118rem;}}@media (min-width:960px){.css-1vx0m01{font-size:1.4993rem;}}@media (min-width:1280px){.css-1vx0m01{font-size:1.4993rem;}}.css-1lcvsa9{padding:16px;padding-top:0px;}.css-1lcvsa9:last-child{padding-bottom:24px;}.css-l2f45e{font-weight:bold;padding-left:4px;}.css-1uthhvt{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:8px;margin-top:8px;}.css-18ldivb{max-width:100%;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:rgba(0, 0, 0, 0.87);background-color:#90caf9;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;}.css-18ldivb.Mui-disabled{opacity:0.38;pointer-events:none;}.css-18ldivb .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#e0e0e0;font-size:0.75rem;}.css-18ldivb .MuiChip-avatarColorPrimary{color:rgba(0, 0, 0, 0.87);background-color:#42a5f5;}.css-18ldivb .MuiChip-avatarColorSecondary{color:rgba(0, 0, 0, 0.87);background-color:#ab47bc;}.css-18ldivb .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-18ldivb .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-18ldivb .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-18ldivb .MuiChip-deleteIcon:hover{color:rgba(255, 255, 255, 0.4);}.css-18ldivb .MuiChip-deleteIcon:hover,.css-18ldivb .MuiChip-deleteIcon:active{color:rgba(0, 0, 0, 0.87);}.css-18ldivb.MuiChip-colorPrimary{color:white;background:#009688;font-weight:500;}.css-1pjtbja{overflow:hidden;text-overflow:ellipsis;padding-left:8px;padding-right:8px;white-space:nowrap;}</style><style data-href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1lgdpai"><div class="MuiToolbar-root MuiToolbar-regular css-dy3din"><div class="MuiBox-root css-zjuml4"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1ps3nxk" tabindex="0" type="button" aria-label="account of current user" aria-controls="menu-appbar" aria-haspopup="true"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button></div><a class="MuiTypography-root MuiTypography-h5 MuiLink-root MuiLink-underlineHover css-6ipc24" href="/">Paco Kwon</a><div class="MuiBox-root css-mfiwgy"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/bio"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Bio</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/posts"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Posts</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/links"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Links</p></a></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeMedium css-670439" tabindex="0" type="button"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="Brightness7Icon"><path d="M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></svg></button></div></header><main><div class="MuiContainer-root MuiContainer-maxWidthLg css-2jualf"><div class="BreakpointMasonry-masonry-grid css-k1vdy4"><div style="width:33.333333333333336%" class="BreakpointMasonry-masonry-item"><a class="css-bu9fp5" href="/posts/20230616-haskell-lisp-parsing"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">하스켈로 간단한 Lisp 만들기 - 파싱</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2023-06-16</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">haskell</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20230415-after-navy-software-developer"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">해군 SW 개발병 복무 후기</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2023-04-15</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">general</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">diary</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">military</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210914-chip8-emulator-in-rust"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Building a Chip-8 Emulator in Rust</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-09-14</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">rust</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">emulator</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210911-simple-state-monad"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Simple State Monad in Haskell with Examples</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-09-11</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">haskell</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210829-genesis"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">블로그 개업!</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-08-29</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">general</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">diary</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div></div></div></a></div><div style="width:33.333333333333336%" class="BreakpointMasonry-masonry-item"><a class="css-bu9fp5" href="/posts/20230604-mission"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">전역, 그리고 안녕</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2023-06-04</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">diary</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20230108-linkwaiter"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">링크 페이지 개업</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2023-01-08</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">blog</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">links</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210913-neovim-users-perspective"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Neovim 0.5.0 - A User&#x27;s Perspective</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-09-13</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">neovim</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">en</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210903-building-a-blog"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Building a Personal Blog in Next.js</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-09-03</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">nextjs</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">en</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20200711-esModuleInterop-in-tsconfig"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Understanding the esModuleInterop option in tsconfig.json</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2020-07-11</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">typescript</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">quicknote</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">en</span></div></div></div></div></a></div><div style="width:33.333333333333336%" class="BreakpointMasonry-masonry-item"><a class="css-bu9fp5" href="/posts/20230430-simple-but-powerful-pratt-parsing"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Simple but Powerful Pratt Parsing</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2023-04-30</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">parsing</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210920-devenv-neovim"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Development Environment - Neovim</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-09-20</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">neovim</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210913-destructuring-refs-in-rust"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Destructuring &amp; References in Rust</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-09-13</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">rust</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">quicknote</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">en</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20210831-navy-software-developer"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">해군 SW 개발병 지원 후기</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2021-08-31</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">general</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">diary</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">military</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div></div></div></a><a class="css-bu9fp5" href="/posts/20200605-spellchecking-in-vim"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation1 MuiCard-root css-1tze5wd"><div class="MuiCardHeader-root css-ofq6s5"><div class="MuiCardHeader-content css-11qjisw"><span class="MuiTypography-root MuiTypography-h5 MuiCardHeader-title css-1vx0m01">Spellchecking in Vim / Neovim</span></div></div><div class="MuiCardContent-root css-1lcvsa9"><span class="css-l2f45e">2020-06-05</span><div class="css-1uthhvt"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">vim</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">neovim</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">quicknote</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">en</span></div></div></div></div></a></div></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"id":"20230616-haskell-lisp-parsing","content":"\n이번 포스트와 다음 포스트에서는 간단한 Lisp 인터프리터를 만들어보겠다. 재미와 학습을 위한 것이니 간단하게 만들어 보겠다.\n\n## 목차\n\n- [Lisp와 목표](#lisp와-목표)\n- [인터프리터 구조](#인터프리터-구조)\n- [파싱](#파싱)\n  - [AST 정의](#AST-정의)\n  - [Parser Combinator](#parser-combinator)\n  - [숫자 파싱](#숫자-파싱)\n  - [식별자 파싱](#식별자-파싱)\n\n나머지 부분들은 2부에서 다루겠다!\n\n## Lisp와 목표\n\nLisp는 단순한 문법과 확장성으로 인해 매니아층이 있는 언어이다. 문법은 S-Expression이라는 표현을 사용하는데, 괄호가 많은 것으로 악명이 높다. 요새 Lisp는 그 자체로 언어라기보다 언어의 family를 나타내는 말로 쓰이는 것 같다. Racket, Common Lisp, Clojure 등등이 이 family에 속한다고 볼 수 있고, 심지어는 이맥스에서도 Emacs Lisp라는 언어를 이용해 내부 configuration을 구성할 수 있게 되어 있다. 언어들마다 제공하는 primitive가 각각 다른데, 이번에는 아래 기능들을 구현해보도록 하겠다.\n\n- 변수 선언 (local, global)\n- 함수 선언 및 호출\n- 표현식 평가\n\n사용할 언어는 하스켈이다. 이럴 때라도 써보도록 하겠다!\n\n우선 프로젝트를 생성하자. 프로젝트 이름은 `whisper`이다. 여기서 사용하는 툴은 [stack](https://docs.haskellstack.org/en/stable/)이다.\n\n```bash\n$ stack new whisper new-template\n```\n\n다음과 같이 파일이 있을 것이다.\n\n```plaintext\napp           LICENSE       README.md  src         stack.yaml.lock  whisper.cabal\nCHANGELOG.md  package.yaml  Setup.hs   stack.yaml  test\n```\n\n실제 프로젝트의 코드는 `app`, `src` 디렉토리에 있으며, `src`는 코어한 라이브러리 함수들이 있고, `app`에는 라이브러리 함수를 잘 조합하여 하나의 실행 파일로 동작하도록 하는 파일이 있다.\n\n이 프로젝트에서는 `ghc 9.2.7`을 사용하겠다. `stack.yaml`에 이를 다음과 같이 명시해준다.\n\n```yaml\n#...\nresolver: lts-20.24\n#...\n```\n\n## 인터프리터 구조\n\n우리의 인터프리터는 읽기 - 파싱 - 평가 - 출력의 단계로 동작하게 할 것이다. 이 중 코어한 부분이 파싱과 평가인데, 이 두 단계를 차례로 부딪혀 보도록 하자.\n\n## 파싱\n\n코드를 작성하기 전에 필요한 패키지를 설치해야 한다. 이 프로젝트에서 사용할 패키지는 [`megaparsec`](https://hackage.haskell.org/package/megaparsec)이라는 parser combinator 라이브러리와, 효율적인 텍스트 처리를 위한 [`text`](https://hackage.haskell.org/package/text) 패키지이다.\n\n`stack.yaml`에 이를 명시해준다.\n\n```yaml\nextra-deps:\n  - megaparsec-9.4.0\n  - text-2.0.2\n```\n\n또 `package.yaml`의 `dependencies` 부분에 다음과 같이 추가한다.\n\n```yaml\ndependencies:\n  - base \u003e= 4.7 \u0026\u0026 \u003c 5\n  - megaparsec \u003e= 9.4 # NEW\n  - text \u003e= 2.0 # NEW\n```\n\n이제 `src/Parser.hs`에 파싱 코드를 작성해보자.\n\nNOTE: `megaparsec`과 같은 parser combinator 라이브러리를 처음 써봐서 [이 공식 문서](https://markkarpov.com/tutorial/megaparsec.html)를 많이 참고했다.\n\n먼저 우리의 `Parser` 타입을 만들어야 한다. 앞으로 만들게 되는 파서들은 이 타입을 가지게 될 것이다.\n\n```haskell\n-- src/Parser.hs\nmodule Parser where\n\nimport Data.Void (Void)\nimport Text.Megaparsec (Parsec)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n```\n\n여기서 `Void`는 파싱 에러의 타입을 뜻하고, `Text`는 입력 소스의 타입을 의미한다. 개발 과정을 단순화하기 위해 에러 타입은 `Void`로 두었다.\n\n### AST 정의\n\n가장 먼저 Syntax 트리를 정의하겠다. Syntax 트리는 코드를 파싱한 결과물을 나타내는데, 우선 하나의 S-Expression을 나타내는 타입을 다음과 같이 정의해볼 수 있다.\n\n```haskell\n-- src/Parser.hs\ndata Sexpr = Paren [Sexpr]\n           | Number Int\n           | Ident String\n\t    deriving Show\n```\n\nSyntax 트리의 노드를 3가지로 간단하게 나타내 보았다. `Number Int`는 `3`과 같이 정수를 표현하고, `Ident String`은 `a`, `foo`와 같이 변수를 표현하며, 마지막으로 `Paren [Sexpr]`는 `(* a (+ 1 3))`와 같이 여러 개의 S-Expression을 괄호 사이에 담고 있는 형태를 나타낸다.\n\n맨 밑줄에 있는 `deriving Show`는 자바로 치면 `toString` 메서드를 자동으로 만들어주는 것과 같다. 다음과 같이 `Sexpr` 타입의 variant를 직관적으로 출력하는 데 도움을 준다.\n\n```haskell\nmain :: IO ()\nmain = do\n    print $ Number 3 -- Output: Number 3\n    print $ Ident \"foo\" -- Output: Ident \"foo\"\n    print $ Paren [Ident \"+\", Number 1, Number 4] -- Output: Paren [Ident \"+\",Number 1,Number 4]\n```\n\n### Parser Combinator\n\n[파서 콤비네이터](https://en.wikipedia.org/wiki/Parser_combinator)는 모나드를 응용하여 재귀하향 파서를 작성하는 방법의 일종이다. 이름이 나타내듯이, 작은 파서를 조합하여 하나의 커다란 파서를 만들기 용이하다.\n\n예를 들어 `megaparsec`에서는 `char`이라는 기본 파서가 있는데 이는 인자로 제공된 문자를 파싱한다.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Text.Megaparsec.Char\nimport Data.Void (Void)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = do\n    parseTest (char 'a' :: Parser Char) \"a\" -- 'a'\n    parseTest (char 'a' :: Parser Char) \"b\" -- ERROR: unexpected 'b', expecting 'a'\n```\n\n`string`이라는 파서도 있다. 이는 인자로 제공된 문자열을 파싱한다.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Text.Megaparsec.Char\nimport Data.Void (Void)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = do\n    parseTest (string \"foo\" :: Parser Text) \"foo\" -- \"foo\"\n```\n\n위 두 예시는 정규표현식으로도 표현이 가능한데, 균형 잡힌 괄호 문제와 같이 regex는 표현하지 못하는 것들도 파싱할 수 있다.\n\n```haskell\ndata ParenExpr = Empty | Concat ParenExpr ParenExpr deriving Show\n\nparenExprParser :: Parser ParenExpr\nparenExprParser = between (char '(') (char ')') innerExpr \u003c|\u003e emptyExpr\n  where\n    innerExpr = do\n      left \u003c- parenExprParser\n      right \u003c- parenExprParser\n      return $ Concat left right\n    emptyExpr = return Empty\n\nmain :: IO ()\nmain = do\n    parseTest parenExprParser \"(())()\" -- Concat (Concat Empty Empty) Empty \"foo\"\n```\n\n### 숫자 파싱\n\n그럼 이제 `megaparsec`에서 제공해주는 기본 파서를 이용해 AST의 정수 부분을 파싱해보자.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Data.Void (Void)\nimport Data.Text (Text)\nimport qualified Text.Megaparsec.Char.Lexer as L\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = parseTest (L.decimal :: Parser Int) \"345\" -- 345\n```\n\n보이는 것과 같이 `Text.Megaparsec.Char.Lexer`의 `decimal` 함수는 10진수 숫자를 파싱해준다. 이때 파싱한 결과는 `Parser Int` 타입인데, 우리가 원하는 것은 `Parser Sexpr` 이다.\n\n어떻게 바꿀 수 있을까?\n\n`Parser` 타입이 모나드라는 사실은 이럴 때 도움이 된다. 이미 모나드에 대해 알고 있는 것을 그대로 적용할 수 있기 때문이다. 모나드가 Functor라는 사실을 알고 있다면, `fmap` 함수를 이용해 내부의 타입을 다음과 같이 변환할 수 있다.\n\n```haskell\nparseTest (Number \u003c$\u003e L.decimal :: Parser Sexpr) \"345\"\n```\n\n따라서 우리의 `number` 함수는 다음과 같이 정의할 수 있다.\n\n```haskell\n-- src/Parser.hs\n\n-- ...\nnumber :: Parser Sexpr\nnumber = Number \u003c$\u003e L.decimal\n```\n\n### 식별자 파싱\n\n이제 조금 더 어려운 식별자를 파싱해보기 전에 식별자가 어떻게 생겼으면 좋겠는지 정의할 필요가 있다. PHP나 JS는 변수명이 `$`로 시작하는 것을 허용하지만, 파이썬은 허용하지 않는 것을 보았을 때, 식별자의 생김새는 정하기 나름이다.\n\nLisp 계열 언어는 식별자 명명에 꽤 관대한 편이다. 따라서 이렇게 규칙을 정하겠다.\n\n1. 식별자는 알파벳, 숫자, 그리고 특정 특수기호로 이루어져 있다\n2. 식별자의 길이는 1 이상이다.\n3. 식별자는 숫자로 시작할 수 없다.\n\n1번의 \"특정 특수기호\"는 ASCII 테이블 안의 특수기호 중 `!\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~` 를 의미한다.\n\n여기서 전략은 두 개의 작은 파서를 만드는 것이다. 파서 A는 첫번째 글자만을 위한 파서이다. 즉 알파벳과 기호를 인식하는 파서이다. 파서 B는 나머지 글자들을 위한 파서이다. 즉 알파벳, 기호, 숫자까지 인식할 수 있다. 그 뒤 파서 A와 B를 합치면 식별자 파서가 되는 것이다.\n\n파서 A는 다음과 같이 만들 수 있다.\n\n```haskell\nimport Text.Megaparsec ((\u003c|\u003e))\nimport Text.Megaparsec.Char (letterChar)\n\nfirst :: Parser Char\nfirst = letterChar \u003c|\u003e symbolChar\n```\n\n`\u003c|\u003e` 연산자의 사용을 볼 수 있는데, 이는 연산자 앞에 있는 파서가 실패하면 뒤에 있는 파서를 시도해보라는 뜻이다. 즉 `letterChar`이 인식하지 못하면, `symbolChar`이 시도를 해보는 것이다. 만약 `symbolChar` 까지 인식하지 못한다면 에러가 발생할 것이다.\n\n`letterChar`은 `megaparsec`에서 가져왔으나, `symbolChar`은 없는 것을 볼 수 있는데, 이는 `megaparsec`에 있는 `symbolChar`이 위에서 정의한 기호들과 일치하지 않기 때문이다. 직접 `symbolChar`를 정의해보자.\n\n```haskell\nimport Text.Megaparsec (satisfy)\nimport qualified Data.Set as Set\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n```\n\n위에선 `satisfy`라는 `megaparsec`의 함수를 사용했는데, 주어진 predicate 함수를 만족하는 문자만 인식하게 하는 것이다. 우리는 predicate로 연산자 집합에 있는 문자만 인식하는 함수를 건넸다.\n\n이제 두 개의 작은 파서가 완성되었다. 이를 조합해 식별자 파서를 완성시켜보자.\n\n```haskell\n-- src/Parser.hs\nimport Text.Megaparsec ((\u003c|\u003e), many, satisfy)\nimport Text.Megaparsec.Char (letterChar, alphaNumChar)\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n\nident :: Parser Sexpr\nident = Ident \u003c$\u003e p\n    where\n        first = letterChar \u003c|\u003e symbolChar\n        rest = many (alphaNumChar \u003c|\u003e symbolChar)\n        p = (:) \u003c$\u003e first \u003c*\u003e rest\n```\n\n위 코드에서 눈여겨볼 점들은:\n\n1. `many` 함수를 이용하여 \"하나의 문자를 인식하는 파서\"를 \"0개 이상의 문자를 인식하는 파서\"로 만들었다.\n2. `(:)` 리스트 cons 연산자를 이용하기 위해 `fmap(\u003c$\u003e)`과 `\u003c*\u003e`를 사용했다. `fmap`은 모나드가 functor이기 때문에 가능하고, `\u003c*\u003e`은 모나드가 applicative이기도 하기 때문에 가능하다.\n\n### 리스트 파싱\n\n이제 마지막 variant인 `Paren`을 파싱해보자. 안에 여러 개의 S-Expression을 담고 있기 때문에 리스트라고 부르겠다. 리스트를 파싱하기 위해 그것의 특성을 먼저 살펴보자.\n\n1. `(`으로 시작한다.\n2. `)`으로 끝난다.\n3. 사이에 1개 이상의 S-Expression이 공백으로 구분되어 있다\n\n가장 어려운 부분은 3번이다. 우선 리스트 안에는 또다른 S-Expression이 있기 때문에 재귀호출이 필요해 보이고, 또 공백을 어떻게든 처리해야 한다. 방법은 다양하겠지만, **파싱이 끝난 이후에 발생하는 공백을 consume하고 무시하도록** 파서를 수정하도록 하자.\n\n이를 돕도록 유틸리티 함수를 하나 만들겠다. 파서를 입력으로 받아, 해당 파서가 하는 일 + 뒤에 있는 공백을 무시하는 파서를 만들자.\n\n```haskell\nimport Text.Megaparsec.Char (space)\n\nlexeme :: Parser a -\u003e Parser a\nlexeme p = p \u003c* space\n```\n\n이를 이용하여 기존 파서들을 수정하자. 위 함수를 사용하면 꽤 간단하다.\n\n```haskell\nnumber :: Parser Sexpr\nnumber = Number \u003c$\u003e lexeme L.decimal\n\n-- ...\nident :: Parser Sexpr\nident = Ident \u003c$\u003e lexeme p\n    where\n        first = letterChar \u003c|\u003e symbolChar\n        rest = many (alphaNumChar \u003c|\u003e symbolChar)\n        p = (:) \u003c$\u003e first \u003c*\u003e rest\n```\n\n이로써 이 파서들은 뒤에 있는 공백까지 무시하는 기능까지 추가되었다.\n\n```haskell\nmain :: IO ()\nmain = do\n    parseTest (liftA2 (,) number ident) \"345 foobar\" -- (Number 345,Ident \"foobar\")\n```\n\n두 파서를 연속으로 실행시켜도 공백을 무시하고 잘 파싱해준다.\n\n이제 유용한 함수를 하나 더 소개하겠다. 바로 `many`와 `some`인데, `many p`는 파서 `p`를 0번 이상 실행시켜 그 결과를 돌려주고, `some p`는 파서 `p`를 1번 이상 실행시켜 그 결과를 돌려준다.\n\n즉, `many number`는 공백으로 구분된 0개 이상의 연속된 숫자를 파싱할 수 있고, `some ident`는 공백으로 구분된 1개 이상의 연속된 식별자를 파싱할 수 있다.\n\n리스트 안에는 1개 이상의 S-Expression이 필요하기 때문에 `some`을 쓰면 된다. 근데 어떤 파서를 1번 이상 실행하면 될까? 우선은 그것을 `sexpr`라 부르기로 하고 조금 이따 돌아와보자.\n\n종합해 보아 `paren` 파서를 만들어 보자. `(`로 시작하고, `p`를 1번 이상 실행한 뒤, `)`로 끝나는 것이다.\n\n```haskell\nimport Text.Megaparsec (some)\nimport Text.Megaparsec.Char (char)\n\nparen :: Parser Sexpr\nparen =\n  lexeme\n    ( do\n        _ \u003c- char '('\n        ss \u003c- some sexpr -- ERROR: Variable not in scope: sexpr\n        _ \u003c- char ')'\n        return $ Paren ss\n    )\n```\n\n에러가 날 것이지만 우선은 S-Expression을 종합적으로 파싱해주는 `sexpr`를 완성해보자. 이미 S-Expression의 variant는 모두 파싱할 수 있으니, 이를 조합만 하면 된다.\n\n```haskell\nsexpr :: Parser Sexpr\nsexpr = paren \u003c|\u003e number \u003c|\u003e ident\n```\n\n잘 되는지 확인해보자!\n\n```haskell\nmain :: IO ()\nmain = do\n    parseTest sexpr \"(+ 1 2 3)\" -- Paren [Ident \"+\",Number 1,Number 2,Number 3]\n    parseTest sexpr \"(+ 1 (* foo spam) 4)\" -- Paren [Ident \"+\",Number 1,Paren [Ident \"*\",Ident \"foo\",Ident \"spam\"],Number 4]\n    parseTest sexpr \"5\" -- Number 5\n    parseTest sexpr \"foo\" -- Ident \"foo\"\n```\n\n문제없이 잘 파싱이 된다면 지금까지 잘 따라온 것이다🎉🎉\n\nNOTE: `paren`은 다음과 같이 간결하게 나타낼 수도 있다!\n\n```haskell\nparen :: Parser Sexpr\nparen = Paren \u003c$\u003e lexeme (char '(' *\u003e some sexpr \u003c* char ')')\n```\n\n아래는 지금까지 작성한 파서 코드이다.\n\n```haskell\n-- src/Parser.hs\nmodule Parser (Sexpr (..), number, ident, paren, sexpr) where\n\nimport Data.List.NonEmpty (NonEmpty (..))\nimport qualified Data.Set as Set\nimport Data.Text (Text)\nimport Data.Void (Void)\nimport Text.Megaparsec (ErrorItem (..), MonadParsec (token), Parsec, Stream (Token), many, satisfy, some, (\u003c|\u003e))\nimport Text.Megaparsec.Char (alphaNumChar, char, letterChar, space)\nimport qualified Text.Megaparsec.Char.Lexer as L\n\ntype Parser = Parsec Void Text\n\ndata Sexpr\n  = Paren [Sexpr]\n  | Number Int\n  | Ident String\n  deriving (Show)\n\nlexeme :: Parser a -\u003e Parser a\nlexeme p = p \u003c* space\n\nnumber :: Parser Sexpr\nnumber = Number \u003c$\u003e lexeme L.decimal\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n\nident :: Parser Sexpr\nident = Ident \u003c$\u003e lexeme p\n  where\n    first = letterChar \u003c|\u003e symbolChar\n    rest = many (alphaNumChar \u003c|\u003e symbolChar)\n    p = (:) \u003c$\u003e first \u003c*\u003e rest\n\nparen :: Parser Sexpr\nparen = Paren \u003c$\u003e lexeme (char '(' *\u003e some sexpr \u003c* char ')')\n\nsexpr :: Parser Sexpr\nsexpr = paren \u003c|\u003e number \u003c|\u003e ident\n```\n\n여기까지가 파싱이었다. 다음 포스트에서는 평가 부분을 다루도록 하겠다.\n","title":"하스켈로 간단한 Lisp 만들기 - 파싱","tags":["ko","haskell"],"date":"2023-06-16"},{"id":"20230604-mission","content":"\n2023년 6월 4일, 오늘은 제 전역날입니다. 평소같이 아침에 부대 생활관에서 일어나고, 평소같이 점호를 받았지만 이젠 마지막이었습니다. 군생활하며 이미 후임보다는 친구, 형 동생과 같았던 수병들에게 과분한 축하를 받고 정문을 나왔습니다.\n\n입대할 땐 이날이 언제 오나 싶었지만, 점점 다가올수록 오히려 불안한 심정을 느끼기도 했었습니다. 제가 전역하고 무엇을 할지, 2023년이 막 되었을 당시에도 제대로 결정하지 못했었습니다. 하지만 머지 않아, 결국 저는 선교사업을 하러 떠나기로 결정했습니다.\n\n저는 교회 안에서 태어나, 교회의 계명에는 항상 순종했으나 신앙심이 아주 깊지는 않았습니다. 선교사업을 결심한 첫 번째 이유는, 저의 신앙을 강화하고 싶어서였습니다. 시간이 많았던 군생활 말년에, 선교사업을 준비하여 주님의 말씀을 열심히 구했습니다. 저는 기도의 응답으로 가슴이 따뜻해지는 경험도 하고, 무엇보다 제가 스스로 중요하다고 생각했던 가치들이, 사실은 교회를 다니며 만들어진 가치들이라는 것을 알게 되었습니다. 선교사로서 다른 사람들에게도 같은 기회를 주고 싶다는 새로운 동기도 찾았습니다.\n\n선교사로서 봉사하겠다는 신청을 하게 되면, 몇 개월 뒤 교회 본부에서는 언제부터, 어느 곳에서 봉사할지를 결정하여 부름장에 담아 회신합니다. 제가 전역하는 날에 부름장을 열어보게 될 줄은, 부름장이 도착한 전역하기 전날이 되어서야 알게 되었습니다. 집에 도착하여 가족과 함께 부름장을 열었고, 제가 **8월 7일부터 뉴욕 시티 선교부**에서 봉사하게 될 것을 알았습니다.\n\n선교 활동을 하며 어떤 일이 벌어질지 전혀 모르겠습니다. 하지만 많은 사람들을 돕고, 그 과정에서 저 스스로도 많은 성장을 하게 될 것과, 그 시간이 헛되지 않을 것 또한 알고 있습니다. 가기 전까지 남은 짧은 시간동안 잘 준비하여 더 훌륭한 주님의 도구로서 봉사할 수 있도록 하겠습니다!\n\n\u003e 이에 이제 이렇게 되었나니 앨마와 그의 형제들 위에 지워진 짐이 가벼워졌고, 참으로 주께서 그들을 강하게 하사 그들로 쉽게 그들의 짐을 지게 하시매, 그들이 주의 모든 뜻에 즐거이 인내를 가지고 복종하였더라. (모사이야 24:16)\n","title":"전역, 그리고 안녕","tags":["ko","diary"],"date":"2023-06-04"},{"id":"20230430-simple-but-powerful-pratt-parsing","content":"\n아래 글은 [matklad](https://github.com/matklad)의 [Simple but Powerful Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html)의 번역 포스팅입니다. 제 스스로의 이해를 돕기 위함이 목적이지만, 유익한 글인 것 같아 블로그에 소개하고도 싶었습니다.\n\n## Simple but Powerful Pratt Parsing\n\n프랫 파싱 글에 온 것을 환영합니다! 프랫 파싱은 구문 분석계의 모나드 튜토리얼과 같다고도 할 수 있습니다. 이 주제에 관한 소개글은 너무 많아서 [이런 튜토리얼 모음](https://www.oilshell.org/blog/2017/03/31.html)까지 있을 정도입니다.\n\n이 글의 목표는 아래와 같습니다.\n\n- 이른바 left-recursion 문제가 과장되었음을 제기하기 위해\n- BNF 표기법이 중위표현식을 표현하기에 부적합함을 지적하기 위해\n- 프랫 파싱 알고리즘의 구현을 과한 추상화 없이, 있는 그대로 보여주기 위해\n- 이 알고리즘을 제가 제대로 이해하기 위해 (제가 실사용 용도로 프랫 파서를 [구현](https://github.com/rust-lang/rust-analyzer/blob/c388130f5ffbcbe7d3131213a24d12d02f769b87/crates/ra_parser/src/grammar/expressions.rs#L280-L281)한 적이 있는데, 이제는 코드를 봐도 바로 이해되지가 않더라고요)\n\n## Introduction\n\n파싱이라는 것은, 일련의 토큰들이 컴파일러에 의해 트리 구조로 변환되는 과정을 이야기합니다.\n\n```plaintext\n                            Add\n                 Parser     / \\\n \"1 + 2 * 3\"    -------\u003e   1  Mul\n                              / \\\n                             2   3\n```\n\n파싱을 접근하는 방식은 다양한데, 크게 두 부류로 나눠볼 수 있습니다.\n\n- 파싱하려는 언어의 문법을 DSL을 사용하여 표현하고, 그 문법을 이용하여 파서를 생성해내는 방법\n- 직접 손으로 파서를 작성하는 방법\n\n두 번째 방식 안에서 가장 널리 사용되는 기법이 바로 프랫 파싱입니다.\n\n## BNF\n\n문맥 자유(Context-Free) 문법 표기법(주로 BNF concrete syntax를 사용)은 구문분석 이론에 중요한 발견이었습니다. BNF를 사용하면 다음과 같이 본래 선형적인 문장 구조를 트리 형태로 나타낼 수 있습니다.\n\n```plaintext\nItem ::=\n    StructItem\n  | EnumItem\n  | ...\n\nStructItem ::=\n    'struct' Name '{' FieldList '}'\n\n...\n```\n\n처음 이 기법을 보며 감탄했던 기억이 납니다.\n\n표현식을 나타내는 방식을 보고 갑자기 좀 서운해졌지만요.\n\n표현식을 나타내는 직관적인 형태의 문법을 살펴보겠습니다.\n\n```plaintext\nExpr ::=\n    Expr '+' Expr\n  | Expr '*' Expr\n  | '(' Expr ')'\n  | 'number'\n```\n\n꽤 직관적이죠. 근데 사실 위 문법은 **모호**해서 자동 파서 생성기(위에서 언급된 1번 방식)에 사용되기 위해서는 고쳐서 작성되어야 합니다. 더 구체적으로 얘기하자면, 연산자의 우선순위와 결합방향을 잘 고려한 문법을 작성해야 하는데요, 아래와 같이 수정하면 앞서 언급된 문제들을 해결할 수 있습니다.\n\n```plaintext\nExpr ::=\n    Factor\n  | Expr '+' Factor\n\nFactor ::=\n    Atom\n  | Factor '*' Atom\n\nAtom ::=\n    'number'\n  | '(' Expr ')'\n```\n\n어떤가요? 솔직히 이 새로운 문법은 제가 처음 생각했던 표현식의 모양과는 전혀 달라 보입니다. 가장 먼저 나온 모호한 문법이 더 직관적이고, 더군다나 제가 스스로 문법을 이렇게 고칠 수 있을때까지 언어론에 대해 전공수업만 세네개 들었어야 했던 것 같습니다.\n\n이것이 제가 프랫 파싱을 좋아하는 이유입니다. 문법을 부자연스럽게 고쳐야 하는 재귀하향식 파싱 기법에서 발전해서, 연산자와 결합방향을 자연스럽게 표현할 수 있기 때문입니다.\n\n## 재귀하향과 Left-Recursion\n\n재귀하향은 직접 파서를 짤 때 사용할 수 있는 가장 기본적인 기법입니다. 이 기법은 서로 재귀적인 함수들을 사용하여 파싱을 하는데, 예를 들어 위에 있는 문법은 재귀하향을 썼을 때 다음과 같이 코드로 표현할 수 있습니다.\n\n```rust\nfn item(p: \u0026mut Parser) {\n    match p.peek() {\n        STRUCT_KEYWORD =\u003e struct_item(p),\n        ENUM_KEYWORD   =\u003e enum_item(p),\n        ...\n    }\n}\n\nfn struct_item(p: \u0026mut Parser) {\n    p.expect(STRUCT_KEYWORD);\n    name(p);\n    p.expect(L_CURLY);\n    field_list(p);\n    p.expect(R_CURLY);\n}\n```\n\n보통 교과서들은 Left Recursive 문법을 이 접근 방식의 단점이라고 지적하면서, 더 심화된 LR 파싱 기법으로 넘어가는 동기로 삼습니다. Left Recursion은 분명히 문제가 되는 시점들이 있는데, 아래 문법을 한 번 보겠습니다.\n\n```plaintext\nSum ::=\n    Sum '+' Int\n  | Int\n```\n\n재귀하향 방식으로 위 문법에 대한 파서를 작성해보겠습니다.\n\n```rust\nfn sum(p: \u0026mut Parser) {\n    // Sum '+' Int가 되는지 먼저 시도해본다\n    sum(p); // ①\n    p.expect(PLUS);\n    int(p);\n    // 위에서 실패했으면, 그 다음 후보지를 시도해본다.\n    ...\n}\n```\n\n1. 이 코드를 실행하면 코드가 무한 재귀에 빠져버려서 스택 오버플로우가 발생해버립니다.\n\n이런 문제를 고치기 위한 이론적인 방법은 역시 문법을 수정해서, **같은 언어를 표현하되 위와 같은 문제가 발생하지 않도록 Left Recursion을 없앤 문법**을 작성하는 것입니다.\n\n하지만 직접 작성하는 파서의 경우에는 실용적인 해결방법도 있는데, 그냥 재귀를 버리고 반복문을 사용하는 것입니다.\n\n```rust\nfn sum(p: \u0026mut Parser) {\n    int(p);\n    while p.eat(PLUS) {\n        int(p);\n    }\n}\n```\n\n## 프랫 파싱의 뼈대\n\n위와 같이 반복문을 이용해서 Left Recursion을 실용적으로 대처하는 방법을 보았는데, 프랫 파싱은 반복문과 재귀를 동시에 사용합니다.\n\n```rust\nfn parse_expr() {\n    ...\n    loop {\n        ...\n        parse_expr()\n        ...\n    }\n}\n```\n\n위에 있는 코드는 연산자 우선순위와 결합방향을 잘 처리해줍니다. 머리가 띵해지긴 하지만요.\n\n## 우선순위에서 결합 세기로\n\n솔직히 말하면 저는 \"높은 우선순위\"와 \"낮은 우선순위\"라는 용어를 보며 항상 헷갈리는 것 같습니다. `a + b * c` 라는 표현식 안에서 덧셈은 우선순위가 **낮은데**, 파싱 트리에서는 **맨 위에** 있습니다.\n\n그래서 저는 **결합 세기**라는 표현이 더 직관적이라고 생각합니다.\n\n```plaintext\nexpr:   A       +       B       *       C\npower:      3       3       5       5\n```\n\n`*`이 더 세니까 B와 C를 끌어당기는 힘이 더 세고, 위 표현식은 `A + (B * C)`와 같이 파싱이 되는 것입니다.\n\n결합 방향은 어떻게 표현할 수 있을까요? `A + B + C`를 보면 모든 연산자들이 같은 세기를 가지고 있어서 어떻게 파싱이 되어야 할지 불명확합니다. 하지만 이것도 아래와 같이 결합 세기로 표현할 수가 있습니다.\n\n```plaintext\nexpr:      A       +       B       +       C\npower:  0      3      3.1      3      3.1     0\n```\n\n오른쪽 피연산자를 당기는 힘이 더 강해지도록 `+`의 오른쪽 결합 세기를 조금 올린 것을 볼 수 있습니다. 양옆 끝에 `0`이 있는 것도 볼 수 있는데, 이건 맨 끝에서는 당기는 힘이 없다는 것을 표현한 것입니다. B의 입장에서 봤을 때, 왼쪽에서 더 강하게 결합하려고 하기 때문에 우선 첫 단계로는 아래와 같이 파싱이 될 것입니다.\n\n```plaintext\nexpr:     (A + B)     +     C\npower:  0          3    3.1    0\n```\n\n그 다음 단계를 거치면 결국 `(A + B) + C` 가 됩니다.\n\n프랫 파싱이 하는 일은 스트링을 왼쪽에서 오른쪽으로 읽으며 우리가 위에서 본 과정을 전부 처리하는 것입니다.\n\n오른쪽으로 결합하는 연산자는 어떻게 처리하면 좋을까요? 예시로, 하스켈에 있는 함수 합성 연산자 `.`는 다음과 같이 모델링할 수 있습니다\n\n```plaintext\n  f     .    g     .    h\n0   8.5    8   8.5    8   0\n```\n\n그러면 위 표현식은 `f . (g . h)` 와 같이 파싱이 되는 것입니다.\n\n## 미니멀한 프랫 파서\n\n이제부터 프랫 파서를 이용해서 캐릭터 하나짜리 숫자와 변수(묶어서 아톰), 그리고 특수문자를 사용한 연산자가 있는 표현식을 파싱해보겠습니다.\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Token {\n    Atom(char),\n    Op(char),\n    Eof,\n}\n\nstruct Lexer {\n    tokens: Vec\u003cToken\u003e,\n}\n\nimpl Lexer {\n    fn new(input: \u0026str) -\u003e Lexer {\n        let mut tokens = input\n            .chars()\n            .filter(|it| !it.is_ascii_whitespace())\n            .map(|c| match c {\n                '0'..='9' |\n                'a'..='z' | 'A'..='Z' =\u003e Token::Atom(c),\n                _ =\u003e Token::Op(c),\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        tokens.reverse();\n        Lexer { tokens }\n    }\n\n    fn next(\u0026mut self) -\u003e Token {\n        self.tokens.pop().unwrap_or(Token::Eof)\n    }\n\n    fn peek(\u0026mut self) -\u003e Token {\n        self.tokens.last().copied().unwrap_or(Token::Eof)\n    }\n}\n```\n\n결합 세기가 잘 반영되어 파싱됐는지 확인해보기 위해, 파싱된 표현식을 중위표현식에서 널리 사용되는 표현 방식으로 변환해보겠습니다. 이 방식은 (아마도 폴란드에서는 별로 인기가 없겠지만) 바로 S-표현식입니다. Lisp 계열 언어에서 지겹도록 볼 수있는 표현 방식이죠.\n\n```plaintext\n1 + 2 * 3 == (+ 1 (* 2 3))\n```\n\n```rust\nuse std::fmt;\n\nenum S {\n    Atom(char),\n    Cons(char, Vec\u003cS\u003e),\n}\n\nimpl fmt::Display for S {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            S::Atom(i) =\u003e write!(f, \"{}\", i),\n            S::Cons(head, rest) =\u003e {\n                write!(f, \"({}\", head)?;\n                for s in rest {\n                    write!(f, \" {}\", s)?\n                }\n                write!(f, \")\")\n            }\n        }\n    }\n}\n```\n\n단순하게 시작하죠. 먼저 아톰과 `+`, `*` 연산자만으로 이루어진 표현식을 파싱해봅시다.\n\n```rust\nfn expr(input: \u0026str) -\u003e S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(\u0026mut lexer)\n}\n\nfn expr_bp(lexer: \u0026mut Lexer) -\u003e S {\n    todo!()\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\")\n}\n```\n\n위에서 본 left recursion에 대한 **실용적인 대처방식**과 유사하게 접근해보겠습니다. 먼저 숫자를 파싱하고, 반복문을 돌고, 연산자를 파싱하고 나서는, 음.. 아직은 모르겠네요.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer) -\u003e S {\n    let lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.next() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n        todo!()\n    }\n    lhs\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n}\n```\n\n그래도 첫 번째 테스트는 벌써 통과합니다!\n\n앞서 언급한 **결합 세기**의 개념을 코드에 도입해봅시다. 각 연산자마다 양옆을 당기는 힘을 `u8`로 각각 나타내고, 결합 방향을 표현하기 위해 한쪽의 결합 세기가 `1` 더 크도록 설정하겠습니다. `0`을 입력의 마지막 부분을 나타내는 결합 세기로 나타내고, 연산자 중 가장 낮은 결합 세기를 `1`이라고 미리 약속해두겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer) -\u003e S {\n    let lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n        let (l_bp, r_bp) = infix_binding_power(op);\n        todo!()\n    }\n    lhs\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        _ =\u003e panic!(\"bad op: {:?}\")\n    }\n}\n```\n\n이제부터 조금 복잡해질텐데, 재귀호출을 사용해보겠습니다. 아래 예시를 보겠습니다.\n\n```plaintext\na   +   b   *   c   *   d   +   e\n  1   2   3   4   3   4   1   2\n```\n\n파싱은 토큰을 왼쪽에서 오른쪽으로 스캔하며 진행이 될텐데, 현재 토큰을 가리키는 커서가 있다고 생각해보죠.\n\n커서가 처음 `+`를 만나게 되면, `l_bp`는 `1`, `r_bp`는 `2`일 것이고, `lhs`는 `a`를 담고 있을 것입니다. 다음에 보이는 연산자인 `*`는 `+`보다 우선순위가 높으니, `a`와 `b`는 더하면 안되겠죠? 하지만 우리는 왼쪽에서 오른쪽으로 커서를 움직이고 있으니, `+`를 바라보고 있는 시점에는 `*`의 존재 유무를 모를 것입니다. lookahead(전방탐색)를 추가하면 해결할 수 있을까요? 안될건 없지만 그 범위가 얼마나 될지 가늠이 안됩니다. 지금 예시만 봐도 `b`, `c`, `d` 토큰을 전부 스캔해야만 우선순위 처리를 제대로 할 수 있을 테니까요.\n\n첫 번째 `+`이후에 나오는 표현식 `b * c * d`까지는 높은 우선순위로 파싱을 해야 합니다. 이는 꽤 직관적으로 판단할 수 있죠. 근데 `d`까지만 파싱해야 하는 이유는 무엇일까요? 그 다음에 나오는 `+`의 우선순위가 처음에 본 `+`의 우선순위보다 높지 않기 때문입니다. 그 전까지 본 연산자들(`*`)은 모두 `+`보다 우선순위가 높았다는 것을 볼 수 있습니다.\n\n이를 처리하기 위해 재귀를 사용하겠습니다. `b`에서 다시 `expr_bp`를 호출하면서, `+`보다 우선순위가 낮아지는 즉시, 즉 `bp`가 `2`보다 낮아지는 순간에 파싱을 멈추는 것입니다.\n\n자, 아래에 미니멀한 프랫 파서가 완성되었습니다.\n\n```rust\nfn expr(input: \u0026str) -\u003e S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(\u0026mut lexer, 0) // 5\n}\n\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S { // 1\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp \u003c min_bp { // 2\n            break;\n        }\n\n        lexer.next(); // 3\n        let rhs = expr_bp(lexer, r_bp);\n        lhs = S::Cons(op, vec![lhs, rhs]); // 4\n    }\n\n    lhs\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\");\n\n    let s = expr(\"a + b * c * d + e\");\n    assert_eq!(s.to_string(), \"(+ (+ a (* (* b c) d)) e)\");\n}\n```\n\n1. `min_bp` 인자는 아주 중요한 변경사항입니다. `expr_bp`는 이제 특정 결합 세기 이상의 표현식만 파싱할 수도 있습니다. `min_bp`보다 결합 강도가 낮은 연산자를 만났을 경우, 즉시 파싱을 중단합니다.\n2. 이곳이 바로 파싱을 중단하는 시점입니다.\n3. `next` 호출로 인해 연산자 위에 있던 커서를 한 칸 움직이고, 재귀호출을 합니다. `min_bp`를 연산자의 `l_bp`와 비교하는 모습을 확인할 수 있습니다. 어떻게 보면 `min_bp`는 현재 파싱하고 있는 커다란 표현식의 왼쪽에 위치한 연산자의 결합 세기라고 생각할 수 있습니다.\n4. `rhs`를 잘 파싱하고 난 이후에는, 이미 파싱한 `lhs`와 결합하여 새로운 `lhs`를 만들어냅니다.\n5. 재귀호출의 시작 인자는 `0`입니다. 표현식의 양끝은 연산자가 없으므로 결합 세기가 `0`이라고 위에서 언급한 바 있습니다.\n\n위에 있는 약 40줄의 코드가 프랫 파싱 알고리즘이라고 할 수 있겠습니다. 조금 까다롭긴 하지만, 열심히 이해하고 나면, 이후에 추가하는 기능들은 꽤 단순합니다.\n\n## 연산자 추가해보기\n\n기본적인 뼈대는 완성되었으니, 이 알고리즘의 진가를 보여드리기 위해 다양한 표현식을 추가해보겠습니다.\n\n먼저, 높은 우선순위를 가지고, 오른쪽으로 결합하는 함수 합성 연산자인 `.`을 추가해보겠습니다.\n\n```rust\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (6, 5), // NEW\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n```\n\n맞습니다. 위와 같이 한 줄만 추가하면 충분합니다. 기존에 추가된 다른 연산자들과는 다르게 왼쪽 결합 세기가 더 강한 것을 확인할 수 있습니다. 결합 방향이 오른쪽이기를 원하기 때문이죠.\n\n```rust\nlet s = expr(\"f . g . h\");\nassert_eq!(s.to_string(), \"(. f (. g h))\");\n\nlet s = expr(\" 1 + 2 + f . g . h * 3 * 4\");\nassert_eq!(s.to_string(), \"(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))\");\n```\n\n### 전위 단항연산자 `-`\n\n이제 단항연산자 `-`를 추가해보겠습니다. 이 연산자는 이항 산술연산자들보다는 더 강하게 결합하고, 함수 합성 연산자(`.`)보다는 약하게 결합합니다.\n\n단항연산자가 추가되면 수정해야 하는 부분이 있습니다. 루프가 시작하는 시점에 첫 번째 토큰은 아톰만 가능하다고 가정했으나, `-5`와 같이 연산자로 시작하는 표현식이 생기기 때문에 이 또한 처리해주어야 합니다.\n\n`-`는 전위 단항연산자이므로 오른쪽 결합 세기만 있습니다. 이를 타입을 통해 나타내보겠습니다.\n\n```rust\nfn prefix_binding_power(op: char) -\u003e ((), u8) { // 1\n    match op {\n        '+' | '-' =\u003e ((), 5),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (8, 7), // 2\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n```\n\n1. 전위 연산자임을 명확하게 하기 위해 타입을 이와 같이 지정하겠습니다. 이 연산자들은 오른쪽에 있는 표현식들과만 결합할 수 있습니다.\n2. 단항연산자 `-`가 `.`보다는 약하게, 이항 `-`, `+` 보다는 강하게 결합하는 이전에 연산자임을 언급하였습니다. 이를 반영하기 위해 우선순위 값들의 조정이 필요합니다. 일반적으로는 홀수를 기본 결합세기로 맞춰놓은 다음, 결합 방향을 반영하기 위해 한쪽의 세기를 `1` 늘려주는 접근 방식을 사용합니다. 단항 `-`는 `5`, `6` 둘 다 상관없지만 일관성을 위해 홀수로 지정하였습니다.\n\n`expr_bp`에 이를 반영해보겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            todo!()\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n    ...\n}\n```\n\n이제 반복문 안에 있는 `r_bp` 관련 로직들을 가져와 `todo!()`를 채워봅시다. 일부 코드는 `l_bp`와 관련있으니 제외하고 가져올 수 있습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp \u003c min_bp {\n            break;\n        }\n\n        lexer.next();\n        let rhs = expr_bp(lexer, r_bp);\n\n        lhs = S::Cons(op, vec![lhs, rhs]);\n    }\n    lhs\n}\n\n#[test]\nfn tests() {\n    ...\n\n    let s = expr(\"--1 * 2\");\n    assert_eq!(s.to_string(), \"(* (- (- 1)) 2)\");\n\n    let s = expr(\"--f . g\");\n    assert_eq!(s.to_string(), \"(- (- (. f g)))\");\n}\n```\n\n이미 적어둔 로직을 거의 기계적으로 가져와 사용해봤는데, 꽤 잘 작동하는 것을 볼 수 있습니다. 먼저 단항연산자를 파싱하고 (있는 경우에), 그 연산자보다 강하게 결합하는 피연산자를 재귀호출을 통해 파싱하는 것입니다.\n\n### 후위연산자도 처리할 수 있을까?\n\n전위연산자 처리 로직을 넣어보았습니다. 이를 위해 `((), u8)` 타입을 사용했는데, 그럼 `(u8, ())`을 사용하면 후위연산자를 처리할 수 있을까요? 한번 해봅시다. 팩토리얼(`!`) 연산자가 적합한 것 같네요. `-`보다는 더 강하게 결합해야 할 것 같습니다. `-(92!)`가 `(-92)!`보다는 더 유용할 테니까요. 전위연산자를 추가할 때와 동일한 방법으로 진행해보겠습니다.\n\n```rust\nlet (l_bp, ()) = postfix_binding_power(op);\nif l_bp \u003c min_bp {\n    break;\n}\n\nlet (l_bp, r_bp) = infix_binding_power(op);\nif l_bp \u003c min_bp {\n    break;\n}\n```\n\n근데 뭔가 이상합니다. 전위 표현식을 파싱한 이후에는, 중위 연산자 **혹은** 후위 연산자를 만날 수 있습니다. 하지만 우리는 이미 등록되어있지 않은 연산자에 대해서는 그냥 `panic!`을 해버립니다. 후위연산자가 없는 경우에는 중위연산자를 찾아보도록 코드를 바꿔봅시다. 그러기 위해 `postfix_binding_power`이 option 타입을 돌려주도록 하겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        // CHANGE START\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n\n            lexer.next();\n            lhs = S::Cons(op, vec![lhs]);\n\n            continue;\n        }\n        // CHANGE END\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp \u003c min_bp {\n            break;\n        }\n\n        lexer.next();\n        let rhs = expr_bp(lexer, r_bp);\n\n        lhs = S::Cons(op, vec![lhs, rhs]);\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -\u003e ((), u8) {\n    match op {\n        '+' | '-' =\u003e ((), 5),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -\u003e Option\u003c(u8, ())\u003e {\n    let res = match op {\n        '!' =\u003e (7, ()),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (10, 9),\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"-9!\");\n    assert_eq!(s.to_string(), \"(- (! 9))\");\n\n    let s = expr(\"f . g !\");\n    assert_eq!(s.to_string(), \"(! (. f g))\");\n}\n```\n\n신기하게도 기존 테스트와 신규 테스트 모두 통과합니다.\n\n### 괄호 표현식\n\n새로운 표현식을 처리해봅시다. 바로 괄호 표현식인데요, 생각보다 어렵지 않습니다. 괄호 표현식은 꽤 기초적인 표현식으로 아톰과 비슷한 방식으로 처리할 수 있습니다.\n\n```rust\nlet mut lhs = match lexer.next() {\n    Token::Atom(it) =\u003e S::Atom(it),\n    Token::Op('(') =\u003e {\n        let lhs = expr_bp(lexer, 0);\n        assert_eq!(lexer.next(), Token::Op(')'));\n        lhs\n    }\n    Token::Op(op) =\u003e {\n        let ((), r_bp) = prefix_binding_power(op);\n        let rhs = expr_bp(lexer, r_bp);\n        S::Cons(op, vec![rhs])\n    }\n    t =\u003e panic!(\"bad token: {:?}\", t),\n};\n```\n\n하지만 이 테스트는 아직 통과하지 않습니다.\n\n```rust\nlet s = expr(\"(((0)))\");\nassert_eq!(s.to_string(), \"0\");\n```\n\n에러는 `loop` 블록에서 발생합니다. 현재 코드에서, 반복문에서 빠져나오는 유일한 조건은 `Eof`를 만났을 때입니다. 근데 이 지점에서 `)`를 만나면서, 이 `)` \"연산자\"가 밑에 있는 `infix_binding_power`에 넘겨지며 `panic!`을 하는 것이지요. 이를 해결하기 위한 가장 쉬운 방법은 `infix_binding_power`도 `postfix_binding_power`와 마찬가지로 식별하지 못한 연산자에 대해서는 option을 돌려주게 하는 것입니다.\n\n이제는 테스트가 잘 통과하네요!\n\n### 배열 접근 연산자 `[]`\n\n이제 배열 접근 연산자인 `a[i]`를 구현해봅시다. 지금까지 본 연산자들은 전위, 중위, 후위와 같이 분류할 수가 있었습니다. 이건 뭘까요? 그냥 `a[]`와 같이 생겼었다면 후위연산자였을 것이고, `[i]`였다면 괄호 표현식과 동일하게 동작했을 것입니다. 하지만 괄호 표현식과 비슷한 점이 있다면 괄호 안에 있는 표현식은 우선순위에 얽매이지 않는다는 겁니다. 한번 코드를 보겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op('(') =\u003e {\n            let lhs = expr_bp(lexer, 0);\n            assert_eq!(lexer.next(), Token::Op(')'));\n            lhs\n        }\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n            lexer.next();\n\n\t\t\t// CHANGE START\n            lhs = if op == '[' {\n                let rhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(']'));\n                S::Cons(op, vec![lhs, rhs])\n            } else {\n                S::Cons(op, vec![lhs])\n            };\n\t\t\t// CHANGE END\n            continue;\n        }\n\n        if let Some((l_bp, r_bp)) = infix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n\n            lexer.next();\n            let rhs = expr_bp(lexer, r_bp);\n\n            lhs = S::Cons(op, vec![lhs, rhs]);\n            continue;\n        }\n\n        break;\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -\u003e ((), u8) {\n    match op {\n        '+' | '-' =\u003e ((), 5),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -\u003e Option\u003c(u8, ())\u003e {\n    let res = match op {\n        '!' | '[' =\u003e (7, ()), // 1\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -\u003e Option\u003c(u8, u8)\u003e {\n    let res = match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (10, 9),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\n#[test]\nfn tests() {\n    ...\n    let s = expr(\"x[0][1]\");\n    assert_eq!(s.to_string(), \"([ ([ x 0) 1)\");\n}\n```\n\n1. `!`과 `[`에 동일한 우선순위를 부여한 것이 보이나요? 일반적으로는 이 알고리즘의 correctness를 위해서 우선순위가 겹치지 않게 하는 것이 꽤 중요합니다. 하지만 우리가 결합 세기를 비교하는 경우에는, **오른쪽 결합 세기**와 **왼쪽 결합 세기**만 비교하기 때문에, 두 후위연산자의 결합 세기가 겹쳐도 문제가 생기지 않습니다.\n\n### 삼항연산자 `? :`\n\n최종 보스를 만나보겠습니다. 바로 삼항연산자입니다.\n\n```plaintext\nc ? e1 : e2\n```\n\n이건 어떻게 분류해야 할까요?? 한번 기호만 살짝 바꿔보겠습니다.\n\n```plaintext\nc [ e1 ] e2\n```\n\n감이 잡히나요? 앞부분에서 `a[i]`는 후위연산자 + 괄호표현식인 것을 보았습니다. 그러니 어떻게 보면 삼항연산자는 `a[i]`의 변형된 형태라고 생각할 수 있습니다. 이제 결합 세기와 방향을 생각해보겠습니다. 이런 경우에는 결합 방향이 어떻게 될까요?\n\n```plaintext\na ? b : c ? d : e\n```\n\n더 단순하게 보기 위해 좀 생략된 표현을 보겠습니다.\n\n```plaintext\na ?: c ?: e\n```\n\n위 표현식은 이렇게 파싱하거나:\n\n```plaintext\n(a ?: c) ?: e\n```\n\n이렇게 파싱할 수도 있습니다.\n\n```plaintext\na ?: (c ?: e)\n```\n\n무엇이 더 유용할까요? 이렇게 연속으로 사용하는 경우에는:\n\n```plaintext\na ? b :\nc ? d :\ne\n```\n\n오른쪽으로 결합하는 쪽이 더 유용할 것 같네요. 결합 세기의 경우에는, 꽤 낮은 우선순위를 가지고 있습니다. [C언어에서는](https://en.cppreference.com/w/c/language/operator_precedence) `=`와 `,`만이 더 낮은 우선순위를 가지고 있습니다.\n\n아래 코드를 통해 저희의 완성된 프랫 파서를 볼 수 있습니다.\n\n```rust\nuse std::{fmt, io::BufRead};\n\nenum S {\n    Atom(char),\n    Cons(char, Vec\u003cS\u003e),\n}\n\nimpl fmt::Display for S {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            S::Atom(i) =\u003e write!(f, \"{}\", i),\n            S::Cons(head, rest) =\u003e {\n                write!(f, \"({}\", head)?;\n                for s in rest {\n                    write!(f, \" {}\", s)?\n                }\n                write!(f, \")\")\n            }\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Token {\n    Atom(char),\n    Op(char),\n    Eof,\n}\n\nstruct Lexer {\n    tokens: Vec\u003cToken\u003e,\n}\n\nimpl Lexer {\n    fn new(input: \u0026str) -\u003e Lexer {\n        let mut tokens = input\n            .chars()\n            .filter(|it| !it.is_ascii_whitespace())\n            .map(|c| match c {\n                '0'..='9'\n                | 'a'..='z' | 'A'..='Z' =\u003e Token::Atom(c),\n                _ =\u003e Token::Op(c),\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        tokens.reverse();\n        Lexer { tokens }\n    }\n\n    fn next(\u0026mut self) -\u003e Token {\n        self.tokens.pop().unwrap_or(Token::Eof)\n    }\n\n    fn peek(\u0026mut self) -\u003e Token {\n        self.tokens.last().copied().unwrap_or(Token::Eof)\n    }\n}\n\nfn expr(input: \u0026str) -\u003e S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(\u0026mut lexer, 0)\n}\n\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op('(') =\u003e {\n            let lhs = expr_bp(lexer, 0);\n            assert_eq!(lexer.next(), Token::Op(')'));\n            lhs\n        }\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n            lexer.next();\n\n            lhs = if op == '[' {\n                let rhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(']'));\n                S::Cons(op, vec![lhs, rhs])\n            } else {\n                S::Cons(op, vec![lhs])\n            };\n            continue;\n        }\n\n        if let Some((l_bp, r_bp)) = infix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n            lexer.next();\n\n            lhs = if op == '?' {\n                let mhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(':'));\n                let rhs = expr_bp(lexer, r_bp);\n                S::Cons(op, vec![lhs, mhs, rhs])\n            } else {\n                let rhs = expr_bp(lexer, r_bp);\n                S::Cons(op, vec![lhs, rhs])\n            };\n            continue;\n        }\n\n        break;\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -\u003e ((), u8) {\n    match op {\n        '+' | '-' =\u003e ((), 9),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -\u003e Option\u003c(u8, ())\u003e {\n    let res = match op {\n        '!' =\u003e (11, ()),\n        '[' =\u003e (11, ()),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -\u003e Option\u003c(u8, u8)\u003e {\n    let res = match op {\n        '=' =\u003e (2, 1),\n        '?' =\u003e (4, 3),\n        '+' | '-' =\u003e (5, 6),\n        '*' | '/' =\u003e (7, 8),\n        '.' =\u003e (14, 13),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\");\n\n    let s = expr(\"a + b * c * d + e\");\n    assert_eq!(s.to_string(), \"(+ (+ a (* (* b c) d)) e)\");\n\n    let s = expr(\"f . g . h\");\n    assert_eq!(s.to_string(), \"(. f (. g h))\");\n\n    let s = expr(\" 1 + 2 + f . g . h * 3 * 4\");\n    assert_eq!(\n        s.to_string(),\n        \"(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))\",\n    );\n\n    let s = expr(\"--1 * 2\");\n    assert_eq!(s.to_string(), \"(* (- (- 1)) 2)\");\n\n    let s = expr(\"--f . g\");\n    assert_eq!(s.to_string(), \"(- (- (. f g)))\");\n\n    let s = expr(\"-9!\");\n    assert_eq!(s.to_string(), \"(- (! 9))\");\n\n    let s = expr(\"f . g !\");\n    assert_eq!(s.to_string(), \"(! (. f g))\");\n\n    let s = expr(\"(((0)))\");\n    assert_eq!(s.to_string(), \"0\");\n\n    let s = expr(\"x[0][1]\");\n    assert_eq!(s.to_string(), \"([ ([ x 0) 1)\");\n\n    let s = expr(\n        \"a ? b :\n         c ? d\n         : e\",\n    );\n    assert_eq!(s.to_string(), \"(? a b (? c d e))\");\n\n    let s = expr(\"a = 0 ? b : c = d\");\n    assert_eq!(s.to_string(), \"(= a (= (? 0 b c) d))\")\n}\n\nfn main() {\n    for line in std::io::stdin().lock().lines() {\n        let line = line.unwrap();\n        let s = expr(\u0026line);\n        println!(\"{}\", s)\n    }\n}\n```\n\n코드는 [이 레포](https://github.com/matklad/minipratt)에서도 확인해볼 수 있습니다. Eof.\n","title":"Simple but Powerful Pratt Parsing","tags":["parsing","ko"],"date":"2023-04-30"},{"id":"20230415-after-navy-software-developer","content":"\n2021년 9월 입대하기 직전에 블로그 하나는 갖고 싶다는 생각이 들어 부랴부랴 블로그를 만들었다. 그리고 해군 개발병에 대한 정보가 인터넷에 워낙 부족했어서 이를 조금이라도 해소하고 싶어 지원 후기를 작성했었다. 그 기억들이 아직 생생한데, 지금 전역을 앞두고 있는 나를 보니 군생활이 생각보다 빨리 지나간 것 같다. 이 글에는 **개발병으로서** 복무한 후기를 적어보겠다. 누군가에게 이 글이 도움이 됐으면 좋겠다.\n\n## 실제로 개발을 하나요?\n\n내가 가장 걱정했던 부분 중 하나이다. 많은 정보를 알지 못한 채 훈련소에 입대했었는데, 그 기수에는 개발병이 나 혼자였다(21\\~22년 기준 평균 2기수당 1\\~2명 입대). 그래서 훈련소 동기들은 물론, 훈련소에 있는 훈련 교관들도 개발병 직별에 대해 모른다. 밖이랑 단절된 채로 6주를 있으려니 자대는 어딘지, 진짜 개발은 하는지, 그냥 다른 전산병들이랑 같이 컴퓨터 정비를 하게 되진 않을지 고민하다 보면 별걸 다 상상하게 된다. 옆에 있는 훈련소 동기들에게, \"진짜 개발 하겠어? 그냥 컴퓨터 좀 고치겠지\"라는 말을 몇번 듣고 나면 꽤 불안해진다. 근데 알고보니 자대는 한 곳으로 정해져 있고(면접본 곳), 주 업무는 정말 개발이 맞았었다. 오히려 개발을 실컷 할 수 있다. 개발 가능한 인력이 병밖에 없기 때문이다.\n\n## 개발 환경은 어떤가요?\n\n사무실에서는 앱/웹에 올라가는 다양한 프로젝트를 진행한다. 때문에 프로젝트의 특성은 제각각이지만, 그 중 인트라넷 환경에 대해 이야기해보고 싶다.\n\n군 부대는 보안 유지를 위해 인트라넷을 사용한다. 쉽게 말해 전국의 군 부대들이 사용하는 폐쇄망이 있다는 건데, 이는 인터넷이랑 연결되어있지 않다. 개발 또한 인트라넷 환경에서 하는데, 이로 인해 생기는 문제가 몇 가지 있다.\n\n우선 패키지 다운로드에 제약이 생긴다. 요새 라이브러리 없이 개발하는 건 상상하기 힘들다. 특히 웹, 앱 개발은 정말 많은 라이브러리의 기능을 가져다 쓰는데, 인터넷 접속이 안된다는 것은 `npm`이나 `maven`의 접속이 안된다는 이야기다. 따라서 패키지를 외부에서 다운받아 보안절차를 거쳐 인트라넷으로 가져오는데, 보안절차가 사이에 있는 것이 개발생산성 측면에서 꽤 방해가 된다. 미리 설치해서 가져온다는 건 무엇을 쓸지 한번에 생각해서 전부 미리 받아온다는 것인데, 무엇을 쓸지 미리 생각한다는 것이 쉽지가 않다.\n\n다음으로는 재사용 문제가 있다. 인터넷에서 인트라넷으로 패키지를 들고 와 사용한다고 이야기를 했는데, 슬프게도 힘들게 가져온 패키지를 다른 프로젝트에 재사용하기가 쉽지많은 않다. 어떤 패키지의 의존성을 수동으로 확인하기가 너무 어렵고, 의존성의 버전도 여러 가지가 있기 때문이다.\n\n패키지뿐만이 아니다. 개발 툴들도 취향껏 쓰기가 어렵다. 이유는 앞과 동일한데, 그래서 기존에 인트라넷에 있는 툴들을 사용하는 데 어느정도 만족해야 한다. 이 부분은 라이브러리도 마찬가지다. 나는 리눅스 환경을 선호해서 WSL을 쓰고 싶었는데 그러지 못해서 아쉬웠다.\n\n## 성장할 수 있었나요?\n\n같이 한 사람들 모두가 동의할지는 모르겠으나, 개인적으로 많이 배울 수 있는 직별이라고 느낀다. 자대에 처음 갔을 때는, 물론 그만한 이유는 있었지만 개발자 입장에서는 상대적으로 열악한 환경에 실망했다. 하지만 오히려 환경에 조금 제약이 있으니 같은 문제여도 고민을 더 많이 하고, 환경을 개선하기 위해 직접 노력할 수 있는 부분이 있어 경험을 쌓을 수 있었다. 나는 자바에 대해 원래 악감정이 있었는데 가서 백엔드 개발을 자바와 스프링으로 해야 했었다. 덕분에 처음으로 스프링(부트 X. 레거시 O)을 배워볼 기회가 생겼고, 사용해보니 꽤 좋은 프레임워크라는 것을 느꼈다. 또한 비록 언어로서의 단점은 존재하는 자바지만, 언어를 둘러싼 생태계가 정말 탄탄하다는 것을 알게 되었다. 사실 자바는 언어로서도 이미 꽤 많이 발전했는데, 아직 많은 사용자들이 자바 1.8 / 11에 머무느라(현재 자바 20까지 출시됨) 그 기능들과 향상된 JVM을 사용하지 못하고 있다는 것은 슬픈 일이다.\n\n병 1~2명이 한 프로젝트를 주도하기 때문에 직접 해결해야 하는 문제들도 많았다. 병으로 입대하는 사람이면 보통 나이가 20대 초중반인데, 나는 방학 때 인턴 몇 번 빼곤 학교만 다니다 갔고, 주변에 회사생활 몇 년 하고 온 사람들도 있지만 병들 실력이 많이 해봐야 주니어 정도다. 하지만 그곳에선 모든 개발을 해야 하니 이곳저곳에서 문제를 많이 만나기 마련이었다. 그래서 내가 만든 서비스를 쓰는 사용자들에게는 조금 미안하지만 오히려 나에게는 직접 경험을 쌓을 수 있는 시간이기도 했다.\n\n여가시간도 충분했다. 근무시간에 개발을 하지 않았어도 여가시간을 잘 활용하면 개발 공부를 충분히 할 수 있는 시간이었다. 나는 여가시간에 폰하고 테니스를 많이 했다.\n\n무엇보다 함께 지내는 선후임 병사들이 정말 좋은 사람들이었다. 어느정도 같은 분야를 공부하는 사람들끼리 다같이 있으니 평소에 개발 이야기도 할 수 있고, 좋은 개발 서적들도 주변에서 많이 추천해줘서 유익한 경험을 할 수 있었다.\n\n## 총평\n\n전체적으로 꽤 만족하는 편이다. 힘든 점이 있다면 당직근무가 꽤 자주 있었다는 점이지만, 준비를 좀 한다면 그보다 많은 편의를 자대에서 누릴 수 있는 직별이라고 생각한다. 또 이 글에서는 개발 이야기만 주로 했으나 부대 자체가 워낙 좋은 편이고, 주변 사람들도 좋아서 흔히 얘기하는 악성 선후임을 볼 일이 거의 없는 점도 큰 메리트이다.\n","title":"해군 SW 개발병 복무 후기","tags":["general","diary","military","ko"],"date":"2023-04-15"},{"id":"20230108-linkwaiter","content":"\n링크 페이지를 개업하면서 오랜만에 블로그를 업데이트했다. 미디어 쿼리를 손본다거나 폰트 사이즈를 반응형으로 바꾼다거나 주로 모바일에서 더 볼만하게 하는 변화들이었다.\n\n링크 페이지를 개업한 이유는 지극히 개인적이다. 난 유튜브나 레딧에서 개발 관련 영상이나 게시물이 자주 추천되는 편이다. 해당 자료들을 통해 조금씩 관련 분야 지식들을 쌓는 편인데, 문제가 하나 있다. 좋은 게시물이나 영상들은 보통 길이와 깊이가 꽤 된다는 점이다. 그래서 휴대폰에서 어떤 좋은 링크를 접하게 되었을 때 그걸 한 번 앉아서 끝까지 읽을 수가 없다. 보통 집중할 수 있는 환경도 아니고, 결심하고 읽어야 이해할 수 있을 것 같은 자료들도 꽤 많다. 특히나 휴대폰으로는 다른 딴짓을 하기 꽤 쉬워서 읽다가 탭을 닫고 잊어버리는 일도 자주 있다. 이러한 문제점으로 인해 내 관심사는 계속 바뀌는 데에 반해 조금이라도 알아보고 넘어가는 경우가 많이 없다는 것을 오랜 시간이 지난 뒤에야 알았다.\n\n그래서 흥미로운 링크들을 한 곳에 모아둘 필요성을 느꼈고, 돌아보니 그렇게 하는 사람들을 꽤 많이 본 적이 있었다는 것이 기억났다. 링크 페이지를 블로그에 추가하기로 하였고 바로 페이지를 만들었다. 링크들은 [이 섹션](https://pacokwon.org/links)에서 확인할 수 있다.\n\n이 링크들을 어떻게 관리할지 또한 문제였다. 흥미로운 링크를 마주칠 때 빠르게 쌓아둘 수 있는 구조여야 하고, 블로그에도 그 변경사항을 반영할 수 있어야한다. 근데 이 블로그는 정적으로 만들어져 있고, 링크를 추가하고 싶다고 코드를 직접 수정하는건 너무 접근성이 떨어지는 방법이었다. 서버 애플리케이션이 하나 필요하다는 것이 거의 당연해져서 간단한 프로젝트를 하나 만들기로했다. 당시에는 내가 [Elixir](https://elixir-lang.org)라는 언어에 관심이 높았을 때라 Elixir를 배워보는 김에 링크를 쉽게 등록할 수 있는 웹 기반 페이지를 작성했다. Elixir에는 [Phoenix Framework](https://www.phoenixframework.org/)라는 평가가 좋은 서버 프레임워크가 있는데, 너무 기능이 많은 것 같아서 Phoenix가 기반을 두고 있기도 한 [Plug](https://github.com/elixir-plug/plug)로 백엔드를 작성했다. 써보니 Plug는 정말 barebones여서 실제 프로젝트에는 쓰기 어려울 것 같았지만 이 링크 관리 페이지를 만드는 데에는 좋은 경험이었고, 특히 [이 발표](https://www.youtube.com/watch?v=Z0Z4wu4CPgQ\u0026t=1364s)가 정말 유익했다.\n\n결과적으로 링크 관리 페이지를 이용해 원할 때 블로그의 데이터를 수정해서 직접 Github에 push를 하여 자동 업데이트되도록 만들었고, 아직까지는 만족스럽게 동작하고 있다. 관리 페이지 구현체는 [이곳](https://github.com/pacokwon/linkwaiter)에 있다. 이를 적극 활용하여 흥미로운 것이 많을 때는 페이지에 잘 쌓아두고, 흥미로운 것이 떨어질 때는 페이지에서 잘 뽑아 공부해야겠다.\n","title":"링크 페이지 개업","tags":["blog","links"],"date":"2023-01-08"},{"id":"20210920-devenv-neovim","content":"\n이 글에는 내가 주로 사용하는 neovim 에디터 환경설정, 그 중 플러그인에 대해 적어보려 한다 (한마디로 별 쓸데없음).\n\nneovim이 `0.5.0` 업데이트 이후로 lua의 first class support를 추가하였고, 점점 쓰기 편하게 개발이 진행되고 있는 상태이다. 나는 vimscript와 lua 모두 아주 잘 알지는 않지만 그냥 궁금해서 환경설정 일부는 lua로 바꿔둔 상태이다. 물론 이렇게 하고 나니 그냥 vim 쓸 때는 호환이 안되는게 좀 불편해서 vim 용 설정은 따로 유지를 해야 하나 싶다...암튼 그래서 내 현재 neovim 설정은 일부가 lua로 적혀있을 뿐만 아니라 아주 많은 lua plugin을 사용하고 있다.\n\n내 환경설정은 [여기](https://github.com/pacokwon/nvim-config)에서 관리하고 있다. 현재 설정 모습은 이렇다.\n\n```plaintext\n.\n├── init.vim            # config root file\n└── lua                 # configs written in lua\n   ├── colors.lua       # theme\n   ├── init.lua         # root file written in lua\n   ├── mappings.lua     # keymappings\n   ├── opts.lua         # editor options\n   └── plugins          # plugin configuration\n```\n\n## Plugin Manager\n\n나는 한동안 `vim-plug` 를 사용하다가 `packer.nvim` 으로 플러그인 매니저를 갈아탄 상태다. lua로 작성돼있다. 유저도 많고 굉장히 빠르다고 되어있길래 한 번 갈아타봤는데 실제로 빠른 것 같기도 하고 별 문제없이 작동하는 것 같아서 그냥 계속 사용하고 있는 중이다.\n\n## Plugins\n\n내가 주로 사용하는 플러그인 목록이다. 실제 사용하는건 나열한 것의 1.5 ~ 2배 정도 되지 않을까 싶다.\n\n### [nvim-miniyank](https://github.com/bfredl/nvim-miniyank)\n\nclipboard를 system clipboard로 연결해둔 상태일 때 neovim에서 Visual Block 붙여넣기가 잘 작동하지 않는 버그가 있다. 이유가 뭔지는 까먹었었는데 플러그인의 형태로 솔루션이 존재해서 사용하고 있다.\n\n### [galaxyline.nvim](https://github.com/glepnir/galaxyline.nvim)\n\n아주 미니멀하고 커스터마이징이 쉬운 statusline이다. 모든 걸 직접 설정해줘야 한다는 장벽이 있지만 한번 설정해놓으면 문제없다. 그래서 아주 심플한 statusline을 쓰고 있다. lua로 되어있다.\n\n### [lspsaga.nvim](https://github.com/glepnir/lspsaga.nvim)\n\n아주 필수적인 플러그인은 아니다. 나는 LSP diagnostics를 조금 더 꾸며진 floating window에서 보고 싶어서 설치해 두었다. LSP hover docs의 경우 요 플러그인에서 제공하는 함수를 사용하고 있었는데 lspconfig 플러그인에서 거의 같은 기능을 제공하고 있어서 갈아탔었다. diagnostic 쪽도 같은 기능을 lspconfig에서 제공하고 있으면 그냥 안 써도 무방할 것 같다.\n\n### [nvim-compe](https://github.com/hrsh7th/nvim-compe)\n\nLSP autocompletion을 completion list로 보여주는 플러그인이다. 이미 LSP가 있어도 이러한 플러그인이 있어야 LSP 자동완성을 편하게 사용할 수 있다.\n\n아마 지금 글 쓰는 시점에서는 deprecated된 것으로 아는데 아무 문제 없어서 그냥 쓰고 있다ㅋㅋ듣기로는 같은 개발자의 `nvim-cmp` 라는 플러그인이 거의 같은 역할을 하는데 scalability를 염두에 두고 다시 작성한 것으로 알고 있다.\n\n처음에 LSP 지원이 나왔을 때는 `nvim-completion` 인가? 라는 플러그인이 거의 유일했는데 이게 훨씬 나아서 나 포함해서 사람들이 요걸로 갈아탔었다.\n\n### [fzf.vim](https://github.com/junegunn/fzf.vim)\n\n`fzf` 라는 fuzzy finder를 vim에서 쉽게 사용할 수 있도록 한 wrapper이다. 놓칠 수 없는 플러그인들 중 하나다. 매우 빠르다는 것이 장점이고 Silver Searcher, ripgrep, fd 등 내부에서 사용하는 커맨드 또한 변경 가능해서 gitignore를 respect하게 하는 등의 기능 또한 가능하다.\n\n### [gitsigns.nvim](https://github.com/lewis6991/gitsigns.nvim)\n\n라인마다 깃 상태를 보여주는 플러그인이다. 특정 줄들이나 블록을 stage, unstage, reset하는 함수들을 제공한다. vscode의 gitlens에서 제공하는 라인별 blame 정보 보여주기나, 깃 상태가 바뀐 줄에 대하여 floating window에서 diff를 보여주는 기능 또한 매우 유용하다. lua로 작성되어 있으며 이전에는 gitgutter라는 vim 플러그인을 썼었다.\n\n### [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n\nLSP 설정을 위한 플러그인이다. LSP Client 기능 자체는 neovim에 내장되어 있지만, 설정을 간편하게 해주는 용도로 존재하는 플러그인이다. LSP가 없으면 안되는 것은 아니지만 사용하게 되면 삶의 질이 많이 올라가기 때문에 나는 되도록이면 쓰려고 한다. 근데 설정이 좀 어려운 경우도 있기는 하다.\n\n### [nvim-treesitter](https://github.com/nvim-treesitter/nvim-treesitter)\n\nTreesitter 설정을 위한 플러그인이다. 설정에서 어떤 언어들에 대하여 treesitter를 사용할지 선택할 수 있고, 그에 따른 treesitter syntax highlighting을 제공한다. 훨씬 일관적인 highlighting을 사용할 수 있다. 이 플러그인이 있으면 언어별로 추가적인 highlight group을 담고 있는 플러그인을 설치해서 사용할 필요가 없어진다.\n\n### [pears.nvim](https://github.com/steelsojka/pears.nvim)\n\nautopairs 플러그인이다. lua로 작성되어 있으며 내가 한창 lua로 작성된 플러그인들을 시도하던 와중 갈아탔었다. autopairs라는 것은 예를 들어 `(` 를 입력하면 그 옆에 `)` 가 자동으로 입력된다거나, `)` 바로 왼쪽에서 `)` 를 누르면 해당 문자를 한 번 더 적는 게 아니라 알아서 건너뛰는 기능을 이야기한다. 근데 이 플러그인의 경우 개발이 활발하지는 않아서 엄청 추천하지는 않는다. 오히려 기존에 사용하던 jiangmiao의 auto-pairs가 기능도 조금 더 많고 안정적인 것 같다. lua로 작성된 다른 autopairs 플러그인도 많다.\n\n### [vim-commentary](https://github.com/tpope/vim-commentary)\n\n주석 처리용 플러그인이다. 놓칠 수 없는 플러그인들 중 하나다. 설치를 하면 `gc` 라는 verb가 생긴다. verb라는 것은 `d`, `c`, `v` 같은 동작을 하는 키바인딩을 이야기한다. 예를 들어 `gcj` 를 입력하면 현재 줄과 아래 줄이 주석 처리된다. 매우 편리하고 사용하기도 자연스러워서 그냥 vim 코어에 통합돼도 아무 문제가 없을 것 같다.\n\n### [vim-surround](https://github.com/tpope/vim-surround)\n\n`(`, `{`, `[`, `'`, `\"` 처럼 짝꿍이 있는 문자들을 위한 플러그인이다. 놓칠 수 없는 플러그인들 중 하나다. 설치하면 `ys`, `ds`, `cs` 등의 verb가 생긴다. 예를 들어 `ysiw(` 를 하면 현재 커서가 있는 단어를 `()` 로 감싼다. `ds(` 를 하면 괄호를 삭제하고, `cs({` 를 하면 소괄호를 중괄호로 바꿔준다. 용법이 매우 자연스럽고 이것도 그냥 코어에 통합돼도 문제 없을 것 같은데...\n\n### [vim-fugitive](https://github.com/tpope/vim-fugitive)\n\nGit wrapper 플러그인이다. 플러그인 중 거의 1순위다. 있으면 git 관리가 정말 편해진다.\n\n## Colorschemes\n\n테마도 신경쓰는 편이다. 나는 대체로 high contrast 테마를 좋아한다.\n\n- [tokyonight.nvim](https://github.com/folke/tokyonight.nvim) - 차가운 계열의 테마다\n- [srcery-vim](https://github.com/srcery-colors/srcery-vim) - 따뜻한 계열의 테마다\n- [modus-theme-vim](https://github.com/ishan9299/modus-theme-vim) - high contrast 만땅이면서 색깔이 마음에 든다\n- [panic.vim](https://github.com/pacokwon/panic.vim) - 역시 high contrast 만땅이다. 다만 유지보수가 되고 있지는 않아서 fork해서 내가 사용하는 플러그인들에서 요하는 highlight group들을 추가해 쓰는 중이다.\n- [onedarkhc.vim](https://github.com/pacokwon/onedarkhc.vim) - 기존에 있던 onedark의 색깔들을 수정해서 조금 더 high contrast로 만들어 두었다. 사실 색깔만 바꾼거라 fork하는게 맞는데 1학년 때 암 생각없이 만들었어서 README에 credit만 해놓은 상태다.\n","title":"Development Environment - Neovim","tags":["neovim","ko"],"date":"2021-09-20"},{"id":"20210914-chip8-emulator-in-rust","content":"\nRust로 뭔가는 만들어보고 싶은데 마침 에뮬레이터도 만들어보고 싶어서 입문용 프로젝트로 많이 한다는 Chip-8 에뮬레이터를 작성해보려고 한다. 아직 시작도 안했기 때문에 여기 적을 내용은 많지 않다. 이 포스트를 업데이트해가며 짜려고 한다.\n\n### Update:\n\n생각보다 instruction 개수가 적고 구조도 단순한 편이라 구현이 이틀 정도만에 완성되었다. 좀 생소했던 부분들은 크게 두 가지였는데, 첫 번째는 opcode 구현 시 명세가 인터넷에 있는 참고자료마다 다른 경우가 있었다는 거다. 그래서 뇌피셜 + 다수의 의견을 따라 구현을 했다. 두 번째는 SDL2 사용인데, [SDL2 binding for Rust](https://github.com/Rust-SDL2/rust-sdl2) 의 문서화가 꽤 잘 돼있어서 데모 코드를 참고하니 생각보다 수월했다.\n\n아주 제대로 된 테스팅은 진행하지 않았지만 [테스트 ROM](https://github.com/corax89/chip8-test-rom) 형태로 아주 손쉽게 테스팅해볼 수 있는 방법이 있어서 이 ROM을 실행해보긴 했다. 이 ROM을 통해 잡은 버그는 Rust에서 정수 연산 오버플로우가 자동으로 되지 않는다는 점이었다. 그래서 거의 모든 연산 부분을 그냥 오버플로우가 되도록 수정했다. `Wrapping`이라는 타입으로 해야 하던데 퍼포먼스 저하는 없는 것으로 알고 있다. 그냥 코드가 조금 더 verbose해질 뿐..\n\n오디오 구현은 안(못)했는데 큰 관점에서 중요도가 떨어지는 반면 trivial한 해결 방법이 없어 그냥 냅둔 상태이다. `'\\a'` 코드처럼 삑 소리만 나도 충분할 것 같던데 오래된 규약이다 보니 기기마다 `'\\a'` 가 작동하지 않는 경우도 C 프로그래밍을 할 때 종종 보았는데 Rust에서는 그냥 지원이 안 되는 것 같았다. 뭔가 내가 모르는 쉬운 방법을 찾거나 아주 미니멀한 오디오 라이브러리를 사용하면 될 것 같다.\n\n이 작은 프로젝트를 통해 에뮬레이터를 조금 더 자세히 이해할 수 있었던 것 같다. 그 다음 단계는 NES나 Gameboy 에뮬레이터 구현일텐데, 난이도 상승 폭이 조금 큰 것으로 보인다.\n\n## Repository\n\nhttps://github.com/pacokwon/scaters\n\n## References\n\n참고자료들이다. 꽤 오래된 매뉴얼들인데 필요한 내용은 모두 담고 있고 상당히 도움이 많이 되었다.\n\n- http://www.cs.columbia.edu/~sedwards/classes/2016/4840-spring/designs/Chip8.pdf\n- http://devernay.free.fr/hacks/chip8/C8TECH10.HTM\n","title":"Building a Chip-8 Emulator in Rust","tags":["rust","emulator","ko"],"date":"2021-09-14"},{"id":"20210913-neovim-users-perspective","content":"\nIt's been two years since I've first used Vim.\n\nThe reason I started to learn Vim was because I saw so many experience programmers using it. I thought that there must be something special to it, and I had to give it a try.\n\nIt wasn't easy at first. There certainly is a learning curve, and I often was tempted to go back to my old editor. But once I got used to it, it only got better from there. I loved the speed, the efficient keybindings, the ecosystem of plugins, and the fact that it's still a minimal editor that I configured for myself.\n\nThen there was Neovim. The first time I've heard about it was from [coc.nvim](https://github.com/neoclide/coc.nvim), which was one of the few plugins that had great LSP support out of the box. It was from then I started using Neovim.\n\nI suspect that Neovim was version `0.4.x` at the time. I couldn't feel _any_ differences from Vim whatsoever, but it turns out Neovim at that time was in the verge of a major breakthrough: `0.5.0`.\n\n## Neovim `0.5.0`\n\nNeovim `0.5.0` introduced a ton of new updates to the editor, as a user, there were 3 major featuresthat were added in this release.\n\n### Built-in LSP client support\n\nThe Language Server Protocol is a spec that allows independent \"language servers\" to communicate with and provide useful functionalities such as `Hover Docs`, `Goto Definition`, `Format` to editors that implement a \"language client\". The separation of responsibilities allowed: language servers to do what they do best, and editors to offer rich features without implementing it themselves.\n\nPreviously, plugins were acting as LSP clients to communicate with the respective servers, and this is what coc.nvim was doing really well. But I felt guilty using it because one could easily see that it was a little bloated. It did too many things at once, not to mention that it spawned node processes in the background.\n\nThe built-in LSP support in the `0.5.0` release allowed users to configure lsp servers to their own preference by providing a generic configuration interface. It felt minimal, it was less laggy, I knew what it was doing, and I loved it. One downside might be that it requires a fair amount of code to configure.\n\n### tree-sitter syntax highlighting support\n\nThe way Vim does highlighting is through regexes (AFAIK). It parses tokens through regexes and applies the corresponding highlight groups to them. tree-sitter is a replacement for this highlighting method.\n\ntree-sitter is a dedicated parser generator, meaning that it outputs a parser given a certain language's grammar. I've heard good things about tree-sitter such as its performance and tolerance to syntax errors, but I won't go further because I don't have background knowledge to back it up - for all I know, it does its job really well, and it is capable of providing consistent syntax highlighting across a ton of languages.\n\nSo far, the syntax highlighting that tree-sitter provides has been really great, and it's making me happy.\n\n### lua as a first class configuration language\n\nPreviously and still in Vim 8, vimscript remains the primary language for editor configuration. And vimscript is.. such an odd language. I tried learning it, but the experience was not so good. It was not like any other language that I've learned, and not in a good way either. IMO this would have certainly prevented some users from being able to comfortably write their `vimrc`s or plugins.\n\nAnd then lua came in. It's a very small scripting language that got integrated into Neovim from `0.5.0`. Unlike vimscript it's a general purpose language, it makes more sense and knowledge can be transferred from and to other languages more easily. This allowed users to write their `vimrc`s and plugins in lua and only using lua. The pace at which new plugins came out after lua was first integrated into Neovim was astonishing. Although there now exists incompatibilities between Vim and Neovim with lua plugins, I'm still very happy that the ecosystem is thriving much faster now.\n\nAs someone who loves using and making tools for developers, Neovim stands as my favorite open source project. And because of that, one of my goals is to try to create plugins and/or contribute to the Neovim project. At least I hope to do so.\n","title":"Neovim 0.5.0 - A User's Perspective","tags":["neovim","en"],"date":"2021-09-13"},{"id":"20210913-destructuring-refs-in-rust","content":"\nWhile teaching myself some Rust, it was common to see some code that \"looked like\" it was destructuring references, like:\n\n```rust\nfn main() {\n    let vec = vec![1, 2, 3];\n    let mut iter = vec.into_iter();\n\n    println!(\"Find 2 in vec: {:?}\", iter.find(|\u0026x| x == 2)); // Find 2 in vec: Some(2)\n}\n```\n\nAt first glance, the semantics were a little hard to predict. My curiosity all came down to this: does this copy the whole value? So I decided to write some code to make things clear.\n\n```rust\n#[derive(Debug,Clone,Copy)]\nstruct Foo {\n    a: u32,\n    b: u32,\n}\n\nfn main() {\n    let mut x = Foo { a: 3, b: 4 };\n    let \u0026mut mut y = \u0026mut x;        // destructure mutable reference, AND the variable is mutable\n    y.a = 50;\n    println!(\"{:?} {:?}\", x, y);    // ??\n}\n```\n\n### Output:\n\n```bash\nFoo { a: 3, b: 4 } Foo { a: 50, b: 4 }\n```\n\nA pretty minimal example here, but the syntax looks real weird. I actually had a hard time trying to express what I wanted to because of the syntax.\n\nOnce we try to mutate the struct's field, the output shows that only `y` is mutated. It shows us that it indeed copies the whole value.\n\nWhat if we try to destructure something that does not implement the `Copy` trait, like a vector?\n\n```rust\nfn main() {\n    let mut x = vec![1, 2, 3];\n    let \u0026mut mut y = \u0026mut x;\n    println!(\"{:?}\", y);\n}\n```\n\n### Output:\n\n```bash\nerror[E0507]: cannot move out of a mutable reference\n  --\u003e src/main.rs:10:22\n   |\n10 |     let \u0026mut mut y = \u0026mut x;\n   |         ----------   ^^^^^^\n   |         |    |\n   |         |    data moved here\n   |         |    move occurs because `y` has type `Vec\u003ci32\u003e`, which does not implement the `Copy` trait\n   |         help: consider removing the `\u0026mut`: `mut y`\n\nerror: aborting due to previous error; 1 warning emitted\n```\n\nPretty much the same example except that it's a vector, but the compiler complains for the exact reason why we tried this example in the first place. The destructure does not work because the `Vec` struct does not implement `Copy`. What I've understood from these examples, is that such destructuring is meant to be used on types that support cheap copying.\n\n## References\n\n- https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_pointers.html\n","title":"Destructuring \u0026 References in Rust","tags":["rust","quicknote","en"],"date":"2021-09-13"},{"id":"20210911-simple-state-monad","content":"\n_This post is based on [this video](https://www.youtube.com/watch?v=WYysg5Nf7AU) from Graham Hutton's playlist on advanced functional programming. I tried to write this post without rewatching the video, to deliver my own understanding of the concept._\n\n## Defining `State`\n\nState를 표현하는 어떤 값이 있을 때, 이 state를 변경시키는 어떤 black box가 있다고 하자. 그 black box는 이렇게 표현할 수 있을 것 같다.\n\n```haskell\nblackBox :: a -\u003e a -- where a denotes the state's type\n```\n\n이때 black box에서 input으로 들어온 state를 이용해 어떤 값을 계산한다고 가정한다면, 현재 함수의 타입 정보로는 해당 결과를 잘 표현하기 어렵다. 따라서 output을 두 개 돌려주는 다음과 같은 타입이 더 편리하다.\n\n```haskell\nblackBox :: a -\u003e (b, a) -- where a denotes the state's type, and b the return value's type\n```\n\n이러한 black box에 해당하는 새로운 타입을 다음과 같이 작성해보자. Record에 대해 매번 pattern match를 하는 것을 방지하기 위해, `State`와 state 값이 주어졌을 때, transformer를 호출해주는 helper 또한 정의하자.\n\n```haskell\nnewtype State a b = S {getState :: a -\u003e (b, a)}\n\nrunState :: State a b -\u003e a -\u003e (b, a)\nrunState S {getState = f} = f\n```\n\n0부터 시작하는 id를 생성하는 함수가 있다고 하자. 이러한 상황에서는 ST를 다음과 같이 표현하여 id를 뽑아낼 수 있을 것이다.\n\n```haskell\n-- Plain.hs\nnext :: State Int Int\nnext = S $ \\n -\u003e (n, n + 1)\n\nmain :: IO ()\nmain = do\n    let n0 = 0\n    let (id, n)     = runState next n0\n    let (id', n')   = runState next n\n    let (id'', n'') = runState next n'\n    print id        -- 0\n    print id'       -- 1\n    print id''      -- 2\n    print n''       -- 3\n```\n\n`next` 라는 state transformer를 사용하면 id를 하나 생성하고 state를 하나 증가시키는 것을 확인할 수 있다. 따라서 `id`, `id'`, `id''`등 `next` ST에 새로운 state를 input으로 넣어 생성한 id들은 각각 0, 1, 2, 3의 값을 가지게 된다.\n\n## 기존 방식의 문제점과 `bind` 함수\n\n위 코드에서 문제점이 있다고 할 수 있는 부분은 composition이 불편하다는 점이다. `runState` 는 새로운 state를 만들어 내기 때문에, 이 함수를 여러 번 호출해야 하는 상황에서는 최신 state를 잘 넘겨주도록 유의해야 한다. 이를 위해 매번 pattern match를 해야 하고, 매번 state를 explicit하게 넘겨주어야 한다. 흐름 상으로만 보면 반복되는 코드인데 필요는 하기 때문에 일종의 boilerplate인 것이다. 이는 코드를 작성할 때 error prone하고, 읽을 때도 불필요한 디테일이다. 다음과 같은 문제점을 monad를 통해 해결해보자!\n\n먼저 `bind` 함수를 정의해보자. `bind` 의 타입은 다음과 같다.\n\n```haskell\nbind :: m a -\u003e (a -\u003e m b) -\u003e m b\n```\n\n이때 `m` 은 type constructor으로, 현재 상황의 경우 `State s` 에 해당한다.\n\n```haskell\nbind :: State s a -\u003e (a -\u003e State s b) -\u003e State s b\n```\n\nstate transformation을 두 번 시행함으로써 구현할 수 있다.\n\n```haskell\nbind :: State s a -\u003e (a -\u003e State s b) -\u003e State s b\nbind sa f = S $ \\s -\u003e\n  let (a, s') = runState sa s in runState (f a) s'\n```\n\n이 함수만 있어도 composition이 더 깔끔해진다. 위에 있는 `main` 함수를 리팩토링해보자.\n\n```haskell\n-- Bind.hs\nnext :: State Int Int\nnext = S $ \\n -\u003e (n, n + 1)\n\nmain :: IO ()\nmain = fst $ runState (\n    next `bind` \\id -\u003e\n    next `bind` \\id' -\u003e\n    next `bind` \\id'' -\u003e\n    S $ \\s -\u003e (\n      do\n        print id\n        print id'\n        print id'',\n      s\n    ))\n  0\n```\n\n(표준 출력을 위한 IO 조작 코드가 있는데...무시하고 보자)\n\n`runState` 의 첫 번째 인자로 넘겨진 `State` 코드와, 위에 있는 리팩토링 이전 코드를 비교했을 때, trivial한 state 관리 코드가 아예 사라진 것을 확인할 수 있다. composition을 위해 매번 새로운 state를 다음 호출에 넘겨주던 패턴을 `bind` 라는 함수 안에 넣어두었기 때문에 핵심 코드가 더욱 중점적으로 드러나게 되었다.\n\n이 `bind` 라는 함수는 `Monad` 타입클래스에 `(\u003e\u003e=)` 라는 함수의 형태로 존재한다. `State` 를 `Monad` 타입클래스의 인스턴스로 만들면 `do` notation의 syntactic sugar 또한 사용할 수 있게 된다. 다만 `Monad` 타입클래스의 인스턴스로 만들기 위해서는 그 superclass인 `Applicative` 까지 구현을 해야 하고, `Applicative` 의 superclass인 `Functor` 까지 구현해야 한다. 구현 코드는 다음과 같이 작성할 수 있다.\n\n```haskell\nimport Control.Applicative\n\n-- a type that contains a state transformer\n-- the state transformer accepts a state, and returns a state with some return value\nnewtype State a b = S {getState :: a -\u003e (b, a)}\n\nrunState :: State a b -\u003e a -\u003e (b, a)\nrunState S {getState = f} = f\n\ninstance Functor (State a) where\n  -- fmap :: (a -\u003e b) -\u003e State s a -\u003e State s b\n  fmap f (S transform) = S (\\s -\u003e let (r, s') = transform s in (f r, s'))\n\ninstance Applicative (State a) where\n  -- pure :: a -\u003e State s a\n  pure x = S $ \\s -\u003e (x, s)\n\n  -- (\u003c*\u003e) :: State s (a-\u003eb) -\u003e State s a -\u003e State s b\n  sf \u003c*\u003e sa = S $ \\s -\u003e\n    let (f', s') = runState sf s\n     in runState (f' `fmap` sa) s'\n\ninstance Monad (State a) where\n  -- (\u003e\u003e=) :: State s a -\u003e (a -\u003e State s b) -\u003e State s b\n  (S f) \u003e\u003e= t = S $ \\s -\u003e\n    let (a, s') = f s in runState (t a) s'\n```\n\n이제 `do` notation을 이용해 코드를 2차로 리팩토링해보자.\n\n```haskell\nnext :: State Int Int\nnext = S $ \\n -\u003e (n, n + 1)\n\nmain :: IO ()\nmain = fst $ runState (\n  do\n    id \u003c- next\n    id' \u003c- next\n    id'' \u003c- next\n    S $ \\s -\u003e\n      ( do\n          print id\n          print id'\n          print id'',\n        s\n      )\n  )\n  0\n```\n\n`bind` 호출이 없으니 조금 더 간결해졌다. 마지막으로, `State` monad를 사용하는 코드를 분리하여 리팩토링을 해보자.\n\n```haskell\n-- Main.hs\nnext :: State Int Int\nnext = S $ \\n -\u003e (n, n + 1)\n\nnextThree :: State Int (Int, Int, Int)\nnextThree = do\n  id \u003c- next\n  id' \u003c- next\n  id'' \u003c- next\n  return (id, id', id'')\n\ngetThreeIds :: Int -\u003e (Int, Int, Int)\ngetThreeIds start = fst $ runState nextThree start\n\nmain :: IO ()\nmain = do\n  let (id, id', id'') = getThreeIds 0\n  print id\n  print id'\n  print id''\n```\n\n특히 처음에 비하면 코드가 훨씬 간결해진 것을 확인할 수 있다.\n\n## Tree Labeling\n\n해당 monad를 또 다른 예시에 적용해보자. 이는 위에 언급된 동영상에 있는 예시이기도 하다.\n\n```haskell\ndata Tree a = Leaf a | Node (Tree a) (Tree a) deriving Show\n```\n\n다음과 같은 트리 자료구조가 있을 때, 각각 leaf마다 숫자 id를 붙여 `label`하는 함수를 작성해보자. 먼저 monad 없이 매뉴얼하게 작성해보자.\n\n```haskell\nlabel :: Tree a -\u003e Int -\u003e (Tree Int, Int)\nlabel (Leaf v) n = (Leaf n, n + 1)\nlabel (Node l r) n = (Node l' r', n'')\n  where\n    (l', n') = label l n\n    (r', n'') = label r n'\n```\n\n이 함수는 state를 관리한다. 그 다음에 사용할 id인 `n`이다. 함수를 pure하게 유지하기 위해서는 바늘구멍에 실 궤매듯이 이 state를 계속 들고 다녀야 한다.그럼 위에서 만든 `State` 를 이용하여 같은 코드를 작성해보자.\n\n```haskell\nmlabel :: Tree a -\u003e State Int (Tree Int)\nmlabel (Leaf v) = do\n  n \u003c- next\n  return (Leaf n)\n\nmlabel (Node l r) = do\n  l' \u003c- mlabel l\n  r' \u003c- mlabel r\n  return (Node l' r')\n```\n\n실 꿰매듯 state를 운반하는 코드는 더이상 보이지 않는다. 이 함수는 이렇게 사용할 수 있을 것이다.\n\n```haskell\n-- Tree.hs\ntestTree :: Tree String\ntestTree = Node (Leaf \"foo\") (Node (Leaf \"bar\") (Leaf \"baz\"))\n\nmain :: IO ()\nmain = do\n  let labeled = fst $ runState (mlabel testTree) 0\n  print labeled\n```\n\n(`runState` 랑 0이 불편하면 다른 함수로 만들어두면 된다...여기선 생략한다)\n\n이로써 순수 함수형 언어인 haskell에서 monad를 통해 state를 깔끔하게 처리하는 방법을 알아보았다! 글을 쓰며 나 역시 많이 배운 것 같다. 이 게시글에서 사용한 코드는 [이 레포](https://github.com/pacokwon/simple-state-monad-demo)에 업로드되어있다!\n","title":"Simple State Monad in Haskell with Examples","tags":["haskell","ko"],"date":"2021-09-11"},{"id":"20210903-building-a-blog","content":"\nIn this post I'll be briefly going through how I built my blog with Next.js and some difficulties that I've faced. This will only be a personal reflection, not a tutorial.\n\nSo one day, I decided to build a personal blog. Nothing fancy but a rather simple blog to put my personal info with posting capability. Yes, you can use a given template, but I personally have this avoidance for templates. I wish to have complete control of what I use and build, and thus I decided to use a SSG/SSR framework called Next.js.\n\nAnd so, here are the main tools/packages that I've used to build my blog:\n\n- Next.js\n- Remark / Rehype\n- Material UI React\n- GitHub Pages \u0026 Workflow\n  I'll go through each of these to address my thoughts on them.\n\n## Next.js\n\nNext.js is a SSG/SSR framework for React. I haven't done SSG nor SSR ever before. It looked like Next.js and Gatsby both offer SSG functionality, so I had to choose. After a bit of research, I knew that Next.js would suit me better. To me Gatsby looked like a full fledged ecosystem with plugins and all, while Next.js was more like plug-and-play. It seemed like I would not have as much control over the project if I used Gatsby, so I chose Next.js. Of course, I haven't used Gatsby so there's the benefit of the doubt.\n\n## Remark / Rehype\n\nRemark / Rehype are libraries that transform markdown and html. I used these packages to convert them into React components, so that I could upload my posts.\n\nThe overall process of conversion is: `Markdown File - Remark - Rehype - React Component`. The markdown file is parsed with remark, translated to html using rehype, and then to a React component. The ecosystem allows you to plug processors in between. For example, I've used the `rehype-highlight` package that highlights code with `highlight.js` under the hood.\n\nWhat I really liked about this package is that it allows users to use their own components for each html tag from markdown. For now, rounding corners in code blocks remain my only usage for this feature (...) but I'm sure I could do much more.\n\n## Material UI React\n\nMaterial UI component library provides many useful components that follow the Material UI design. _I like pretty things, but I don't like CSS._ This library is for me. The familiarity helps as well. Most (if not all) google products use this guideline. The documentation is top notch as well. It also allows easy custom styling.\n\n## GitHub Pages \u0026 Workflow\n\nI've used GitHub pages as my blog hosting service. It serves static assets for free. I heard good things about it, but have never used it before. I had some difficulty initially setting it up, only to find out that I haven't changed the branch for github pages.\n\nSince generating static files requires a building process using Next.js, I have also set up GitHub Actions to automatically build as I push.\n\nI hope to keep my blog minimal, but the minimum functionality will grow larger as the need arises. Eventually the stack will grow as well, and maybe I'll do version 2 of this post when it happens.\n","title":"Building a Personal Blog in Next.js","tags":["nextjs","en"],"date":"2021-09-03"},{"id":"20210831-navy-software-developer","content":"\n블하 (블로그 하이라는 뜻)\n\n아무 생각 없이 대학교를 다니다가 보니 시간이 참 빨리 지나갔다. 고등학교 동기들 중에서는 군대가는 친구들을 여럿 보았는데, 입대를 3학년 이후로 생각하고 있던 이유는 많았다.\n\n1. 우리 학교는 다들 군대를 좀 늦게 가는 분위기였어서..\n2. 입대하기 전에 학교에서 최대한 많이 배워보고 싶은 욕구도 좀 있었다. 물론 그래봐야 전공 수업들이긴 했지만 실제로 학점을 굉장히 몰아 들었다. 졸업 이런거 때문이 아니고 맛보고 싶은게 많았다.\n3. 이왕 가는거 개발 쪽으로 갈 수 있으면 좋을 거라 생각했다. 근데 그러려면 2학년은 마쳐야 가능성이 조금이라도 생긴다.\n\n3번 이유가 가장 컸다. 병특을 고려하지 않은 이유는 내가 대학원을 가게 되면 그 전에 시간을 너무 많이 써야 해서..그리고 난 대학원 옵션을 버리고 싶지는 않았다. 전문연을 고려하지 않은 이유는 외국 대학원 옵션을 버리고 싶지 않아서. 또 그렇다고 대학원을 가야겠다는 확신이 들지 않는 상황이었다. 이것저것 고민하다보니 머리가 상당히 복잡해져서, 좋은 보직에 선발되면 그냥 가자는 결론을 내렸다.\n\n## 육군 SW 개발병 지원\n\n2학년 때 입대 고민을 할 당시에는 이걸 지원해서 갈 생각이었다. 선발은 1차 서류 + 2차 면접으로 이루어졌었다. 1차 서류는 학년 점수 + 자격증 + 고교 출석률 3개로 이루어져 있었다. 난 모범생이었으니 고교 출석률은 문제 없었고, 학년은 내가 당장 바꿀 수 없었기에 학년 점수도 고정이었다. 마지막 남은 자격증의 경우 10점이 최고 점수였는데, 10점을 주는 자격증들(기사급)이 여러개 있었고, 그 다음이 8점(산업기사급), 마지막이 6점이었다. 난 자격증은 없는 상황이었어서 주변 사람들이 많이 따는 정보처리 자격증을 취득하기로 했는데, 10점을 주는 정보처리기사 자격증은 졸업(4학년이었나?)을 해야 딸 수 있고, 8점을 주는 정보처리산업기사 자격증은 3학년이 돼야 딸 수 있었다. 6점 주는 기능사 자격증은 초등학생도 딸 수 있던 것 같던데 이걸로는 부족할 것 같았다. 그래서 3학년 된 직후에 정보처리산업기사 자격증 딴다고 필기시험은 회사 다니면서 공부하고, 실기시험은 수요일에 중간고사 끝나고 며칠 공부하고, 참 바쁜 시간 쪼개가며 공부했는데 어쩌다 취득은 했다.\n\n아무튼 내가 당시에 낼 수 있는 최대 점수를 냈는데 1차에서 탈락해버렸다. 모집 인원은 3명, 1차 통과는 3배수였고, 내 점수는 커트보다 3점 낮아서 떨어졌다. 내 점수는 선발 순위가 27위였다. 그만큼 1점씩이 중요했던 것 같다. 근데 한창 학기 중이라 바쁜 시기였던 것도 있었고, 나는 나름 최선을 다했어서 별로 후회되거나 아쉬운 점은 없었다. 누굴 탓할 순 없었다.\n\n## 해군 SW 개발병 지원\n\n육군을 떨어지고 바로 해군을 넣었다. 해군도 1차 서류 - 2차 면접 방식으로 선발을 하는데 1차는 모두 통과시키고 면접을 보는 방식이었다. 배점은 자격(30) + 경력(30) + 전공(40) + 면접(100)이었는데 솔직히 모르고 그냥 면접보러 갔었다. 면접은 대면으로 모든 대상자들이 계룡대에서 보았다. 나는 학교에 있었는데 가까이 있어서 택시타고 갔다. 근데 **면접을 보는 건물이 지도에 안 나오니 잘 찾아가야 한다...**, 택시에서 생각없이 내리고 길도 모르고 걸어가다 늦을 뻔했는데 어떤 은인이 나타나서 면접장까지 태워주셨다. 진짜 감사합니다...이걸 보시게 되면 연락해주세요. 보상이라도 해드리고 싶습니다.\n\n선발은 1명 선발이라 적혀 있었고, 병무청 웹사이트에서 조회했을 때는 나의 1차 점수는 3위, 최종 점수가 1위였다. 총 13~15명 정도 지원했던 것으로 기억한다. 다만 지원할 때 1명보다 많이 뽑을 수도 있다고 적혀 있어 실제로 얼마나 뽑았는지는 모르겠다.\n\n### 면접 후기\n\n나에게 물어보신 질문들을 직접 적을 생각은 없다. 대신 어떤 느낌으로 나왔는지 설명하겠다.\n\n#### 자료를 성심성의껏 준비하자\n\n나는 이 자료로부터 나오는 질문이 많았다. 고정질문이랑 비슷한 수의 질문을 하신 것 같다. 그만큼 주의깊게 이 자료를 보시니 준비를 잘하자!\n\n매수 또한 넉넉하게 출력해가는 것이 좋다. 나는 평소에 정말 생각이 없는 편이라 한 장만 뽑았었는데 운이 좋게도 여러 개 뽑을 생각을 했었다. 면접 보러 들어가니 면접관이 한 분보다 많이 계셔서 다행이 한 부씩 드릴 수 있었다.\n\n우선 1차를 통과하고(2021년도 기준 100%) 포트폴리오나 자기소개서 등의 자료를 자유롭게고 지참하라는 연락을 받았다. 근데 나는 둘 다 없는 상황이었다. 사실 반년 전에 회사 인턴 지원하면서 작성한 게 있었는데 정말 편한 느낌으로 써놓은 거라 그대로 내기에는 부담스러웠다. 그래서 처음부터 다시 작성했다. 어떤 내용을 넣을지는 고민을 많이 한 부분이다. 나는 `짧은 소개 + 경력 + 프로젝트 경험 + 보유기술 + 어학능력 + 교육 + 기타 활동`으로 구성했다. 그냥 내 마음대로 만든 구성이니 따라할거면 위험은 알아서 감수하도록.\n\n포트폴리오라는 말을 몰라 취업한 형에게 물어보니 보통 PPT 형태라고 하던데, 어떻게 가져오라는 건지 약간 의문이어서 그냥 문서 형식으로 작성해갔었다. 가보고 나니 그렇게 준비해가길 잘했다. 가서 보니 디지털로 발표를 할 환경은 아니었다. 물론 둘 다 준비를 하면 최고겠다. 나는 시간에 쫓겨 준비했었기 때문에..\n\n#### 기본적인 조사는 하자\n\n군면접의 성격을 띤 질문들도 많이 하신다. 대한민국 군대와 역사에 대해 최소한으로는 알아가면 좋을 것 같다. 나는 해군에 지원했기에 해군과 관련된 지식을 좀 쌓고 가는 것도 좋을 것이다.\n이외에도 부대 내에서의 상황을 주시고 이런 상황에서 어떻게 행동할 것인지에 관한 질문들 또한 하신다. 여러 가지 상황을 준비해가는 것도 방법일 것 같다. 나는 약간 생소한 상황을 질문하셔서 내 평소 가치관이랑 부족한 순발력에 의지해서 대답을 드려야 했다.\n\n내가 시간이 지나면 위 내용들을 잊을 것 같아 글을 작성하기도 했지만 해군 개발병에 지원할 때 후기가 전혀 없어 준비하기가 조금 어려워서 누군가 이 글을 보고 조금 더 수월하게 준비했으면 하는 마음도 있다. 지금 제 블로그가 바닥부터 만든거라 댓글 기능이 없는데, 추가 문의사항이 생기면 메일로 문의를 주시거나 보실 적에 댓글 기능이 있으면 댓글 달아주세요:)\n","title":"해군 SW 개발병 지원 후기","tags":["general","diary","military","ko"],"date":"2021-08-31"},{"id":"20210829-genesis","content":"\n## Hello World!\n\n블로그를 시작하게 되었다.\n\n블로그 운영은 거의 올해 초부터 해보고 싶었는데, 본업 때문에 시간이 부족하다는 변명을 스스로에게 하며 시작하지 않고 있었다... 나는 \"From Scratch\"를 굉장히 좋아하는 편이라 블로그도 템플릿에 의존하지 않고 직접 만들어야 한다는 생각 때문에 시작하는데 조금 장벽이 되었을 수도 있었을 것 같다는 생각이 든다.\n\n21년 여름에는 본교 PLRG에서 개별연구를 했는데, 랩 미팅 때 교수님께서 \"평소에 글을 쓰는 습관을 들이는 것이 좋다\"라는 말씀을 하신 것을 듣고 조금 더 동기부여가 되었던 것 같다. 얼마 뒤인지부터는 모르겠는데 아무튼 블로그 개발을 시작했고, 소개, bio, 그리고 게시글 조회 기능을 만든 뒤에 이 글을 작성하고 있다.\n\n동기부여가 되었던 또 다른 일은 입대가 얼마 안 남았다는 점이다. 이 이야기는 별도의 글에 더 자세하게 담겠지만, 불과 이틀 전에 해군 SW 개발병에 합격했는데, 한 명 뽑는 보직이다 보니 될 기대를 크게 안하고 있었어서 입영 날짜를 모르고 있었다. 알고 보니 10월 5일 입영이었고 백신 문제 때문에 정확히 그때 갈지는 모르겠지만 시간이 한 달...정도밖에 남지 않았기 때문에, 시간이 있을 때라도 좀 정리를 하고 가야겠다는 생각을 했다. 물론 아직 남은 시간동안 어떠한 일을 할지 제대로 생각을 못해봤는데, 최대한 블로그 정리를 하고 갈 수 있었으면 한다.\n\n블로그 게시글들은 남이 볼 것이라고 기대하지는 않고 오히려 개인 일기 느낌에 가깝도록 편하게 적을 것 같은데, 또 나만 알아들을 수 있도록 적지는 않을 생각이다. 주 내용은 내가 평소에 관심있던 편집기 이야기 및 개발을 배우면서 사소하게 배웠던 것들을 적을 것 같다! 또 예전부터 개인 노션이나 `vimwiki` 등 여기저기 적어는 놓았는데 정리가 안된 자료들도 과거 작성 날짜에 맞춰 업로드할 생각이다.\n","title":"블로그 개업!","tags":["general","diary","ko"],"date":"2021-08-29"},{"id":"20200711-esModuleInterop-in-tsconfig","content":"\nWhy is it that different patterns of imports are shown across typescript examples?\n\n```typescript\nimport * as React from 'react';\nimport React from 'react';\n```\n\nLet us look at how the two examples are compiled to javascript code using `tsc`.\n\nFirst, intialize a project with the following commands:\n\n```bash\nmkdir esminterop-example \u0026\u0026 cd esminterop-example   # create project directory\nyarn init -y                                        # initialize npm project\nyarn add react                                      # add react package (opt.)\nyarn add -D typescript @types/node @types/react     # add typescript compiler and type definitions (req.)\ntouch star.ts plain.ts\n```\n\nFill in the files `star.ts` and `plain.ts` with the following code:\n\n`star.ts`\n\n```typescript\nimport * as React from 'react';\nconsole.log(React);\n```\n\n`plain.ts`\n\n```typescript\nimport React from 'react';\nconsole.log(React);\n```\n\nFirst, let's compile `star.ts` with `tsc` and see the output.\n\n```bash\nnpx tsc star.ts\n```\n\n`star.js`\n\n```javascript\n'use strict';\nexports.__esModule = true;\nvar React = require('react');\nconsole.log(React);\n```\n\nAll good. Now try to compile `plain.ts`, and an error will occur.\n\n```bash\nnpx tsc plain.ts\n\nplain.ts:1:8 - error TS1259: Module '\"/Users/pacokwon/workspace/esminterop-example/node_modules/@types/react/index\"' can only be default-imported using the 'esModuleInterop' flag\n\n1 import React from 'react';\n         ~~~~~\n\n  node_modules/@types/react/index.d.ts:65:1\n    65 export = React;\n       ~~~~~~~~~~~~~~~\n    This module is declared with using 'export =', and can only be used with a default import when using the 'esModuleInterop' flag.\n\n\nFound 1 error.\n```\n\nThe problem occurs because while `react` does not have a default export, our typescript file is attempting to default import it. One way of solving this issue might be to use the wildcard(asterisk) import above. Another way is to use the `--esModuleInterop` flag. Now let's see how the latter way works, by using that flag in our compiler.\n\n```bash\nnpx tsc --esModuleInterop plain.ts\n```\n\nThere are no errors, which is a good thing. The compiled file looks like this:\n\n```javascript\n'use strict';\nvar __importDefault =\n  (this \u0026\u0026 this.__importDefault) ||\n  function (mod) {\n    return mod \u0026\u0026 mod.__esModule ? mod : { default: mod };\n  };\nexports.__esModule = true;\nvar react_1 = __importDefault(require('react'));\nconsole.log(react_1['default']);\n```\n\nOne can find out that a wrapper to the require is added. The wrapper provides additional logic, that allows flexible resolution between es6 modules and commonjs modules. It can also be observed that a \"default\" export or import is, from a commonjs module point of view, the value that corresponds to the key `\"default\"` in the `module.exports` object.\n\nAFAIK, javascript packages are usually shipped with the original source code transpiled into using commonjs modules, so the `esModuleInterop` flag is a flag that I commonly use in my `tsconfig.json`.\n","title":"Understanding the esModuleInterop option in tsconfig.json","tags":["typescript","quicknote","en"],"date":"2020-07-11"},{"id":"20200605-spellchecking-in-vim","content":"\nJust until stumbling upon some random video on youtube about spellchecking in Vim, I didn't know such capability even existed in Vim. Turns out that you can, and it can be utilized in markdown files, commit messages and etc. This post is a demonstration of how you can enable and utilize spellchecking in Vim.\n\n## Enabling Spellchecking in Vim\n\n```vim\n:set spell spellang=en_us \" use english dictionary for spellchecking\n```\n\nTo only set it for local buffers, use:\n\n```vim\n:setlocal spell spelllang=en_us\n```\n\nI utilize this primarily in autocmds, like this:\n\n```vim\nautocmd BufRead,BufNewFile *.md setlocal spell spelllang=en_us \" enable spellchecking in markdown files\nautocmd FileType gitcommit setlocal spell spelllang=en_us \" enable spellchecking in git commit files\n```\n\nOnce you have these set up, words that are recognized by the spellchecker will be highlighted according to the highlight groups `SpellBad`, `SpellCap`, `SpellRare`, `SpellLocal`. For further reference, consulting the `:help spell-quickstart` docs will come in handy. In my neovim setup, the words are shown underlined (Not exactly sure where it comes from).\n\n## Utilizing it\n\nOne can get recommendations from the spellchecker from the completion engine. Run `set complete+=kspell`, as in:\n\n```vim\nautocmd FileType gitcommit setlocal spell spelllang=en_us | set complete+=kspell\n```\n\nOne can navigate between recommendations in insert mode using `^N` and `^P`, and spellchecking recommendations will show up among the options.\n\nHere are some commands I found useful:\n\n- `]s` and `[s`: navigate between misspelled words. Former moves forward, the latter backwards.\n- `z=`: see alternatives to the word under the cursor. For example, if I write `file` and run `z=` on it, it will recommend a list of words from the dictionary.\n- `zg`: register a word as correct in the dictionary. The Vim dictionary does not know a lot of words, so it will mark a lot of words as incorrect. One way to solve that issue is to register a word to the dictionary. This command does that.\n- `zw`: just like `zg`, but marks a word as incorrect.\n\nFor more, as always, consult the helpdocs. For spellchecking, `:help spell` is where you should go to.\n","title":"Spellchecking in Vim / Neovim","tags":["vim","neovim","quicknote","en"],"date":"2020-06-05"}]},"__N_SSG":true},"page":"/posts","query":{},"buildId":"rua-Pj8yobcYBXhnGGnm0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>