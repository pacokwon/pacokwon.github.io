{"pageProps":{"posts":[{"id":"20230616-haskell-lisp-parsing","content":"\nì´ë²ˆ í¬ìŠ¤íŠ¸ì™€ ë‹¤ìŒ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ê°„ë‹¨í•œ Lisp ì¸í„°í”„ë¦¬í„°ë¥¼ ë§Œë“¤ì–´ë³´ê² ë‹¤. ì¬ë¯¸ì™€ í•™ìŠµì„ ìœ„í•œ ê²ƒì´ë‹ˆ ê°„ë‹¨í•˜ê²Œ ë§Œë“¤ì–´ ë³´ê² ë‹¤.\n\n## ëª©ì°¨\n\n- [Lispì™€ ëª©í‘œ](#lispì™€-ëª©í‘œ)\n- [ì¸í„°í”„ë¦¬í„° êµ¬ì¡°](#ì¸í„°í”„ë¦¬í„°-êµ¬ì¡°)\n- [íŒŒì‹±](#íŒŒì‹±)\n  - [AST ì •ì˜](#AST-ì •ì˜)\n  - [Parser Combinator](#parser-combinator)\n  - [ìˆ«ì íŒŒì‹±](#ìˆ«ì-íŒŒì‹±)\n  - [ì‹ë³„ì íŒŒì‹±](#ì‹ë³„ì-íŒŒì‹±)\n\në‚˜ë¨¸ì§€ ë¶€ë¶„ë“¤ì€ 2ë¶€ì—ì„œ ë‹¤ë£¨ê² ë‹¤!\n\n## Lispì™€ ëª©í‘œ\n\nLispëŠ” ë‹¨ìˆœí•œ ë¬¸ë²•ê³¼ í™•ì¥ì„±ìœ¼ë¡œ ì¸í•´ ë§¤ë‹ˆì•„ì¸µì´ ìˆëŠ” ì–¸ì–´ì´ë‹¤. ë¬¸ë²•ì€ S-Expressionì´ë¼ëŠ” í‘œí˜„ì„ ì‚¬ìš©í•˜ëŠ”ë°, ê´„í˜¸ê°€ ë§ì€ ê²ƒìœ¼ë¡œ ì•…ëª…ì´ ë†’ë‹¤. ìš”ìƒˆ LispëŠ” ê·¸ ìì²´ë¡œ ì–¸ì–´ë¼ê¸°ë³´ë‹¤ ì–¸ì–´ì˜ familyë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë§ë¡œ ì“°ì´ëŠ” ê²ƒ ê°™ë‹¤. Racket, Common Lisp, Clojure ë“±ë“±ì´ ì´ familyì— ì†í•œë‹¤ê³  ë³¼ ìˆ˜ ìˆê³ , ì‹¬ì§€ì–´ëŠ” ì´ë§¥ìŠ¤ì—ì„œë„ Emacs Lispë¼ëŠ” ì–¸ì–´ë¥¼ ì´ìš©í•´ ë‚´ë¶€ configurationì„ êµ¬ì„±í•  ìˆ˜ ìˆê²Œ ë˜ì–´ ìˆë‹¤. ì–¸ì–´ë“¤ë§ˆë‹¤ ì œê³µí•˜ëŠ” primitiveê°€ ê°ê° ë‹¤ë¥¸ë°, ì´ë²ˆì—ëŠ” ì•„ë˜ ê¸°ëŠ¥ë“¤ì„ êµ¬í˜„í•´ë³´ë„ë¡ í•˜ê² ë‹¤.\n\n- ë³€ìˆ˜ ì„ ì–¸ (local, global)\n- í•¨ìˆ˜ ì„ ì–¸ ë° í˜¸ì¶œ\n- í‘œí˜„ì‹ í‰ê°€\n\nì‚¬ìš©í•  ì–¸ì–´ëŠ” í•˜ìŠ¤ì¼ˆì´ë‹¤. ì´ëŸ´ ë•Œë¼ë„ ì¨ë³´ë„ë¡ í•˜ê² ë‹¤!\n\nìš°ì„  í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•˜ì. í”„ë¡œì íŠ¸ ì´ë¦„ì€ `whisper`ì´ë‹¤. ì—¬ê¸°ì„œ ì‚¬ìš©í•˜ëŠ” íˆ´ì€ [stack](https://docs.haskellstack.org/en/stable/)ì´ë‹¤.\n\n```bash\n$ stack new whisper new-template\n```\n\në‹¤ìŒê³¼ ê°™ì´ íŒŒì¼ì´ ìˆì„ ê²ƒì´ë‹¤.\n\n```plaintext\napp           LICENSE       README.md  src         stack.yaml.lock  whisper.cabal\nCHANGELOG.md  package.yaml  Setup.hs   stack.yaml  test\n```\n\nì‹¤ì œ í”„ë¡œì íŠ¸ì˜ ì½”ë“œëŠ” `app`, `src` ë””ë ‰í† ë¦¬ì— ìˆìœ¼ë©°, `src`ëŠ” ì½”ì–´í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ë“¤ì´ ìˆê³ , `app`ì—ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ í•¨ìˆ˜ë¥¼ ì˜ ì¡°í•©í•˜ì—¬ í•˜ë‚˜ì˜ ì‹¤í–‰ íŒŒì¼ë¡œ ë™ì‘í•˜ë„ë¡ í•˜ëŠ” íŒŒì¼ì´ ìˆë‹¤.\n\nì´ í”„ë¡œì íŠ¸ì—ì„œëŠ” `ghc 9.2.7`ì„ ì‚¬ìš©í•˜ê² ë‹¤. `stack.yaml`ì— ì´ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ëª…ì‹œí•´ì¤€ë‹¤.\n\n```yaml\n#...\nresolver: lts-20.24\n#...\n```\n\n## ì¸í„°í”„ë¦¬í„° êµ¬ì¡°\n\nìš°ë¦¬ì˜ ì¸í„°í”„ë¦¬í„°ëŠ” ì½ê¸° - íŒŒì‹± - í‰ê°€ - ì¶œë ¥ì˜ ë‹¨ê³„ë¡œ ë™ì‘í•˜ê²Œ í•  ê²ƒì´ë‹¤. ì´ ì¤‘ ì½”ì–´í•œ ë¶€ë¶„ì´ íŒŒì‹±ê³¼ í‰ê°€ì¸ë°, ì´ ë‘ ë‹¨ê³„ë¥¼ ì°¨ë¡€ë¡œ ë¶€ë”ªí˜€ ë³´ë„ë¡ í•˜ì.\n\n## íŒŒì‹±\n\nì½”ë“œë¥¼ ì‘ì„±í•˜ê¸° ì „ì— í•„ìš”í•œ íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•´ì•¼ í•œë‹¤. ì´ í”„ë¡œì íŠ¸ì—ì„œ ì‚¬ìš©í•  íŒ¨í‚¤ì§€ëŠ” [`megaparsec`](https://hackage.haskell.org/package/megaparsec)ì´ë¼ëŠ” parser combinator ë¼ì´ë¸ŒëŸ¬ë¦¬ì™€, íš¨ìœ¨ì ì¸ í…ìŠ¤íŠ¸ ì²˜ë¦¬ë¥¼ ìœ„í•œ [`text`](https://hackage.haskell.org/package/text) íŒ¨í‚¤ì§€ì´ë‹¤.\n\n`stack.yaml`ì— ì´ë¥¼ ëª…ì‹œí•´ì¤€ë‹¤.\n\n```yaml\nextra-deps:\n  - megaparsec-9.4.0\n  - text-2.0.2\n```\n\në˜ `package.yaml`ì˜ `dependencies` ë¶€ë¶„ì— ë‹¤ìŒê³¼ ê°™ì´ ì¶”ê°€í•œë‹¤.\n\n```yaml\ndependencies:\n  - base >= 4.7 && < 5\n  - megaparsec >= 9.4 # NEW\n  - text >= 2.0 # NEW\n```\n\nì´ì œ `src/Parser.hs`ì— íŒŒì‹± ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì.\n\nNOTE: `megaparsec`ê³¼ ê°™ì€ parser combinator ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì²˜ìŒ ì¨ë´ì„œ [ì´ ê³µì‹ ë¬¸ì„œ](https://markkarpov.com/tutorial/megaparsec.html)ë¥¼ ë§ì´ ì°¸ê³ í–ˆë‹¤.\n\në¨¼ì € ìš°ë¦¬ì˜ `Parser` íƒ€ì…ì„ ë§Œë“¤ì–´ì•¼ í•œë‹¤. ì•ìœ¼ë¡œ ë§Œë“¤ê²Œ ë˜ëŠ” íŒŒì„œë“¤ì€ ì´ íƒ€ì…ì„ ê°€ì§€ê²Œ ë  ê²ƒì´ë‹¤.\n\n```haskell\n-- src/Parser.hs\nmodule Parser where\n\nimport Data.Void (Void)\nimport Text.Megaparsec (Parsec)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n```\n\nì—¬ê¸°ì„œ `Void`ëŠ” íŒŒì‹± ì—ëŸ¬ì˜ íƒ€ì…ì„ ëœ»í•˜ê³ , `Text`ëŠ” ì…ë ¥ ì†ŒìŠ¤ì˜ íƒ€ì…ì„ ì˜ë¯¸í•œë‹¤. ê°œë°œ ê³¼ì •ì„ ë‹¨ìˆœí™”í•˜ê¸° ìœ„í•´ ì—ëŸ¬ íƒ€ì…ì€ `Void`ë¡œ ë‘ì—ˆë‹¤.\n\n### AST ì •ì˜\n\nê°€ì¥ ë¨¼ì € Syntax íŠ¸ë¦¬ë¥¼ ì •ì˜í•˜ê² ë‹¤. Syntax íŠ¸ë¦¬ëŠ” ì½”ë“œë¥¼ íŒŒì‹±í•œ ê²°ê³¼ë¬¼ì„ ë‚˜íƒ€ë‚´ëŠ”ë°, ìš°ì„  í•˜ë‚˜ì˜ S-Expressionì„ ë‚˜íƒ€ë‚´ëŠ” íƒ€ì…ì„ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•´ë³¼ ìˆ˜ ìˆë‹¤.\n\n```haskell\n-- src/Parser.hs\ndata Sexpr = Paren [Sexpr]\n           | Number Int\n           | Ident String\n\t    deriving Show\n```\n\nSyntax íŠ¸ë¦¬ì˜ ë…¸ë“œë¥¼ 3ê°€ì§€ë¡œ ê°„ë‹¨í•˜ê²Œ ë‚˜íƒ€ë‚´ ë³´ì•˜ë‹¤. `Number Int`ëŠ” `3`ê³¼ ê°™ì´ ì •ìˆ˜ë¥¼ í‘œí˜„í•˜ê³ , `Ident String`ì€ `a`, `foo`ì™€ ê°™ì´ ë³€ìˆ˜ë¥¼ í‘œí˜„í•˜ë©°, ë§ˆì§€ë§‰ìœ¼ë¡œ `Paren [Sexpr]`ëŠ” `(* a (+ 1 3))`ì™€ ê°™ì´ ì—¬ëŸ¬ ê°œì˜ S-Expressionì„ ê´„í˜¸ ì‚¬ì´ì— ë‹´ê³  ìˆëŠ” í˜•íƒœë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.\n\në§¨ ë°‘ì¤„ì— ìˆëŠ” `deriving Show`ëŠ” ìë°”ë¡œ ì¹˜ë©´ `toString` ë©”ì„œë“œë¥¼ ìë™ìœ¼ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” ê²ƒê³¼ ê°™ë‹¤. ë‹¤ìŒê³¼ ê°™ì´ `Sexpr` íƒ€ì…ì˜ variantë¥¼ ì§ê´€ì ìœ¼ë¡œ ì¶œë ¥í•˜ëŠ” ë° ë„ì›€ì„ ì¤€ë‹¤.\n\n```haskell\nmain :: IO ()\nmain = do\n    print $ Number 3 -- Output: Number 3\n    print $ Ident \"foo\" -- Output: Ident \"foo\"\n    print $ Paren [Ident \"+\", Number 1, Number 4] -- Output: Paren [Ident \"+\",Number 1,Number 4]\n```\n\n### Parser Combinator\n\n[íŒŒì„œ ì½¤ë¹„ë„¤ì´í„°](https://en.wikipedia.org/wiki/Parser_combinator)ëŠ” ëª¨ë‚˜ë“œë¥¼ ì‘ìš©í•˜ì—¬ ì¬ê·€í•˜í–¥ íŒŒì„œë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•ì˜ ì¼ì¢…ì´ë‹¤. ì´ë¦„ì´ ë‚˜íƒ€ë‚´ë“¯ì´, ì‘ì€ íŒŒì„œë¥¼ ì¡°í•©í•˜ì—¬ í•˜ë‚˜ì˜ ì»¤ë‹¤ë€ íŒŒì„œë¥¼ ë§Œë“¤ê¸° ìš©ì´í•˜ë‹¤.\n\nì˜ˆë¥¼ ë“¤ì–´ `megaparsec`ì—ì„œëŠ” `char`ì´ë¼ëŠ” ê¸°ë³¸ íŒŒì„œê°€ ìˆëŠ”ë° ì´ëŠ” ì¸ìë¡œ ì œê³µëœ ë¬¸ìë¥¼ íŒŒì‹±í•œë‹¤.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Text.Megaparsec.Char\nimport Data.Void (Void)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = do\n    parseTest (char 'a' :: Parser Char) \"a\" -- 'a'\n    parseTest (char 'a' :: Parser Char) \"b\" -- ERROR: unexpected 'b', expecting 'a'\n```\n\n`string`ì´ë¼ëŠ” íŒŒì„œë„ ìˆë‹¤. ì´ëŠ” ì¸ìë¡œ ì œê³µëœ ë¬¸ìì—´ì„ íŒŒì‹±í•œë‹¤.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Text.Megaparsec.Char\nimport Data.Void (Void)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = do\n    parseTest (string \"foo\" :: Parser Text) \"foo\" -- \"foo\"\n```\n\nìœ„ ë‘ ì˜ˆì‹œëŠ” ì •ê·œí‘œí˜„ì‹ìœ¼ë¡œë„ í‘œí˜„ì´ ê°€ëŠ¥í•œë°, ê· í˜• ì¡íŒ ê´„í˜¸ ë¬¸ì œì™€ ê°™ì´ regexëŠ” í‘œí˜„í•˜ì§€ ëª»í•˜ëŠ” ê²ƒë“¤ë„ íŒŒì‹±í•  ìˆ˜ ìˆë‹¤.\n\n```haskell\ndata ParenExpr = Empty | Concat ParenExpr ParenExpr deriving Show\n\nparenExprParser :: Parser ParenExpr\nparenExprParser = between (char '(') (char ')') innerExpr <|> emptyExpr\n  where\n    innerExpr = do\n      left <- parenExprParser\n      right <- parenExprParser\n      return $ Concat left right\n    emptyExpr = return Empty\n\nmain :: IO ()\nmain = do\n    parseTest parenExprParser \"(())()\" -- Concat (Concat Empty Empty) Empty \"foo\"\n```\n\n### ìˆ«ì íŒŒì‹±\n\nê·¸ëŸ¼ ì´ì œ `megaparsec`ì—ì„œ ì œê³µí•´ì£¼ëŠ” ê¸°ë³¸ íŒŒì„œë¥¼ ì´ìš©í•´ ASTì˜ ì •ìˆ˜ ë¶€ë¶„ì„ íŒŒì‹±í•´ë³´ì.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Data.Void (Void)\nimport Data.Text (Text)\nimport qualified Text.Megaparsec.Char.Lexer as L\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = parseTest (L.decimal :: Parser Int) \"345\" -- 345\n```\n\në³´ì´ëŠ” ê²ƒê³¼ ê°™ì´ `Text.Megaparsec.Char.Lexer`ì˜ `decimal` í•¨ìˆ˜ëŠ” 10ì§„ìˆ˜ ìˆ«ìë¥¼ íŒŒì‹±í•´ì¤€ë‹¤. ì´ë•Œ íŒŒì‹±í•œ ê²°ê³¼ëŠ” `Parser Int` íƒ€ì…ì¸ë°, ìš°ë¦¬ê°€ ì›í•˜ëŠ” ê²ƒì€ `Parser Sexpr` ì´ë‹¤.\n\nì–´ë–»ê²Œ ë°”ê¿€ ìˆ˜ ìˆì„ê¹Œ?\n\n`Parser` íƒ€ì…ì´ ëª¨ë‚˜ë“œë¼ëŠ” ì‚¬ì‹¤ì€ ì´ëŸ´ ë•Œ ë„ì›€ì´ ëœë‹¤. ì´ë¯¸ ëª¨ë‚˜ë“œì— ëŒ€í•´ ì•Œê³  ìˆëŠ” ê²ƒì„ ê·¸ëŒ€ë¡œ ì ìš©í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤. ëª¨ë‚˜ë“œê°€ Functorë¼ëŠ” ì‚¬ì‹¤ì„ ì•Œê³  ìˆë‹¤ë©´, `fmap` í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë‚´ë¶€ì˜ íƒ€ì…ì„ ë‹¤ìŒê³¼ ê°™ì´ ë³€í™˜í•  ìˆ˜ ìˆë‹¤.\n\n```haskell\nparseTest (Number <$> L.decimal :: Parser Sexpr) \"345\"\n```\n\në”°ë¼ì„œ ìš°ë¦¬ì˜ `number` í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•  ìˆ˜ ìˆë‹¤.\n\n```haskell\n-- src/Parser.hs\n\n-- ...\nnumber :: Parser Sexpr\nnumber = Number <$> L.decimal\n```\n\n### ì‹ë³„ì íŒŒì‹±\n\nì´ì œ ì¡°ê¸ˆ ë” ì–´ë ¤ìš´ ì‹ë³„ìë¥¼ íŒŒì‹±í•´ë³´ê¸° ì „ì— ì‹ë³„ìê°€ ì–´ë–»ê²Œ ìƒê²¼ìœ¼ë©´ ì¢‹ê² ëŠ”ì§€ ì •ì˜í•  í•„ìš”ê°€ ìˆë‹¤. PHPë‚˜ JSëŠ” ë³€ìˆ˜ëª…ì´ `$`ë¡œ ì‹œì‘í•˜ëŠ” ê²ƒì„ í—ˆìš©í•˜ì§€ë§Œ, íŒŒì´ì¬ì€ í—ˆìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì„ ë³´ì•˜ì„ ë•Œ, ì‹ë³„ìì˜ ìƒê¹€ìƒˆëŠ” ì •í•˜ê¸° ë‚˜ë¦„ì´ë‹¤.\n\nLisp ê³„ì—´ ì–¸ì–´ëŠ” ì‹ë³„ì ëª…ëª…ì— ê½¤ ê´€ëŒ€í•œ í¸ì´ë‹¤. ë”°ë¼ì„œ ì´ë ‡ê²Œ ê·œì¹™ì„ ì •í•˜ê² ë‹¤.\n\n1. ì‹ë³„ìëŠ” ì•ŒíŒŒë²³, ìˆ«ì, ê·¸ë¦¬ê³  íŠ¹ì • íŠ¹ìˆ˜ê¸°í˜¸ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤\n2. ì‹ë³„ìì˜ ê¸¸ì´ëŠ” 1 ì´ìƒì´ë‹¤.\n3. ì‹ë³„ìëŠ” ìˆ«ìë¡œ ì‹œì‘í•  ìˆ˜ ì—†ë‹¤.\n\n1ë²ˆì˜ \"íŠ¹ì • íŠ¹ìˆ˜ê¸°í˜¸\"ëŠ” ASCII í…Œì´ë¸” ì•ˆì˜ íŠ¹ìˆ˜ê¸°í˜¸ ì¤‘ `!\"#$%&'*+,-./:<=>?@^_~` ë¥¼ ì˜ë¯¸í•œë‹¤.\n\nì—¬ê¸°ì„œ ì „ëµì€ ë‘ ê°œì˜ ì‘ì€ íŒŒì„œë¥¼ ë§Œë“œëŠ” ê²ƒì´ë‹¤. íŒŒì„œ AëŠ” ì²«ë²ˆì§¸ ê¸€ìë§Œì„ ìœ„í•œ íŒŒì„œì´ë‹¤. ì¦‰ ì•ŒíŒŒë²³ê³¼ ê¸°í˜¸ë¥¼ ì¸ì‹í•˜ëŠ” íŒŒì„œì´ë‹¤. íŒŒì„œ BëŠ” ë‚˜ë¨¸ì§€ ê¸€ìë“¤ì„ ìœ„í•œ íŒŒì„œì´ë‹¤. ì¦‰ ì•ŒíŒŒë²³, ê¸°í˜¸, ìˆ«ìê¹Œì§€ ì¸ì‹í•  ìˆ˜ ìˆë‹¤. ê·¸ ë’¤ íŒŒì„œ Aì™€ Bë¥¼ í•©ì¹˜ë©´ ì‹ë³„ì íŒŒì„œê°€ ë˜ëŠ” ê²ƒì´ë‹¤.\n\níŒŒì„œ AëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë§Œë“¤ ìˆ˜ ìˆë‹¤.\n\n```haskell\nimport Text.Megaparsec ((<|>))\nimport Text.Megaparsec.Char (letterChar)\n\nfirst :: Parser Char\nfirst = letterChar <|> symbolChar\n```\n\n`<|>` ì—°ì‚°ìì˜ ì‚¬ìš©ì„ ë³¼ ìˆ˜ ìˆëŠ”ë°, ì´ëŠ” ì—°ì‚°ì ì•ì— ìˆëŠ” íŒŒì„œê°€ ì‹¤íŒ¨í•˜ë©´ ë’¤ì— ìˆëŠ” íŒŒì„œë¥¼ ì‹œë„í•´ë³´ë¼ëŠ” ëœ»ì´ë‹¤. ì¦‰ `letterChar`ì´ ì¸ì‹í•˜ì§€ ëª»í•˜ë©´, `symbolChar`ì´ ì‹œë„ë¥¼ í•´ë³´ëŠ” ê²ƒì´ë‹¤. ë§Œì•½ `symbolChar` ê¹Œì§€ ì¸ì‹í•˜ì§€ ëª»í•œë‹¤ë©´ ì—ëŸ¬ê°€ ë°œìƒí•  ê²ƒì´ë‹¤.\n\n`letterChar`ì€ `megaparsec`ì—ì„œ ê°€ì ¸ì™”ìœ¼ë‚˜, `symbolChar`ì€ ì—†ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆëŠ”ë°, ì´ëŠ” `megaparsec`ì— ìˆëŠ” `symbolChar`ì´ ìœ„ì—ì„œ ì •ì˜í•œ ê¸°í˜¸ë“¤ê³¼ ì¼ì¹˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì´ë‹¤. ì§ì ‘ `symbolChar`ë¥¼ ì •ì˜í•´ë³´ì.\n\n```haskell\nimport Text.Megaparsec (satisfy)\nimport qualified Data.Set as Set\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%&'*+,-./:<=>?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n```\n\nìœ„ì—ì„  `satisfy`ë¼ëŠ” `megaparsec`ì˜ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í–ˆëŠ”ë°, ì£¼ì–´ì§„ predicate í•¨ìˆ˜ë¥¼ ë§Œì¡±í•˜ëŠ” ë¬¸ìë§Œ ì¸ì‹í•˜ê²Œ í•˜ëŠ” ê²ƒì´ë‹¤. ìš°ë¦¬ëŠ” predicateë¡œ ì—°ì‚°ì ì§‘í•©ì— ìˆëŠ” ë¬¸ìë§Œ ì¸ì‹í•˜ëŠ” í•¨ìˆ˜ë¥¼ ê±´ë„¸ë‹¤.\n\nì´ì œ ë‘ ê°œì˜ ì‘ì€ íŒŒì„œê°€ ì™„ì„±ë˜ì—ˆë‹¤. ì´ë¥¼ ì¡°í•©í•´ ì‹ë³„ì íŒŒì„œë¥¼ ì™„ì„±ì‹œì¼œë³´ì.\n\n```haskell\n-- src/Parser.hs\nimport Text.Megaparsec ((<|>), many, satisfy)\nimport Text.Megaparsec.Char (letterChar, alphaNumChar)\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%&'*+,-./:<=>?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n\nident :: Parser Sexpr\nident = Ident <$> p\n    where\n        first = letterChar <|> symbolChar\n        rest = many (alphaNumChar <|> symbolChar)\n        p = (:) <$> first <*> rest\n```\n\nìœ„ ì½”ë“œì—ì„œ ëˆˆì—¬ê²¨ë³¼ ì ë“¤ì€:\n\n1. `many` í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ \"í•˜ë‚˜ì˜ ë¬¸ìë¥¼ ì¸ì‹í•˜ëŠ” íŒŒì„œ\"ë¥¼ \"0ê°œ ì´ìƒì˜ ë¬¸ìë¥¼ ì¸ì‹í•˜ëŠ” íŒŒì„œ\"ë¡œ ë§Œë“¤ì—ˆë‹¤.\n2. `(:)` ë¦¬ìŠ¤íŠ¸ cons ì—°ì‚°ìë¥¼ ì´ìš©í•˜ê¸° ìœ„í•´ `fmap(<$>)`ê³¼ `<*>`ë¥¼ ì‚¬ìš©í–ˆë‹¤. `fmap`ì€ ëª¨ë‚˜ë“œê°€ functorì´ê¸° ë•Œë¬¸ì— ê°€ëŠ¥í•˜ê³ , `<*>`ì€ ëª¨ë‚˜ë“œê°€ applicativeì´ê¸°ë„ í•˜ê¸° ë•Œë¬¸ì— ê°€ëŠ¥í•˜ë‹¤.\n\n### ë¦¬ìŠ¤íŠ¸ íŒŒì‹±\n\nì´ì œ ë§ˆì§€ë§‰ variantì¸ `Paren`ì„ íŒŒì‹±í•´ë³´ì. ì•ˆì— ì—¬ëŸ¬ ê°œì˜ S-Expressionì„ ë‹´ê³  ìˆê¸° ë•Œë¬¸ì— ë¦¬ìŠ¤íŠ¸ë¼ê³  ë¶€ë¥´ê² ë‹¤. ë¦¬ìŠ¤íŠ¸ë¥¼ íŒŒì‹±í•˜ê¸° ìœ„í•´ ê·¸ê²ƒì˜ íŠ¹ì„±ì„ ë¨¼ì € ì‚´í´ë³´ì.\n\n1. `(`ìœ¼ë¡œ ì‹œì‘í•œë‹¤.\n2. `)`ìœ¼ë¡œ ëë‚œë‹¤.\n3. ì‚¬ì´ì— 1ê°œ ì´ìƒì˜ S-Expressionì´ ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ì–´ ìˆë‹¤\n\nê°€ì¥ ì–´ë ¤ìš´ ë¶€ë¶„ì€ 3ë²ˆì´ë‹¤. ìš°ì„  ë¦¬ìŠ¤íŠ¸ ì•ˆì—ëŠ” ë˜ë‹¤ë¥¸ S-Expressionì´ ìˆê¸° ë•Œë¬¸ì— ì¬ê·€í˜¸ì¶œì´ í•„ìš”í•´ ë³´ì´ê³ , ë˜ ê³µë°±ì„ ì–´ë–»ê²Œë“  ì²˜ë¦¬í•´ì•¼ í•œë‹¤. ë°©ë²•ì€ ë‹¤ì–‘í•˜ê² ì§€ë§Œ, **íŒŒì‹±ì´ ëë‚œ ì´í›„ì— ë°œìƒí•˜ëŠ” ê³µë°±ì„ consumeí•˜ê³  ë¬´ì‹œí•˜ë„ë¡** íŒŒì„œë¥¼ ìˆ˜ì •í•˜ë„ë¡ í•˜ì.\n\nì´ë¥¼ ë•ë„ë¡ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¥¼ í•˜ë‚˜ ë§Œë“¤ê² ë‹¤. íŒŒì„œë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ì•„, í•´ë‹¹ íŒŒì„œê°€ í•˜ëŠ” ì¼ + ë’¤ì— ìˆëŠ” ê³µë°±ì„ ë¬´ì‹œí•˜ëŠ” íŒŒì„œë¥¼ ë§Œë“¤ì.\n\n```haskell\nimport Text.Megaparsec.Char (space)\n\nlexeme :: Parser a -> Parser a\nlexeme p = p <* space\n```\n\nì´ë¥¼ ì´ìš©í•˜ì—¬ ê¸°ì¡´ íŒŒì„œë“¤ì„ ìˆ˜ì •í•˜ì. ìœ„ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ ê½¤ ê°„ë‹¨í•˜ë‹¤.\n\n```haskell\nnumber :: Parser Sexpr\nnumber = Number <$> lexeme L.decimal\n\n-- ...\nident :: Parser Sexpr\nident = Ident <$> lexeme p\n    where\n        first = letterChar <|> symbolChar\n        rest = many (alphaNumChar <|> symbolChar)\n        p = (:) <$> first <*> rest\n```\n\nì´ë¡œì¨ ì´ íŒŒì„œë“¤ì€ ë’¤ì— ìˆëŠ” ê³µë°±ê¹Œì§€ ë¬´ì‹œí•˜ëŠ” ê¸°ëŠ¥ê¹Œì§€ ì¶”ê°€ë˜ì—ˆë‹¤.\n\n```haskell\nmain :: IO ()\nmain = do\n    parseTest (liftA2 (,) number ident) \"345 foobar\" -- (Number 345,Ident \"foobar\")\n```\n\në‘ íŒŒì„œë¥¼ ì—°ì†ìœ¼ë¡œ ì‹¤í–‰ì‹œì¼œë„ ê³µë°±ì„ ë¬´ì‹œí•˜ê³  ì˜ íŒŒì‹±í•´ì¤€ë‹¤.\n\nì´ì œ ìœ ìš©í•œ í•¨ìˆ˜ë¥¼ í•˜ë‚˜ ë” ì†Œê°œí•˜ê² ë‹¤. ë°”ë¡œ `many`ì™€ `some`ì¸ë°, `many p`ëŠ” íŒŒì„œ `p`ë¥¼ 0ë²ˆ ì´ìƒ ì‹¤í–‰ì‹œì¼œ ê·¸ ê²°ê³¼ë¥¼ ëŒë ¤ì£¼ê³ , `some p`ëŠ” íŒŒì„œ `p`ë¥¼ 1ë²ˆ ì´ìƒ ì‹¤í–‰ì‹œì¼œ ê·¸ ê²°ê³¼ë¥¼ ëŒë ¤ì¤€ë‹¤.\n\nì¦‰, `many number`ëŠ” ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ëœ 0ê°œ ì´ìƒì˜ ì—°ì†ëœ ìˆ«ìë¥¼ íŒŒì‹±í•  ìˆ˜ ìˆê³ , `some ident`ëŠ” ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ëœ 1ê°œ ì´ìƒì˜ ì—°ì†ëœ ì‹ë³„ìë¥¼ íŒŒì‹±í•  ìˆ˜ ìˆë‹¤.\n\në¦¬ìŠ¤íŠ¸ ì•ˆì—ëŠ” 1ê°œ ì´ìƒì˜ S-Expressionì´ í•„ìš”í•˜ê¸° ë•Œë¬¸ì— `some`ì„ ì“°ë©´ ëœë‹¤. ê·¼ë° ì–´ë–¤ íŒŒì„œë¥¼ 1ë²ˆ ì´ìƒ ì‹¤í–‰í•˜ë©´ ë ê¹Œ? ìš°ì„ ì€ ê·¸ê²ƒì„ `sexpr`ë¼ ë¶€ë¥´ê¸°ë¡œ í•˜ê³  ì¡°ê¸ˆ ì´ë”° ëŒì•„ì™€ë³´ì.\n\nì¢…í•©í•´ ë³´ì•„ `paren` íŒŒì„œë¥¼ ë§Œë“¤ì–´ ë³´ì. `(`ë¡œ ì‹œì‘í•˜ê³ , `p`ë¥¼ 1ë²ˆ ì´ìƒ ì‹¤í–‰í•œ ë’¤, `)`ë¡œ ëë‚˜ëŠ” ê²ƒì´ë‹¤.\n\n```haskell\nimport Text.Megaparsec (some)\nimport Text.Megaparsec.Char (char)\n\nparen :: Parser Sexpr\nparen =\n  lexeme\n    ( do\n        _ <- char '('\n        ss <- some sexpr -- ERROR: Variable not in scope: sexpr\n        _ <- char ')'\n        return $ Paren ss\n    )\n```\n\nì—ëŸ¬ê°€ ë‚  ê²ƒì´ì§€ë§Œ ìš°ì„ ì€ S-Expressionì„ ì¢…í•©ì ìœ¼ë¡œ íŒŒì‹±í•´ì£¼ëŠ” `sexpr`ë¥¼ ì™„ì„±í•´ë³´ì. ì´ë¯¸ S-Expressionì˜ variantëŠ” ëª¨ë‘ íŒŒì‹±í•  ìˆ˜ ìˆìœ¼ë‹ˆ, ì´ë¥¼ ì¡°í•©ë§Œ í•˜ë©´ ëœë‹¤.\n\n```haskell\nsexpr :: Parser Sexpr\nsexpr = paren <|> number <|> ident\n```\n\nì˜ ë˜ëŠ”ì§€ í™•ì¸í•´ë³´ì!\n\n```haskell\nmain :: IO ()\nmain = do\n    parseTest sexpr \"(+ 1 2 3)\" -- Paren [Ident \"+\",Number 1,Number 2,Number 3]\n    parseTest sexpr \"(+ 1 (* foo spam) 4)\" -- Paren [Ident \"+\",Number 1,Paren [Ident \"*\",Ident \"foo\",Ident \"spam\"],Number 4]\n    parseTest sexpr \"5\" -- Number 5\n    parseTest sexpr \"foo\" -- Ident \"foo\"\n```\n\në¬¸ì œì—†ì´ ì˜ íŒŒì‹±ì´ ëœë‹¤ë©´ ì§€ê¸ˆê¹Œì§€ ì˜ ë”°ë¼ì˜¨ ê²ƒì´ë‹¤ğŸ‰ğŸ‰\n\nNOTE: `paren`ì€ ë‹¤ìŒê³¼ ê°™ì´ ê°„ê²°í•˜ê²Œ ë‚˜íƒ€ë‚¼ ìˆ˜ë„ ìˆë‹¤!\n\n```haskell\nparen :: Parser Sexpr\nparen = Paren <$> lexeme (char '(' *> some sexpr <* char ')')\n```\n\nì•„ë˜ëŠ” ì§€ê¸ˆê¹Œì§€ ì‘ì„±í•œ íŒŒì„œ ì½”ë“œì´ë‹¤.\n\n```haskell\n-- src/Parser.hs\nmodule Parser (Sexpr (..), number, ident, paren, sexpr) where\n\nimport Data.List.NonEmpty (NonEmpty (..))\nimport qualified Data.Set as Set\nimport Data.Text (Text)\nimport Data.Void (Void)\nimport Text.Megaparsec (ErrorItem (..), MonadParsec (token), Parsec, Stream (Token), many, satisfy, some, (<|>))\nimport Text.Megaparsec.Char (alphaNumChar, char, letterChar, space)\nimport qualified Text.Megaparsec.Char.Lexer as L\n\ntype Parser = Parsec Void Text\n\ndata Sexpr\n  = Paren [Sexpr]\n  | Number Int\n  | Ident String\n  deriving (Show)\n\nlexeme :: Parser a -> Parser a\nlexeme p = p <* space\n\nnumber :: Parser Sexpr\nnumber = Number <$> lexeme L.decimal\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%&'*+,-./:<=>?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n\nident :: Parser Sexpr\nident = Ident <$> lexeme p\n  where\n    first = letterChar <|> symbolChar\n    rest = many (alphaNumChar <|> symbolChar)\n    p = (:) <$> first <*> rest\n\nparen :: Parser Sexpr\nparen = Paren <$> lexeme (char '(' *> some sexpr <* char ')')\n\nsexpr :: Parser Sexpr\nsexpr = paren <|> number <|> ident\n```\n\nì—¬ê¸°ê¹Œì§€ê°€ íŒŒì‹±ì´ë‹¤. ë‹¤ìŒ í¬ìŠ¤íŠ¸ì—ì„œëŠ” í‰ê°€ ë¶€ë¶„ì„ ë‹¤ë£¨ë„ë¡ í•˜ê² ë‹¤.\n","title":"í•˜ìŠ¤ì¼ˆë¡œ ê°„ë‹¨í•œ Lisp ë§Œë“¤ê¸° - íŒŒì‹±","tags":["ko","haskell"],"date":"2023-06-16"},{"id":"20230604-mission","content":"\n2023ë…„ 6ì›” 4ì¼, ì˜¤ëŠ˜ì€ ì œ ì „ì—­ë‚ ì…ë‹ˆë‹¤. í‰ì†Œê°™ì´ ì•„ì¹¨ì— ë¶€ëŒ€ ìƒí™œê´€ì—ì„œ ì¼ì–´ë‚˜ê³ , í‰ì†Œê°™ì´ ì í˜¸ë¥¼ ë°›ì•˜ì§€ë§Œ ì´ì   ë§ˆì§€ë§‰ì´ì—ˆìŠµë‹ˆë‹¤. êµ°ìƒí™œí•˜ë©° ì´ë¯¸ í›„ì„ë³´ë‹¤ëŠ” ì¹œêµ¬, í˜• ë™ìƒê³¼ ê°™ì•˜ë˜ ìˆ˜ë³‘ë“¤ì—ê²Œ ê³¼ë¶„í•œ ì¶•í•˜ë¥¼ ë°›ê³  ì •ë¬¸ì„ ë‚˜ì™”ìŠµë‹ˆë‹¤.\n\nì…ëŒ€í•  ë• ì´ë‚ ì´ ì–¸ì œ ì˜¤ë‚˜ ì‹¶ì—ˆì§€ë§Œ, ì ì  ë‹¤ê°€ì˜¬ìˆ˜ë¡ ì˜¤íˆë ¤ ë¶ˆì•ˆí•œ ì‹¬ì •ì„ ëŠë¼ê¸°ë„ í–ˆì—ˆìŠµë‹ˆë‹¤. ì œê°€ ì „ì—­í•˜ê³  ë¬´ì—‡ì„ í• ì§€, 2023ë…„ì´ ë§‰ ë˜ì—ˆì„ ë‹¹ì‹œì—ë„ ì œëŒ€ë¡œ ê²°ì •í•˜ì§€ ëª»í–ˆì—ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë¨¸ì§€ ì•Šì•„, ê²°êµ­ ì €ëŠ” ì„ êµì‚¬ì—…ì„ í•˜ëŸ¬ ë– ë‚˜ê¸°ë¡œ ê²°ì •í–ˆìŠµë‹ˆë‹¤.\n\nì„ êµì‚¬ì—…ì„ ê²°ì‹¬í•œ ì²« ë²ˆì§¸ ì´ìœ ëŠ”, ì €ì˜ ì‹ ì•™ì„ ê°•í™”í•˜ê³  ì‹¶ì–´ì„œì˜€ìŠµë‹ˆë‹¤. ì œê°€ ì˜ì ìœ¼ë¡œ ì™„ì „íˆ ìë¦½í•˜ì§€ ì•Šì•˜ë‹¤ê³  ìì£¼ ëŠê¼ˆì—ˆìŠµë‹ˆë‹¤. ì‹œê°„ì´ ë§ì•˜ë˜ êµ°ìƒí™œ ë§ë…„ì—, ì„ êµì‚¬ì—…ì„ ì¤€ë¹„í•˜ì—¬ ì£¼ë‹˜ì˜ ë§ì”€ì„ ì—´ì‹¬íˆ êµ¬í–ˆìŠµë‹ˆë‹¤. ì €ëŠ” ê¸°ë„ì˜ ì‘ë‹µìœ¼ë¡œ ê°€ìŠ´ì´ ë”°ëœ»í•´ì§€ëŠ” ê²½í—˜ë„ í•˜ê³ , ë¬´ì—‡ë³´ë‹¤ ì œê°€ ìŠ¤ìŠ¤ë¡œ ì¤‘ìš”í•˜ë‹¤ê³  ìƒê°í–ˆë˜ ê°€ì¹˜ë“¤ì´, ì‚¬ì‹¤ì€ êµíšŒë¥¼ ë‹¤ë‹ˆë©° ë§Œë“¤ì–´ì§„ ê°€ì¹˜ë“¤ì´ë¼ëŠ” ê²ƒì„ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì„ êµì‚¬ë¡œì„œ ë‹¤ë¥¸ ì‚¬ëŒë“¤ì—ê²Œë„ ê°™ì€ ê¸°íšŒë¥¼ ì£¼ê³  ì‹¶ë‹¤ëŠ” ìƒˆë¡œìš´ ë™ê¸°ë„ ì°¾ì•˜ìŠµë‹ˆë‹¤.\n\nì„ êµì‚¬ë¡œì„œ ë´‰ì‚¬í•˜ê² ë‹¤ëŠ” ì‹ ì²­ì„ í•˜ê²Œ ë˜ë©´, ëª‡ ê°œì›” ë’¤ êµíšŒ ë³¸ë¶€ì—ì„œëŠ” ì–¸ì œë¶€í„°, ì–´ëŠ ê³³ì—ì„œ ë´‰ì‚¬í• ì§€ë¥¼ ê²°ì •í•˜ì—¬ ë¶€ë¦„ì¥ì— ë‹´ì•„ íšŒì‹ í•©ë‹ˆë‹¤. ì œê°€ ì „ì—­í•˜ëŠ” ë‚ ì— ë¶€ë¦„ì¥ì„ ì—´ì–´ë³´ê²Œ ë  ì¤„ì€, ë¶€ë¦„ì¥ì´ ë„ì°©í•œ ì „ì—­í•˜ê¸° ì „ë‚ ì´ ë˜ì–´ì„œì•¼ ì•Œê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤. ì§‘ì— ë„ì°©í•˜ì—¬ ê°€ì¡±ê³¼ í•¨ê»˜ ë¶€ë¦„ì¥ì„ ì—´ì—ˆê³ , ì œê°€ **8ì›” 7ì¼ë¶€í„° ë‰´ìš• ì‹œí‹° ì„ êµë¶€**ì—ì„œ ë´‰ì‚¬í•˜ê²Œ ë  ê²ƒì„ ì•Œì•˜ìŠµë‹ˆë‹¤.\n\nì„ êµ í™œë™ì„ í•˜ë©° ì–´ë–¤ ì¼ì´ ë²Œì–´ì§ˆì§€ ì „í˜€ ëª¨ë¥´ê² ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë§ì€ ì‚¬ëŒë“¤ì„ ë•ê³ , ê·¸ ê³¼ì •ì—ì„œ ì € ìŠ¤ìŠ¤ë¡œë„ ë§ì€ ì„±ì¥ì„ í•˜ê²Œ ë  ê²ƒê³¼, ê·¸ ì‹œê°„ì´ í—›ë˜ì§€ ì•Šì„ ê²ƒ ë˜í•œ ì•Œê³  ìˆìŠµë‹ˆë‹¤. ê°€ê¸° ì „ê¹Œì§€ ë‚¨ì€ ì§§ì€ ì‹œê°„ë™ì•ˆ ì˜ ì¤€ë¹„í•˜ì—¬ ë” í›Œë¥­í•œ ì£¼ë‹˜ì˜ ë„êµ¬ë¡œì„œ ë´‰ì‚¬í•  ìˆ˜ ìˆë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤!\n\n> ì´ì— ì´ì œ ì´ë ‡ê²Œ ë˜ì—ˆë‚˜ë‹ˆ ì•¨ë§ˆì™€ ê·¸ì˜ í˜•ì œë“¤ ìœ„ì— ì§€ì›Œì§„ ì§ì´ ê°€ë²¼ì›Œì¡Œê³ , ì°¸ìœ¼ë¡œ ì£¼ê»˜ì„œ ê·¸ë“¤ì„ ê°•í•˜ê²Œ í•˜ì‚¬ ê·¸ë“¤ë¡œ ì‰½ê²Œ ê·¸ë“¤ì˜ ì§ì„ ì§€ê²Œ í•˜ì‹œë§¤, ê·¸ë“¤ì´ ì£¼ì˜ ëª¨ë“  ëœ»ì— ì¦ê±°ì´ ì¸ë‚´ë¥¼ ê°€ì§€ê³  ë³µì¢…í•˜ì˜€ë”ë¼. (ëª¨ì‚¬ì´ì•¼ 24:16)\n","title":"ì „ì—­, ê·¸ë¦¬ê³  ì•ˆë…•","tags":["ko","diary"],"date":"2023-06-04"},{"id":"20230430-simple-but-powerful-pratt-parsing","content":"\nì•„ë˜ ê¸€ì€ [matklad](https://github.com/matklad)ì˜ [Simple but Powerful Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html)ì˜ ë²ˆì—­ í¬ìŠ¤íŒ…ì…ë‹ˆë‹¤. ì œ ìŠ¤ìŠ¤ë¡œì˜ ì´í•´ë¥¼ ë•ê¸° ìœ„í•¨ì´ ëª©ì ì´ì§€ë§Œ, ìœ ìµí•œ ê¸€ì¸ ê²ƒ ê°™ì•„ ë¸”ë¡œê·¸ì— ì†Œê°œí•˜ê³ ë„ ì‹¶ì—ˆìŠµë‹ˆë‹¤.\n\n## Simple but Powerful Pratt Parsing\n\ní”„ë« íŒŒì‹± ê¸€ì— ì˜¨ ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤! í”„ë« íŒŒì‹±ì€ êµ¬ë¬¸ ë¶„ì„ê³„ì˜ ëª¨ë‚˜ë“œ íŠœí† ë¦¬ì–¼ê³¼ ê°™ë‹¤ê³ ë„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ì£¼ì œì— ê´€í•œ ì†Œê°œê¸€ì€ ë„ˆë¬´ ë§ì•„ì„œ [ì´ëŸ° íŠœí† ë¦¬ì–¼ ëª¨ìŒ](https://www.oilshell.org/blog/2017/03/31.html)ê¹Œì§€ ìˆì„ ì •ë„ì…ë‹ˆë‹¤.\n\nì´ ê¸€ì˜ ëª©í‘œëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.\n\n- ì´ë¥¸ë°” left-recursion ë¬¸ì œê°€ ê³¼ì¥ë˜ì—ˆìŒì„ ì œê¸°í•˜ê¸° ìœ„í•´\n- BNF í‘œê¸°ë²•ì´ ì¤‘ìœ„í‘œí˜„ì‹ì„ í‘œí˜„í•˜ê¸°ì— ë¶€ì í•©í•¨ì„ ì§€ì í•˜ê¸° ìœ„í•´\n- í”„ë« íŒŒì‹± ì•Œê³ ë¦¬ì¦˜ì˜ êµ¬í˜„ì„ ê³¼í•œ ì¶”ìƒí™” ì—†ì´, ìˆëŠ” ê·¸ëŒ€ë¡œ ë³´ì—¬ì£¼ê¸° ìœ„í•´\n- ì´ ì•Œê³ ë¦¬ì¦˜ì„ ì œê°€ ì œëŒ€ë¡œ ì´í•´í•˜ê¸° ìœ„í•´ (ì œê°€ ì‹¤ì‚¬ìš© ìš©ë„ë¡œ í”„ë« íŒŒì„œë¥¼ [êµ¬í˜„](https://github.com/rust-lang/rust-analyzer/blob/c388130f5ffbcbe7d3131213a24d12d02f769b87/crates/ra_parser/src/grammar/expressions.rs#L280-L281)í•œ ì ì´ ìˆëŠ”ë°, ì´ì œëŠ” ì½”ë“œë¥¼ ë´ë„ ë°”ë¡œ ì´í•´ë˜ì§€ê°€ ì•Šë”ë¼ê³ ìš”)\n\n## Introduction\n\níŒŒì‹±ì´ë¼ëŠ” ê²ƒì€, ì¼ë ¨ì˜ í† í°ë“¤ì´ ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ë³€í™˜ë˜ëŠ” ê³¼ì •ì„ ì´ì•¼ê¸°í•©ë‹ˆë‹¤.\n\n```plaintext\n                            Add\n                 Parser     / \\\n \"1 + 2 * 3\"    ------->   1  Mul\n                              / \\\n                             2   3\n```\n\níŒŒì‹±ì„ ì ‘ê·¼í•˜ëŠ” ë°©ì‹ì€ ë‹¤ì–‘í•œë°, í¬ê²Œ ë‘ ë¶€ë¥˜ë¡œ ë‚˜ëˆ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n- íŒŒì‹±í•˜ë ¤ëŠ” ì–¸ì–´ì˜ ë¬¸ë²•ì„ DSLì„ ì‚¬ìš©í•˜ì—¬ í‘œí˜„í•˜ê³ , ê·¸ ë¬¸ë²•ì„ ì´ìš©í•˜ì—¬ íŒŒì„œë¥¼ ìƒì„±í•´ë‚´ëŠ” ë°©ë²•\n- ì§ì ‘ ì†ìœ¼ë¡œ íŒŒì„œë¥¼ ì‘ì„±í•˜ëŠ” ë°©ë²•\n\në‘ ë²ˆì§¸ ë°©ì‹ ì•ˆì—ì„œ ê°€ì¥ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” ê¸°ë²•ì´ ë°”ë¡œ í”„ë« íŒŒì‹±ì…ë‹ˆë‹¤.\n\n## BNF\n\në¬¸ë§¥ ììœ (Context-Free) ë¬¸ë²• í‘œê¸°ë²•(ì£¼ë¡œ BNF concrete syntaxë¥¼ ì‚¬ìš©)ì€ êµ¬ë¬¸ë¶„ì„ ì´ë¡ ì— ì¤‘ìš”í•œ ë°œê²¬ì´ì—ˆìŠµë‹ˆë‹¤. BNFë¥¼ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ ë³¸ë˜ ì„ í˜•ì ì¸ ë¬¸ì¥ êµ¬ì¡°ë¥¼ íŠ¸ë¦¬ í˜•íƒœë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n```plaintext\nItem ::=\n    StructItem\n  | EnumItem\n  | ...\n\nStructItem ::=\n    'struct' Name '{' FieldList '}'\n\n...\n```\n\nì²˜ìŒ ì´ ê¸°ë²•ì„ ë³´ë©° ê°íƒ„í–ˆë˜ ê¸°ì–µì´ ë‚©ë‹ˆë‹¤.\n\ní‘œí˜„ì‹ì„ ë‚˜íƒ€ë‚´ëŠ” ë°©ì‹ì„ ë³´ê³  ê°‘ìê¸° ì¢€ ì„œìš´í•´ì¡Œì§€ë§Œìš”.\n\ní‘œí˜„ì‹ì„ ë‚˜íƒ€ë‚´ëŠ” ì§ê´€ì ì¸ í˜•íƒœì˜ ë¬¸ë²•ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.\n\n```plaintext\nExpr ::=\n    Expr '+' Expr\n  | Expr '*' Expr\n  | '(' Expr ')'\n  | 'number'\n```\n\nê½¤ ì§ê´€ì ì´ì£ . ê·¼ë° ì‚¬ì‹¤ ìœ„ ë¬¸ë²•ì€ **ëª¨í˜¸**í•´ì„œ ìë™ íŒŒì„œ ìƒì„±ê¸°(ìœ„ì—ì„œ ì–¸ê¸‰ëœ 1ë²ˆ ë°©ì‹)ì— ì‚¬ìš©ë˜ê¸° ìœ„í•´ì„œëŠ” ê³ ì³ì„œ ì‘ì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤. ë” êµ¬ì²´ì ìœ¼ë¡œ ì–˜ê¸°í•˜ìë©´, ì—°ì‚°ìì˜ ìš°ì„ ìˆœìœ„ì™€ ê²°í•©ë°©í–¥ì„ ì˜ ê³ ë ¤í•œ ë¬¸ë²•ì„ ì‘ì„±í•´ì•¼ í•˜ëŠ”ë°ìš”, ì•„ë˜ì™€ ê°™ì´ ìˆ˜ì •í•˜ë©´ ì•ì„œ ì–¸ê¸‰ëœ ë¬¸ì œë“¤ì„ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n```plaintext\nExpr ::=\n    Factor\n  | Expr '+' Factor\n\nFactor ::=\n    Atom\n  | Factor '*' Atom\n\nAtom ::=\n    'number'\n  | '(' Expr ')'\n```\n\nì–´ë–¤ê°€ìš”? ì†”ì§íˆ ì´ ìƒˆë¡œìš´ ë¬¸ë²•ì€ ì œê°€ ì²˜ìŒ ìƒê°í–ˆë˜ í‘œí˜„ì‹ì˜ ëª¨ì–‘ê³¼ëŠ” ì „í˜€ ë‹¬ë¼ ë³´ì…ë‹ˆë‹¤. ê°€ì¥ ë¨¼ì € ë‚˜ì˜¨ ëª¨í˜¸í•œ ë¬¸ë²•ì´ ë” ì§ê´€ì ì´ê³ , ë”êµ°ë‹¤ë‚˜ ì œê°€ ìŠ¤ìŠ¤ë¡œ ë¬¸ë²•ì„ ì´ë ‡ê²Œ ê³ ì¹  ìˆ˜ ìˆì„ë•Œê¹Œì§€ ì–¸ì–´ë¡ ì— ëŒ€í•´ ì „ê³µìˆ˜ì—…ë§Œ ì„¸ë„¤ê°œ ë“¤ì—ˆì–´ì•¼ í–ˆë˜ ê²ƒ ê°™ìŠµë‹ˆë‹¤.\n\nì´ê²ƒì´ ì œê°€ í”„ë« íŒŒì‹±ì„ ì¢‹ì•„í•˜ëŠ” ì´ìœ ì…ë‹ˆë‹¤. ë¬¸ë²•ì„ ë¶€ìì—°ìŠ¤ëŸ½ê²Œ ê³ ì³ì•¼ í•˜ëŠ” ì¬ê·€í•˜í–¥ì‹ íŒŒì‹± ê¸°ë²•ì—ì„œ ë°œì „í•´ì„œ, ì—°ì‚°ìì™€ ê²°í•©ë°©í–¥ì„ ìì—°ìŠ¤ëŸ½ê²Œ í‘œí˜„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.\n\n## ì¬ê·€í•˜í–¥ê³¼ Left-Recursion\n\nì¬ê·€í•˜í–¥ì€ ì§ì ‘ íŒŒì„œë¥¼ ì§¤ ë•Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê°€ì¥ ê¸°ë³¸ì ì¸ ê¸°ë²•ì…ë‹ˆë‹¤. ì´ ê¸°ë²•ì€ ì„œë¡œ ì¬ê·€ì ì¸ í•¨ìˆ˜ë“¤ì„ ì‚¬ìš©í•˜ì—¬ íŒŒì‹±ì„ í•˜ëŠ”ë°, ì˜ˆë¥¼ ë“¤ì–´ ìœ„ì— ìˆëŠ” ë¬¸ë²•ì€ ì¬ê·€í•˜í–¥ì„ ì¼ì„ ë•Œ ë‹¤ìŒê³¼ ê°™ì´ ì½”ë“œë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n```rust\nfn item(p: &mut Parser) {\n    match p.peek() {\n        STRUCT_KEYWORD => struct_item(p),\n        ENUM_KEYWORD   => enum_item(p),\n        ...\n    }\n}\n\nfn struct_item(p: &mut Parser) {\n    p.expect(STRUCT_KEYWORD);\n    name(p);\n    p.expect(L_CURLY);\n    field_list(p);\n    p.expect(R_CURLY);\n}\n```\n\në³´í†µ êµê³¼ì„œë“¤ì€ Left Recursive ë¬¸ë²•ì„ ì´ ì ‘ê·¼ ë°©ì‹ì˜ ë‹¨ì ì´ë¼ê³  ì§€ì í•˜ë©´ì„œ, ë” ì‹¬í™”ëœ LR íŒŒì‹± ê¸°ë²•ìœ¼ë¡œ ë„˜ì–´ê°€ëŠ” ë™ê¸°ë¡œ ì‚¼ìŠµë‹ˆë‹¤. Left Recursionì€ ë¶„ëª…íˆ ë¬¸ì œê°€ ë˜ëŠ” ì‹œì ë“¤ì´ ìˆëŠ”ë°, ì•„ë˜ ë¬¸ë²•ì„ í•œ ë²ˆ ë³´ê² ìŠµë‹ˆë‹¤.\n\n```plaintext\nSum ::=\n    Sum '+' Int\n  | Int\n```\n\nì¬ê·€í•˜í–¥ ë°©ì‹ìœ¼ë¡œ ìœ„ ë¬¸ë²•ì— ëŒ€í•œ íŒŒì„œë¥¼ ì‘ì„±í•´ë³´ê² ìŠµë‹ˆë‹¤.\n\n```rust\nfn sum(p: &mut Parser) {\n    // Sum '+' Intê°€ ë˜ëŠ”ì§€ ë¨¼ì € ì‹œë„í•´ë³¸ë‹¤\n    sum(p); // â‘ \n    p.expect(PLUS);\n    int(p);\n    // ìœ„ì—ì„œ ì‹¤íŒ¨í–ˆìœ¼ë©´, ê·¸ ë‹¤ìŒ í›„ë³´ì§€ë¥¼ ì‹œë„í•´ë³¸ë‹¤.\n    ...\n}\n```\n\n1. ì´ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ë©´ ì½”ë“œê°€ ë¬´í•œ ì¬ê·€ì— ë¹ ì ¸ë²„ë ¤ì„œ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°ê°€ ë°œìƒí•´ë²„ë¦½ë‹ˆë‹¤.\n\nì´ëŸ° ë¬¸ì œë¥¼ ê³ ì¹˜ê¸° ìœ„í•œ ì´ë¡ ì ì¸ ë°©ë²•ì€ ì—­ì‹œ ë¬¸ë²•ì„ ìˆ˜ì •í•´ì„œ, **ê°™ì€ ì–¸ì–´ë¥¼ í‘œí˜„í•˜ë˜ ìœ„ì™€ ê°™ì€ ë¬¸ì œê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ Left Recursionì„ ì—†ì•¤ ë¬¸ë²•**ì„ ì‘ì„±í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\ní•˜ì§€ë§Œ ì§ì ‘ ì‘ì„±í•˜ëŠ” íŒŒì„œì˜ ê²½ìš°ì—ëŠ” ì‹¤ìš©ì ì¸ í•´ê²°ë°©ë²•ë„ ìˆëŠ”ë°, ê·¸ëƒ¥ ì¬ê·€ë¥¼ ë²„ë¦¬ê³  ë°˜ë³µë¬¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\n```rust\nfn sum(p: &mut Parser) {\n    int(p);\n    while p.eat(PLUS) {\n        int(p);\n    }\n}\n```\n\n## í”„ë« íŒŒì‹±ì˜ ë¼ˆëŒ€\n\nìœ„ì™€ ê°™ì´ ë°˜ë³µë¬¸ì„ ì´ìš©í•´ì„œ Left Recursionì„ ì‹¤ìš©ì ìœ¼ë¡œ ëŒ€ì²˜í•˜ëŠ” ë°©ë²•ì„ ë³´ì•˜ëŠ”ë°, í”„ë« íŒŒì‹±ì€ ë°˜ë³µë¬¸ê³¼ ì¬ê·€ë¥¼ ë™ì‹œì— ì‚¬ìš©í•©ë‹ˆë‹¤.\n\n```rust\nfn parse_expr() {\n    ...\n    loop {\n        ...\n        parse_expr()\n        ...\n    }\n}\n```\n\nìœ„ì— ìˆëŠ” ì½”ë“œëŠ” ì—°ì‚°ì ìš°ì„ ìˆœìœ„ì™€ ê²°í•©ë°©í–¥ì„ ì˜ ì²˜ë¦¬í•´ì¤ë‹ˆë‹¤. ë¨¸ë¦¬ê°€ ëµí•´ì§€ê¸´ í•˜ì§€ë§Œìš”.\n\n## ìš°ì„ ìˆœìœ„ì—ì„œ ê²°í•© ì„¸ê¸°ë¡œ\n\nì†”ì§íˆ ë§í•˜ë©´ ì €ëŠ” \"ë†’ì€ ìš°ì„ ìˆœìœ„\"ì™€ \"ë‚®ì€ ìš°ì„ ìˆœìœ„\"ë¼ëŠ” ìš©ì–´ë¥¼ ë³´ë©° í•­ìƒ í—·ê°ˆë¦¬ëŠ” ê²ƒ ê°™ìŠµë‹ˆë‹¤. `a + b * c` ë¼ëŠ” í‘œí˜„ì‹ ì•ˆì—ì„œ ë§ì…ˆì€ ìš°ì„ ìˆœìœ„ê°€ **ë‚®ì€ë°**, íŒŒì‹± íŠ¸ë¦¬ì—ì„œëŠ” **ë§¨ ìœ„ì—** ìˆìŠµë‹ˆë‹¤.\n\nê·¸ë˜ì„œ ì €ëŠ” **ê²°í•© ì„¸ê¸°**ë¼ëŠ” í‘œí˜„ì´ ë” ì§ê´€ì ì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤.\n\n```plaintext\nexpr:   A       +       B       *       C\npower:      3       3       5       5\n```\n\n`*`ì´ ë” ì„¸ë‹ˆê¹Œ Bì™€ Cë¥¼ ëŒì–´ë‹¹ê¸°ëŠ” í˜ì´ ë” ì„¸ê³ , ìœ„ í‘œí˜„ì‹ì€ `A + (B * C)`ì™€ ê°™ì´ íŒŒì‹±ì´ ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\nê²°í•© ë°©í–¥ì€ ì–´ë–»ê²Œ í‘œí˜„í•  ìˆ˜ ìˆì„ê¹Œìš”? `A + B + C`ë¥¼ ë³´ë©´ ëª¨ë“  ì—°ì‚°ìë“¤ì´ ê°™ì€ ì„¸ê¸°ë¥¼ ê°€ì§€ê³  ìˆì–´ì„œ ì–´ë–»ê²Œ íŒŒì‹±ì´ ë˜ì–´ì•¼ í• ì§€ ë¶ˆëª…í™•í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ê²ƒë„ ì•„ë˜ì™€ ê°™ì´ ê²°í•© ì„¸ê¸°ë¡œ í‘œí˜„í•  ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.\n\n```plaintext\nexpr:      A       +       B       +       C\npower:  0      3      3.1      3      3.1     0\n```\n\nì˜¤ë¥¸ìª½ í”¼ì—°ì‚°ìë¥¼ ë‹¹ê¸°ëŠ” í˜ì´ ë” ê°•í•´ì§€ë„ë¡ `+`ì˜ ì˜¤ë¥¸ìª½ ê²°í•© ì„¸ê¸°ë¥¼ ì¡°ê¸ˆ ì˜¬ë¦° ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì–‘ì˜† ëì— `0`ì´ ìˆëŠ” ê²ƒë„ ë³¼ ìˆ˜ ìˆëŠ”ë°, ì´ê±´ ë§¨ ëì—ì„œëŠ” ë‹¹ê¸°ëŠ” í˜ì´ ì—†ë‹¤ëŠ” ê²ƒì„ í‘œí˜„í•œ ê²ƒì…ë‹ˆë‹¤. Bì˜ ì…ì¥ì—ì„œ ë´¤ì„ ë•Œ, ì™¼ìª½ì—ì„œ ë” ê°•í•˜ê²Œ ê²°í•©í•˜ë ¤ê³  í•˜ê¸° ë•Œë¬¸ì— ìš°ì„  ì²« ë‹¨ê³„ë¡œëŠ” ì•„ë˜ì™€ ê°™ì´ íŒŒì‹±ì´ ë  ê²ƒì…ë‹ˆë‹¤.\n\n```plaintext\nexpr:     (A + B)     +     C\npower:  0          3    3.1    0\n```\n\nê·¸ ë‹¤ìŒ ë‹¨ê³„ë¥¼ ê±°ì¹˜ë©´ ê²°êµ­ `(A + B) + C` ê°€ ë©ë‹ˆë‹¤.\n\ní”„ë« íŒŒì‹±ì´ í•˜ëŠ” ì¼ì€ ìŠ¤íŠ¸ë§ì„ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì½ìœ¼ë©° ìš°ë¦¬ê°€ ìœ„ì—ì„œ ë³¸ ê³¼ì •ì„ ì „ë¶€ ì²˜ë¦¬í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\nì˜¤ë¥¸ìª½ìœ¼ë¡œ ê²°í•©í•˜ëŠ” ì—°ì‚°ìëŠ” ì–´ë–»ê²Œ ì²˜ë¦¬í•˜ë©´ ì¢‹ì„ê¹Œìš”? ì˜ˆì‹œë¡œ, í•˜ìŠ¤ì¼ˆì— ìˆëŠ” í•¨ìˆ˜ í•©ì„± ì—°ì‚°ì `.`ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ëª¨ë¸ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤\n\n```plaintext\n  f     .    g     .    h\n0   8.5    8   8.5    8   0\n```\n\nê·¸ëŸ¬ë©´ ìœ„ í‘œí˜„ì‹ì€ `f . (g . h)` ì™€ ê°™ì´ íŒŒì‹±ì´ ë˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\n## ë¯¸ë‹ˆë©€í•œ í”„ë« íŒŒì„œ\n\nì´ì œë¶€í„° í”„ë« íŒŒì„œë¥¼ ì´ìš©í•´ì„œ ìºë¦­í„° í•˜ë‚˜ì§œë¦¬ ìˆ«ìì™€ ë³€ìˆ˜(ë¬¶ì–´ì„œ ì•„í†°), ê·¸ë¦¬ê³  íŠ¹ìˆ˜ë¬¸ìë¥¼ ì‚¬ìš©í•œ ì—°ì‚°ìê°€ ìˆëŠ” í‘œí˜„ì‹ì„ íŒŒì‹±í•´ë³´ê² ìŠµë‹ˆë‹¤.\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Token {\n    Atom(char),\n    Op(char),\n    Eof,\n}\n\nstruct Lexer {\n    tokens: Vec<Token>,\n}\n\nimpl Lexer {\n    fn new(input: &str) -> Lexer {\n        let mut tokens = input\n            .chars()\n            .filter(|it| !it.is_ascii_whitespace())\n            .map(|c| match c {\n                '0'..='9' |\n                'a'..='z' | 'A'..='Z' => Token::Atom(c),\n                _ => Token::Op(c),\n            })\n            .collect::<Vec<_>>();\n        tokens.reverse();\n        Lexer { tokens }\n    }\n\n    fn next(&mut self) -> Token {\n        self.tokens.pop().unwrap_or(Token::Eof)\n    }\n\n    fn peek(&mut self) -> Token {\n        self.tokens.last().copied().unwrap_or(Token::Eof)\n    }\n}\n```\n\nê²°í•© ì„¸ê¸°ê°€ ì˜ ë°˜ì˜ë˜ì–´ íŒŒì‹±ëëŠ”ì§€ í™•ì¸í•´ë³´ê¸° ìœ„í•´, íŒŒì‹±ëœ í‘œí˜„ì‹ì„ ì¤‘ìœ„í‘œí˜„ì‹ì—ì„œ ë„ë¦¬ ì‚¬ìš©ë˜ëŠ” í‘œí˜„ ë°©ì‹ìœ¼ë¡œ ë³€í™˜í•´ë³´ê² ìŠµë‹ˆë‹¤. ì´ ë°©ì‹ì€ (ì•„ë§ˆë„ í´ë€ë“œì—ì„œëŠ” ë³„ë¡œ ì¸ê¸°ê°€ ì—†ê² ì§€ë§Œ) ë°”ë¡œ S-í‘œí˜„ì‹ì…ë‹ˆë‹¤. Lisp ê³„ì—´ ì–¸ì–´ì—ì„œ ì§€ê²¹ë„ë¡ ë³¼ ìˆ˜ìˆëŠ” í‘œí˜„ ë°©ì‹ì´ì£ .\n\n```plaintext\n1 + 2 * 3 == (+ 1 (* 2 3))\n```\n\n```rust\nuse std::fmt;\n\nenum S {\n    Atom(char),\n    Cons(char, Vec<S>),\n}\n\nimpl fmt::Display for S {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            S::Atom(i) => write!(f, \"{}\", i),\n            S::Cons(head, rest) => {\n                write!(f, \"({}\", head)?;\n                for s in rest {\n                    write!(f, \" {}\", s)?\n                }\n                write!(f, \")\")\n            }\n        }\n    }\n}\n```\n\në‹¨ìˆœí•˜ê²Œ ì‹œì‘í•˜ì£ . ë¨¼ì € ì•„í†°ê³¼ `+`, `*` ì—°ì‚°ìë§Œìœ¼ë¡œ ì´ë£¨ì–´ì§„ í‘œí˜„ì‹ì„ íŒŒì‹±í•´ë´…ì‹œë‹¤.\n\n```rust\nfn expr(input: &str) -> S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(&mut lexer)\n}\n\nfn expr_bp(lexer: &mut Lexer) -> S {\n    todo!()\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\")\n}\n```\n\nìœ„ì—ì„œ ë³¸ left recursionì— ëŒ€í•œ **ì‹¤ìš©ì ì¸ ëŒ€ì²˜ë°©ì‹**ê³¼ ìœ ì‚¬í•˜ê²Œ ì ‘ê·¼í•´ë³´ê² ìŠµë‹ˆë‹¤. ë¨¼ì € ìˆ«ìë¥¼ íŒŒì‹±í•˜ê³ , ë°˜ë³µë¬¸ì„ ëŒê³ , ì—°ì‚°ìë¥¼ íŒŒì‹±í•˜ê³  ë‚˜ì„œëŠ”, ìŒ.. ì•„ì§ì€ ëª¨ë¥´ê² ë„¤ìš”.\n\n```rust\nfn expr_bp(lexer: &mut Lexer) -> S {\n    let lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        t => panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.next() {\n            Token::Eof => break,\n            Token::Op(op) => op,\n            t => panic!(\"bad token: {:?}\", t),\n        };\n        todo!()\n    }\n    lhs\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n}\n```\n\nê·¸ë˜ë„ ì²« ë²ˆì§¸ í…ŒìŠ¤íŠ¸ëŠ” ë²Œì¨ í†µê³¼í•©ë‹ˆë‹¤!\n\nì•ì„œ ì–¸ê¸‰í•œ **ê²°í•© ì„¸ê¸°**ì˜ ê°œë…ì„ ì½”ë“œì— ë„ì…í•´ë´…ì‹œë‹¤. ê° ì—°ì‚°ìë§ˆë‹¤ ì–‘ì˜†ì„ ë‹¹ê¸°ëŠ” í˜ì„ `u8`ë¡œ ê°ê° ë‚˜íƒ€ë‚´ê³ , ê²°í•© ë°©í–¥ì„ í‘œí˜„í•˜ê¸° ìœ„í•´ í•œìª½ì˜ ê²°í•© ì„¸ê¸°ê°€ `1` ë” í¬ë„ë¡ ì„¤ì •í•˜ê² ìŠµë‹ˆë‹¤. `0`ì„ ì…ë ¥ì˜ ë§ˆì§€ë§‰ ë¶€ë¶„ì„ ë‚˜íƒ€ë‚´ëŠ” ê²°í•© ì„¸ê¸°ë¡œ ë‚˜íƒ€ë‚´ê³ , ì—°ì‚°ì ì¤‘ ê°€ì¥ ë‚®ì€ ê²°í•© ì„¸ê¸°ë¥¼ `1`ì´ë¼ê³  ë¯¸ë¦¬ ì•½ì†í•´ë‘ê² ìŠµë‹ˆë‹¤.\n\n```rust\nfn expr_bp(lexer: &mut Lexer) -> S {\n    let lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        t => panic!(\"bad token: {:?}\", t),\n    };\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof => break,\n            Token::Op(op) => op,\n            t => panic!(\"bad token: {:?}\", t),\n        };\n        let (l_bp, r_bp) = infix_binding_power(op);\n        todo!()\n    }\n    lhs\n}\n\nfn infix_binding_power(op: char) -> (u8, u8) {\n    match op {\n        '+' | '-' => (1, 2),\n        '*' | '/' => (3, 4),\n        _ => panic!(\"bad op: {:?}\")\n    }\n}\n```\n\nì´ì œë¶€í„° ì¡°ê¸ˆ ë³µì¡í•´ì§ˆí…ë°, ì¬ê·€í˜¸ì¶œì„ ì‚¬ìš©í•´ë³´ê² ìŠµë‹ˆë‹¤. ì•„ë˜ ì˜ˆì‹œë¥¼ ë³´ê² ìŠµë‹ˆë‹¤.\n\n```plaintext\na   +   b   *   c   *   d   +   e\n  1   2   3   4   3   4   1   2\n```\n\níŒŒì‹±ì€ í† í°ì„ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¤ìº”í•˜ë©° ì§„í–‰ì´ ë í…ë°, í˜„ì¬ í† í°ì„ ê°€ë¦¬í‚¤ëŠ” ì»¤ì„œê°€ ìˆë‹¤ê³  ìƒê°í•´ë³´ì£ .\n\nì»¤ì„œê°€ ì²˜ìŒ `+`ë¥¼ ë§Œë‚˜ê²Œ ë˜ë©´, `l_bp`ëŠ” `1`, `r_bp`ëŠ” `2`ì¼ ê²ƒì´ê³ , `lhs`ëŠ” `a`ë¥¼ ë‹´ê³  ìˆì„ ê²ƒì…ë‹ˆë‹¤. ë‹¤ìŒì— ë³´ì´ëŠ” ì—°ì‚°ìì¸ `*`ëŠ” `+`ë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ìœ¼ë‹ˆ, `a`ì™€ `b`ëŠ” ë”í•˜ë©´ ì•ˆë˜ê² ì£ ? í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì»¤ì„œë¥¼ ì›€ì§ì´ê³  ìˆìœ¼ë‹ˆ, `+`ë¥¼ ë°”ë¼ë³´ê³  ìˆëŠ” ì‹œì ì—ëŠ” `*`ì˜ ì¡´ì¬ ìœ ë¬´ë¥¼ ëª¨ë¥¼ ê²ƒì…ë‹ˆë‹¤. lookahead(ì „ë°©íƒìƒ‰)ë¥¼ ì¶”ê°€í•˜ë©´ í•´ê²°í•  ìˆ˜ ìˆì„ê¹Œìš”? ì•ˆë ê±´ ì—†ì§€ë§Œ ê·¸ ë²”ìœ„ê°€ ì–¼ë§ˆë‚˜ ë ì§€ ê°€ëŠ ì´ ì•ˆë©ë‹ˆë‹¤. ì§€ê¸ˆ ì˜ˆì‹œë§Œ ë´ë„ `b`, `c`, `d` í† í°ì„ ì „ë¶€ ìŠ¤ìº”í•´ì•¼ë§Œ ìš°ì„ ìˆœìœ„ ì²˜ë¦¬ë¥¼ ì œëŒ€ë¡œ í•  ìˆ˜ ìˆì„ í…Œë‹ˆê¹Œìš”.\n\nì²« ë²ˆì§¸ `+`ì´í›„ì— ë‚˜ì˜¤ëŠ” í‘œí˜„ì‹ `b * c * d`ê¹Œì§€ëŠ” ë†’ì€ ìš°ì„ ìˆœìœ„ë¡œ íŒŒì‹±ì„ í•´ì•¼ í•©ë‹ˆë‹¤. ì´ëŠ” ê½¤ ì§ê´€ì ìœ¼ë¡œ íŒë‹¨í•  ìˆ˜ ìˆì£ . ê·¼ë° `d`ê¹Œì§€ë§Œ íŒŒì‹±í•´ì•¼ í•˜ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ì¼ê¹Œìš”? ê·¸ ë‹¤ìŒì— ë‚˜ì˜¤ëŠ” `+`ì˜ ìš°ì„ ìˆœìœ„ê°€ ì²˜ìŒì— ë³¸ `+`ì˜ ìš°ì„ ìˆœìœ„ë³´ë‹¤ ë†’ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ê·¸ ì „ê¹Œì§€ ë³¸ ì—°ì‚°ìë“¤(`*`)ì€ ëª¨ë‘ `+`ë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë†’ì•˜ë‹¤ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\nì´ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ê² ìŠµë‹ˆë‹¤. `b`ì—ì„œ ë‹¤ì‹œ `expr_bp`ë¥¼ í˜¸ì¶œí•˜ë©´ì„œ, `+`ë³´ë‹¤ ìš°ì„ ìˆœìœ„ê°€ ë‚®ì•„ì§€ëŠ” ì¦‰ì‹œ, ì¦‰ `bp`ê°€ `2`ë³´ë‹¤ ë‚®ì•„ì§€ëŠ” ìˆœê°„ì— íŒŒì‹±ì„ ë©ˆì¶”ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\nì, ì•„ë˜ì— ë¯¸ë‹ˆë©€í•œ í”„ë« íŒŒì„œê°€ ì™„ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n```rust\nfn expr(input: &str) -> S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(&mut lexer, 0) // 5\n}\n\nfn expr_bp(lexer: &mut Lexer, min_bp: u8) -> S { // 1\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        t => panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof => break,\n            Token::Op(op) => op,\n            t => panic!(\"bad token: {:?}\", t),\n        };\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp < min_bp { // 2\n            break;\n        }\n\n        lexer.next(); // 3\n        let rhs = expr_bp(lexer, r_bp);\n        lhs = S::Cons(op, vec![lhs, rhs]); // 4\n    }\n\n    lhs\n}\n\nfn infix_binding_power(op: char) -> (u8, u8) {\n    match op {\n        '+' | '-' => (1, 2),\n        '*' | '/' => (3, 4),\n        _ => panic!(\"bad op: {:?}\"),\n    }\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\");\n\n    let s = expr(\"a + b * c * d + e\");\n    assert_eq!(s.to_string(), \"(+ (+ a (* (* b c) d)) e)\");\n}\n```\n\n1. `min_bp` ì¸ìëŠ” ì•„ì£¼ ì¤‘ìš”í•œ ë³€ê²½ì‚¬í•­ì…ë‹ˆë‹¤. `expr_bp`ëŠ” ì´ì œ íŠ¹ì • ê²°í•© ì„¸ê¸° ì´ìƒì˜ í‘œí˜„ì‹ë§Œ íŒŒì‹±í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. `min_bp`ë³´ë‹¤ ê²°í•© ê°•ë„ê°€ ë‚®ì€ ì—°ì‚°ìë¥¼ ë§Œë‚¬ì„ ê²½ìš°, ì¦‰ì‹œ íŒŒì‹±ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.\n2. ì´ê³³ì´ ë°”ë¡œ íŒŒì‹±ì„ ì¤‘ë‹¨í•˜ëŠ” ì‹œì ì…ë‹ˆë‹¤.\n3. `next` í˜¸ì¶œë¡œ ì¸í•´ ì—°ì‚°ì ìœ„ì— ìˆë˜ ì»¤ì„œë¥¼ í•œ ì¹¸ ì›€ì§ì´ê³ , ì¬ê·€í˜¸ì¶œì„ í•©ë‹ˆë‹¤. `min_bp`ë¥¼ ì—°ì‚°ìì˜ `l_bp`ì™€ ë¹„êµí•˜ëŠ” ëª¨ìŠµì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì–´ë–»ê²Œ ë³´ë©´ `min_bp`ëŠ” í˜„ì¬ íŒŒì‹±í•˜ê³  ìˆëŠ” ì»¤ë‹¤ë€ í‘œí˜„ì‹ì˜ ì™¼ìª½ì— ìœ„ì¹˜í•œ ì—°ì‚°ìì˜ ê²°í•© ì„¸ê¸°ë¼ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n4. `rhs`ë¥¼ ì˜ íŒŒì‹±í•˜ê³  ë‚œ ì´í›„ì—ëŠ”, ì´ë¯¸ íŒŒì‹±í•œ `lhs`ì™€ ê²°í•©í•˜ì—¬ ìƒˆë¡œìš´ `lhs`ë¥¼ ë§Œë“¤ì–´ëƒ…ë‹ˆë‹¤.\n5. ì¬ê·€í˜¸ì¶œì˜ ì‹œì‘ ì¸ìëŠ” `0`ì…ë‹ˆë‹¤. í‘œí˜„ì‹ì˜ ì–‘ëì€ ì—°ì‚°ìê°€ ì—†ìœ¼ë¯€ë¡œ ê²°í•© ì„¸ê¸°ê°€ `0`ì´ë¼ê³  ìœ„ì—ì„œ ì–¸ê¸‰í•œ ë°” ìˆìŠµë‹ˆë‹¤.\n\nìœ„ì— ìˆëŠ” ì•½ 40ì¤„ì˜ ì½”ë“œê°€ í”„ë« íŒŒì‹± ì•Œê³ ë¦¬ì¦˜ì´ë¼ê³  í•  ìˆ˜ ìˆê² ìŠµë‹ˆë‹¤. ì¡°ê¸ˆ ê¹Œë‹¤ë¡­ê¸´ í•˜ì§€ë§Œ, ì—´ì‹¬íˆ ì´í•´í•˜ê³  ë‚˜ë©´, ì´í›„ì— ì¶”ê°€í•˜ëŠ” ê¸°ëŠ¥ë“¤ì€ ê½¤ ë‹¨ìˆœí•©ë‹ˆë‹¤.\n\n## ì—°ì‚°ì ì¶”ê°€í•´ë³´ê¸°\n\nê¸°ë³¸ì ì¸ ë¼ˆëŒ€ëŠ” ì™„ì„±ë˜ì—ˆìœ¼ë‹ˆ, ì´ ì•Œê³ ë¦¬ì¦˜ì˜ ì§„ê°€ë¥¼ ë³´ì—¬ë“œë¦¬ê¸° ìœ„í•´ ë‹¤ì–‘í•œ í‘œí˜„ì‹ì„ ì¶”ê°€í•´ë³´ê² ìŠµë‹ˆë‹¤.\n\në¨¼ì €, ë†’ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ê³ , ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê²°í•©í•˜ëŠ” í•¨ìˆ˜ í•©ì„± ì—°ì‚°ìì¸ `.`ì„ ì¶”ê°€í•´ë³´ê² ìŠµë‹ˆë‹¤.\n\n```rust\nfn infix_binding_power(op: char) -> (u8, u8) {\n    match op {\n        '+' | '-' => (1, 2),\n        '*' | '/' => (3, 4),\n        '.' => (6, 5), // NEW\n        _ => panic!(\"bad op: {:?}\"),\n    }\n}\n```\n\në§ìŠµë‹ˆë‹¤. ìœ„ì™€ ê°™ì´ í•œ ì¤„ë§Œ ì¶”ê°€í•˜ë©´ ì¶©ë¶„í•©ë‹ˆë‹¤. ê¸°ì¡´ì— ì¶”ê°€ëœ ë‹¤ë¥¸ ì—°ì‚°ìë“¤ê³¼ëŠ” ë‹¤ë¥´ê²Œ ì™¼ìª½ ê²°í•© ì„¸ê¸°ê°€ ë” ê°•í•œ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê²°í•© ë°©í–¥ì´ ì˜¤ë¥¸ìª½ì´ê¸°ë¥¼ ì›í•˜ê¸° ë•Œë¬¸ì´ì£ .\n\n```rust\nlet s = expr(\"f . g . h\");\nassert_eq!(s.to_string(), \"(. f (. g h))\");\n\nlet s = expr(\" 1 + 2 + f . g . h * 3 * 4\");\nassert_eq!(s.to_string(), \"(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))\");\n```\n\n### ì „ìœ„ ë‹¨í•­ì—°ì‚°ì `-`\n\nì´ì œ ë‹¨í•­ì—°ì‚°ì `-`ë¥¼ ì¶”ê°€í•´ë³´ê² ìŠµë‹ˆë‹¤. ì´ ì—°ì‚°ìëŠ” ì´í•­ ì‚°ìˆ ì—°ì‚°ìë“¤ë³´ë‹¤ëŠ” ë” ê°•í•˜ê²Œ ê²°í•©í•˜ê³ , í•¨ìˆ˜ í•©ì„± ì—°ì‚°ì(`.`)ë³´ë‹¤ëŠ” ì•½í•˜ê²Œ ê²°í•©í•©ë‹ˆë‹¤.\n\në‹¨í•­ì—°ì‚°ìê°€ ì¶”ê°€ë˜ë©´ ìˆ˜ì •í•´ì•¼ í•˜ëŠ” ë¶€ë¶„ì´ ìˆìŠµë‹ˆë‹¤. ë£¨í”„ê°€ ì‹œì‘í•˜ëŠ” ì‹œì ì— ì²« ë²ˆì§¸ í† í°ì€ ì•„í†°ë§Œ ê°€ëŠ¥í•˜ë‹¤ê³  ê°€ì •í–ˆìœ¼ë‚˜, `-5`ì™€ ê°™ì´ ì—°ì‚°ìë¡œ ì‹œì‘í•˜ëŠ” í‘œí˜„ì‹ì´ ìƒê¸°ê¸° ë•Œë¬¸ì— ì´ ë˜í•œ ì²˜ë¦¬í•´ì£¼ì–´ì•¼ í•©ë‹ˆë‹¤.\n\n`-`ëŠ” ì „ìœ„ ë‹¨í•­ì—°ì‚°ìì´ë¯€ë¡œ ì˜¤ë¥¸ìª½ ê²°í•© ì„¸ê¸°ë§Œ ìˆìŠµë‹ˆë‹¤. ì´ë¥¼ íƒ€ì…ì„ í†µí•´ ë‚˜íƒ€ë‚´ë³´ê² ìŠµë‹ˆë‹¤.\n\n```rust\nfn prefix_binding_power(op: char) -> ((), u8) { // 1\n    match op {\n        '+' | '-' => ((), 5),\n        _ => panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn infix_binding_power(op: char) -> (u8, u8) {\n    match op {\n        '+' | '-' => (1, 2),\n        '*' | '/' => (3, 4),\n        '.' => (8, 7), // 2\n        _ => panic!(\"bad op: {:?}\"),\n    }\n}\n```\n\n1. ì „ìœ„ ì—°ì‚°ìì„ì„ ëª…í™•í•˜ê²Œ í•˜ê¸° ìœ„í•´ íƒ€ì…ì„ ì´ì™€ ê°™ì´ ì§€ì •í•˜ê² ìŠµë‹ˆë‹¤. ì´ ì—°ì‚°ìë“¤ì€ ì˜¤ë¥¸ìª½ì— ìˆëŠ” í‘œí˜„ì‹ë“¤ê³¼ë§Œ ê²°í•©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n2. ë‹¨í•­ì—°ì‚°ì `-`ê°€ `.`ë³´ë‹¤ëŠ” ì•½í•˜ê²Œ, ì´í•­ `-`, `+` ë³´ë‹¤ëŠ” ê°•í•˜ê²Œ ê²°í•©í•˜ëŠ” ì´ì „ì— ì—°ì‚°ìì„ì„ ì–¸ê¸‰í•˜ì˜€ìŠµë‹ˆë‹¤. ì´ë¥¼ ë°˜ì˜í•˜ê¸° ìœ„í•´ ìš°ì„ ìˆœìœ„ ê°’ë“¤ì˜ ì¡°ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œëŠ” í™€ìˆ˜ë¥¼ ê¸°ë³¸ ê²°í•©ì„¸ê¸°ë¡œ ë§ì¶°ë†“ì€ ë‹¤ìŒ, ê²°í•© ë°©í–¥ì„ ë°˜ì˜í•˜ê¸° ìœ„í•´ í•œìª½ì˜ ì„¸ê¸°ë¥¼ `1` ëŠ˜ë ¤ì£¼ëŠ” ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë‹¨í•­ `-`ëŠ” `5`, `6` ë‘˜ ë‹¤ ìƒê´€ì—†ì§€ë§Œ ì¼ê´€ì„±ì„ ìœ„í•´ í™€ìˆ˜ë¡œ ì§€ì •í•˜ì˜€ìŠµë‹ˆë‹¤.\n\n`expr_bp`ì— ì´ë¥¼ ë°˜ì˜í•´ë³´ê² ìŠµë‹ˆë‹¤.\n\n```rust\nfn expr_bp(lexer: &mut Lexer, min_bp: u8) -> S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        Token::Op(op) => {\n            let ((), r_bp) = prefix_binding_power(op);\n            todo!()\n        }\n        t => panic!(\"bad token: {:?}\", t),\n    };\n    ...\n}\n```\n\nì´ì œ ë°˜ë³µë¬¸ ì•ˆì— ìˆëŠ” `r_bp` ê´€ë ¨ ë¡œì§ë“¤ì„ ê°€ì ¸ì™€ `todo!()`ë¥¼ ì±„ì›Œë´…ì‹œë‹¤. ì¼ë¶€ ì½”ë“œëŠ” `l_bp`ì™€ ê´€ë ¨ìˆìœ¼ë‹ˆ ì œì™¸í•˜ê³  ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n```rust\nfn expr_bp(lexer: &mut Lexer, min_bp: u8) -> S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        Token::Op(op) => {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t => panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof => break,\n            Token::Op(op) => op,\n            t => panic!(\"bad token: {:?}\", t),\n        };\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp < min_bp {\n            break;\n        }\n\n        lexer.next();\n        let rhs = expr_bp(lexer, r_bp);\n\n        lhs = S::Cons(op, vec![lhs, rhs]);\n    }\n    lhs\n}\n\n#[test]\nfn tests() {\n    ...\n\n    let s = expr(\"--1 * 2\");\n    assert_eq!(s.to_string(), \"(* (- (- 1)) 2)\");\n\n    let s = expr(\"--f . g\");\n    assert_eq!(s.to_string(), \"(- (- (. f g)))\");\n}\n```\n\nì´ë¯¸ ì ì–´ë‘” ë¡œì§ì„ ê±°ì˜ ê¸°ê³„ì ìœ¼ë¡œ ê°€ì ¸ì™€ ì‚¬ìš©í•´ë´¤ëŠ”ë°, ê½¤ ì˜ ì‘ë™í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¨¼ì € ë‹¨í•­ì—°ì‚°ìë¥¼ íŒŒì‹±í•˜ê³  (ìˆëŠ” ê²½ìš°ì—), ê·¸ ì—°ì‚°ìë³´ë‹¤ ê°•í•˜ê²Œ ê²°í•©í•˜ëŠ” í”¼ì—°ì‚°ìë¥¼ ì¬ê·€í˜¸ì¶œì„ í†µí•´ íŒŒì‹±í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\n### í›„ìœ„ì—°ì‚°ìë„ ì²˜ë¦¬í•  ìˆ˜ ìˆì„ê¹Œ?\n\nì „ìœ„ì—°ì‚°ì ì²˜ë¦¬ ë¡œì§ì„ ë„£ì–´ë³´ì•˜ìŠµë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ `((), u8)` íƒ€ì…ì„ ì‚¬ìš©í–ˆëŠ”ë°, ê·¸ëŸ¼ `(u8, ())`ì„ ì‚¬ìš©í•˜ë©´ í›„ìœ„ì—°ì‚°ìë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆì„ê¹Œìš”? í•œë²ˆ í•´ë´…ì‹œë‹¤. íŒ©í† ë¦¬ì–¼(`!`) ì—°ì‚°ìê°€ ì í•©í•œ ê²ƒ ê°™ë„¤ìš”. `-`ë³´ë‹¤ëŠ” ë” ê°•í•˜ê²Œ ê²°í•©í•´ì•¼ í•  ê²ƒ ê°™ìŠµë‹ˆë‹¤. `-(92!)`ê°€ `(-92)!`ë³´ë‹¤ëŠ” ë” ìœ ìš©í•  í…Œë‹ˆê¹Œìš”. ì „ìœ„ì—°ì‚°ìë¥¼ ì¶”ê°€í•  ë•Œì™€ ë™ì¼í•œ ë°©ë²•ìœ¼ë¡œ ì§„í–‰í•´ë³´ê² ìŠµë‹ˆë‹¤.\n\n```rust\nlet (l_bp, ()) = postfix_binding_power(op);\nif l_bp < min_bp {\n    break;\n}\n\nlet (l_bp, r_bp) = infix_binding_power(op);\nif l_bp < min_bp {\n    break;\n}\n```\n\nê·¼ë° ë­”ê°€ ì´ìƒí•©ë‹ˆë‹¤. ì „ìœ„ í‘œí˜„ì‹ì„ íŒŒì‹±í•œ ì´í›„ì—ëŠ”, ì¤‘ìœ„ ì—°ì‚°ì **í˜¹ì€** í›„ìœ„ ì—°ì‚°ìë¥¼ ë§Œë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” ì´ë¯¸ ë“±ë¡ë˜ì–´ìˆì§€ ì•Šì€ ì—°ì‚°ìì— ëŒ€í•´ì„œëŠ” ê·¸ëƒ¥ `panic!`ì„ í•´ë²„ë¦½ë‹ˆë‹¤. í›„ìœ„ì—°ì‚°ìê°€ ì—†ëŠ” ê²½ìš°ì—ëŠ” ì¤‘ìœ„ì—°ì‚°ìë¥¼ ì°¾ì•„ë³´ë„ë¡ ì½”ë“œë¥¼ ë°”ê¿”ë´…ì‹œë‹¤. ê·¸ëŸ¬ê¸° ìœ„í•´ `postfix_binding_power`ì´ option íƒ€ì…ì„ ëŒë ¤ì£¼ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.\n\n```rust\nfn expr_bp(lexer: &mut Lexer, min_bp: u8) -> S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        Token::Op(op) => {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t => panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof => break,\n            Token::Op(op) => op,\n            t => panic!(\"bad token: {:?}\", t),\n        };\n\n        // CHANGE START\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp < min_bp {\n                break;\n            }\n\n            lexer.next();\n            lhs = S::Cons(op, vec![lhs]);\n\n            continue;\n        }\n        // CHANGE END\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp < min_bp {\n            break;\n        }\n\n        lexer.next();\n        let rhs = expr_bp(lexer, r_bp);\n\n        lhs = S::Cons(op, vec![lhs, rhs]);\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -> ((), u8) {\n    match op {\n        '+' | '-' => ((), 5),\n        _ => panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -> Option<(u8, ())> {\n    let res = match op {\n        '!' => (7, ()),\n        _ => return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -> (u8, u8) {\n    match op {\n        '+' | '-' => (1, 2),\n        '*' | '/' => (3, 4),\n        '.' => (10, 9),\n        _ => panic!(\"bad op: {:?}\"),\n    }\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"-9!\");\n    assert_eq!(s.to_string(), \"(- (! 9))\");\n\n    let s = expr(\"f . g !\");\n    assert_eq!(s.to_string(), \"(! (. f g))\");\n}\n```\n\nì‹ ê¸°í•˜ê²Œë„ ê¸°ì¡´ í…ŒìŠ¤íŠ¸ì™€ ì‹ ê·œ í…ŒìŠ¤íŠ¸ ëª¨ë‘ í†µê³¼í•©ë‹ˆë‹¤.\n\n### ê´„í˜¸ í‘œí˜„ì‹\n\nìƒˆë¡œìš´ í‘œí˜„ì‹ì„ ì²˜ë¦¬í•´ë´…ì‹œë‹¤. ë°”ë¡œ ê´„í˜¸ í‘œí˜„ì‹ì¸ë°ìš”, ìƒê°ë³´ë‹¤ ì–´ë µì§€ ì•ŠìŠµë‹ˆë‹¤. ê´„í˜¸ í‘œí˜„ì‹ì€ ê½¤ ê¸°ì´ˆì ì¸ í‘œí˜„ì‹ìœ¼ë¡œ ì•„í†°ê³¼ ë¹„ìŠ·í•œ ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n```rust\nlet mut lhs = match lexer.next() {\n    Token::Atom(it) => S::Atom(it),\n    Token::Op('(') => {\n        let lhs = expr_bp(lexer, 0);\n        assert_eq!(lexer.next(), Token::Op(')'));\n        lhs\n    }\n    Token::Op(op) => {\n        let ((), r_bp) = prefix_binding_power(op);\n        let rhs = expr_bp(lexer, r_bp);\n        S::Cons(op, vec![rhs])\n    }\n    t => panic!(\"bad token: {:?}\", t),\n};\n```\n\ní•˜ì§€ë§Œ ì´ í…ŒìŠ¤íŠ¸ëŠ” ì•„ì§ í†µê³¼í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n```rust\nlet s = expr(\"(((0)))\");\nassert_eq!(s.to_string(), \"0\");\n```\n\nì—ëŸ¬ëŠ” `loop` ë¸”ë¡ì—ì„œ ë°œìƒí•©ë‹ˆë‹¤. í˜„ì¬ ì½”ë“œì—ì„œ, ë°˜ë³µë¬¸ì—ì„œ ë¹ ì ¸ë‚˜ì˜¤ëŠ” ìœ ì¼í•œ ì¡°ê±´ì€ `Eof`ë¥¼ ë§Œë‚¬ì„ ë•Œì…ë‹ˆë‹¤. ê·¼ë° ì´ ì§€ì ì—ì„œ `)`ë¥¼ ë§Œë‚˜ë©´ì„œ, ì´ `)` \"ì—°ì‚°ì\"ê°€ ë°‘ì— ìˆëŠ” `infix_binding_power`ì— ë„˜ê²¨ì§€ë©° `panic!`ì„ í•˜ëŠ” ê²ƒì´ì§€ìš”. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ê°€ì¥ ì‰¬ìš´ ë°©ë²•ì€ `infix_binding_power`ë„ `postfix_binding_power`ì™€ ë§ˆì°¬ê°€ì§€ë¡œ ì‹ë³„í•˜ì§€ ëª»í•œ ì—°ì‚°ìì— ëŒ€í•´ì„œëŠ” optionì„ ëŒë ¤ì£¼ê²Œ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.\n\nì´ì œëŠ” í…ŒìŠ¤íŠ¸ê°€ ì˜ í†µê³¼í•˜ë„¤ìš”!\n\n### ë°°ì—´ ì ‘ê·¼ ì—°ì‚°ì `[]`\n\nì´ì œ ë°°ì—´ ì ‘ê·¼ ì—°ì‚°ìì¸ `a[i]`ë¥¼ êµ¬í˜„í•´ë´…ì‹œë‹¤. ì§€ê¸ˆê¹Œì§€ ë³¸ ì—°ì‚°ìë“¤ì€ ì „ìœ„, ì¤‘ìœ„, í›„ìœ„ì™€ ê°™ì´ ë¶„ë¥˜í•  ìˆ˜ê°€ ìˆì—ˆìŠµë‹ˆë‹¤. ì´ê±´ ë­˜ê¹Œìš”? ê·¸ëƒ¥ `a[]`ì™€ ê°™ì´ ìƒê²¼ì—ˆë‹¤ë©´ í›„ìœ„ì—°ì‚°ìì˜€ì„ ê²ƒì´ê³ , `[i]`ì˜€ë‹¤ë©´ ê´„í˜¸ í‘œí˜„ì‹ê³¼ ë™ì¼í•˜ê²Œ ë™ì‘í–ˆì„ ê²ƒì…ë‹ˆë‹¤. í•˜ì§€ë§Œ ê´„í˜¸ í‘œí˜„ì‹ê³¼ ë¹„ìŠ·í•œ ì ì´ ìˆë‹¤ë©´ ê´„í˜¸ ì•ˆì— ìˆëŠ” í‘œí˜„ì‹ì€ ìš°ì„ ìˆœìœ„ì— ì–½ë§¤ì´ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ë‹ˆë‹¤. í•œë²ˆ ì½”ë“œë¥¼ ë³´ê² ìŠµë‹ˆë‹¤.\n\n```rust\nfn expr_bp(lexer: &mut Lexer, min_bp: u8) -> S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        Token::Op('(') => {\n            let lhs = expr_bp(lexer, 0);\n            assert_eq!(lexer.next(), Token::Op(')'));\n            lhs\n        }\n        Token::Op(op) => {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t => panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof => break,\n            Token::Op(op) => op,\n            t => panic!(\"bad token: {:?}\", t),\n        };\n\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp < min_bp {\n                break;\n            }\n            lexer.next();\n\n\t\t\t// CHANGE START\n            lhs = if op == '[' {\n                let rhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(']'));\n                S::Cons(op, vec![lhs, rhs])\n            } else {\n                S::Cons(op, vec![lhs])\n            };\n\t\t\t// CHANGE END\n            continue;\n        }\n\n        if let Some((l_bp, r_bp)) = infix_binding_power(op) {\n            if l_bp < min_bp {\n                break;\n            }\n\n            lexer.next();\n            let rhs = expr_bp(lexer, r_bp);\n\n            lhs = S::Cons(op, vec![lhs, rhs]);\n            continue;\n        }\n\n        break;\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -> ((), u8) {\n    match op {\n        '+' | '-' => ((), 5),\n        _ => panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -> Option<(u8, ())> {\n    let res = match op {\n        '!' | '[' => (7, ()), // 1\n        _ => return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -> Option<(u8, u8)> {\n    let res = match op {\n        '+' | '-' => (1, 2),\n        '*' | '/' => (3, 4),\n        '.' => (10, 9),\n        _ => return None,\n    };\n    Some(res)\n}\n\n#[test]\nfn tests() {\n    ...\n    let s = expr(\"x[0][1]\");\n    assert_eq!(s.to_string(), \"([ ([ x 0) 1)\");\n}\n```\n\n1. `!`ê³¼ `[`ì— ë™ì¼í•œ ìš°ì„ ìˆœìœ„ë¥¼ ë¶€ì—¬í•œ ê²ƒì´ ë³´ì´ë‚˜ìš”? ì¼ë°˜ì ìœ¼ë¡œëŠ” ì´ ì•Œê³ ë¦¬ì¦˜ì˜ correctnessë¥¼ ìœ„í•´ì„œ ìš°ì„ ìˆœìœ„ê°€ ê²¹ì¹˜ì§€ ì•Šê²Œ í•˜ëŠ” ê²ƒì´ ê½¤ ì¤‘ìš”í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ìš°ë¦¬ê°€ ê²°í•© ì„¸ê¸°ë¥¼ ë¹„êµí•˜ëŠ” ê²½ìš°ì—ëŠ”, **ì˜¤ë¥¸ìª½ ê²°í•© ì„¸ê¸°**ì™€ **ì™¼ìª½ ê²°í•© ì„¸ê¸°**ë§Œ ë¹„êµí•˜ê¸° ë•Œë¬¸ì—, ë‘ í›„ìœ„ì—°ì‚°ìì˜ ê²°í•© ì„¸ê¸°ê°€ ê²¹ì³ë„ ë¬¸ì œê°€ ìƒê¸°ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n### ì‚¼í•­ì—°ì‚°ì `? :`\n\nìµœì¢… ë³´ìŠ¤ë¥¼ ë§Œë‚˜ë³´ê² ìŠµë‹ˆë‹¤. ë°”ë¡œ ì‚¼í•­ì—°ì‚°ìì…ë‹ˆë‹¤.\n\n```plaintext\nc ? e1 : e2\n```\n\nì´ê±´ ì–´ë–»ê²Œ ë¶„ë¥˜í•´ì•¼ í• ê¹Œìš”?? í•œë²ˆ ê¸°í˜¸ë§Œ ì‚´ì§ ë°”ê¿”ë³´ê² ìŠµë‹ˆë‹¤.\n\n```plaintext\nc [ e1 ] e2\n```\n\nê°ì´ ì¡íˆë‚˜ìš”? ì•ë¶€ë¶„ì—ì„œ `a[i]`ëŠ” í›„ìœ„ì—°ì‚°ì + ê´„í˜¸í‘œí˜„ì‹ì¸ ê²ƒì„ ë³´ì•˜ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‹ˆ ì–´ë–»ê²Œ ë³´ë©´ ì‚¼í•­ì—°ì‚°ìëŠ” `a[i]`ì˜ ë³€í˜•ëœ í˜•íƒœë¼ê³  ìƒê°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ì œ ê²°í•© ì„¸ê¸°ì™€ ë°©í–¥ì„ ìƒê°í•´ë³´ê² ìŠµë‹ˆë‹¤. ì´ëŸ° ê²½ìš°ì—ëŠ” ê²°í•© ë°©í–¥ì´ ì–´ë–»ê²Œ ë ê¹Œìš”?\n\n```plaintext\na ? b : c ? d : e\n```\n\në” ë‹¨ìˆœí•˜ê²Œ ë³´ê¸° ìœ„í•´ ì¢€ ìƒëµëœ í‘œí˜„ì„ ë³´ê² ìŠµë‹ˆë‹¤.\n\n```plaintext\na ?: c ?: e\n```\n\nìœ„ í‘œí˜„ì‹ì€ ì´ë ‡ê²Œ íŒŒì‹±í•˜ê±°ë‚˜:\n\n```plaintext\n(a ?: c) ?: e\n```\n\nì´ë ‡ê²Œ íŒŒì‹±í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.\n\n```plaintext\na ?: (c ?: e)\n```\n\në¬´ì—‡ì´ ë” ìœ ìš©í• ê¹Œìš”? ì´ë ‡ê²Œ ì—°ì†ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì—ëŠ”:\n\n```plaintext\na ? b :\nc ? d :\ne\n```\n\nì˜¤ë¥¸ìª½ìœ¼ë¡œ ê²°í•©í•˜ëŠ” ìª½ì´ ë” ìœ ìš©í•  ê²ƒ ê°™ë„¤ìš”. ê²°í•© ì„¸ê¸°ì˜ ê²½ìš°ì—ëŠ”, ê½¤ ë‚®ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. [Cì–¸ì–´ì—ì„œëŠ”](https://en.cppreference.com/w/c/language/operator_precedence) `=`ì™€ `,`ë§Œì´ ë” ë‚®ì€ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤.\n\nì•„ë˜ ì½”ë“œë¥¼ í†µí•´ ì €í¬ì˜ ì™„ì„±ëœ í”„ë« íŒŒì„œë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n```rust\nuse std::{fmt, io::BufRead};\n\nenum S {\n    Atom(char),\n    Cons(char, Vec<S>),\n}\n\nimpl fmt::Display for S {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            S::Atom(i) => write!(f, \"{}\", i),\n            S::Cons(head, rest) => {\n                write!(f, \"({}\", head)?;\n                for s in rest {\n                    write!(f, \" {}\", s)?\n                }\n                write!(f, \")\")\n            }\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Token {\n    Atom(char),\n    Op(char),\n    Eof,\n}\n\nstruct Lexer {\n    tokens: Vec<Token>,\n}\n\nimpl Lexer {\n    fn new(input: &str) -> Lexer {\n        let mut tokens = input\n            .chars()\n            .filter(|it| !it.is_ascii_whitespace())\n            .map(|c| match c {\n                '0'..='9'\n                | 'a'..='z' | 'A'..='Z' => Token::Atom(c),\n                _ => Token::Op(c),\n            })\n            .collect::<Vec<_>>();\n        tokens.reverse();\n        Lexer { tokens }\n    }\n\n    fn next(&mut self) -> Token {\n        self.tokens.pop().unwrap_or(Token::Eof)\n    }\n\n    fn peek(&mut self) -> Token {\n        self.tokens.last().copied().unwrap_or(Token::Eof)\n    }\n}\n\nfn expr(input: &str) -> S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(&mut lexer, 0)\n}\n\nfn expr_bp(lexer: &mut Lexer, min_bp: u8) -> S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) => S::Atom(it),\n        Token::Op('(') => {\n            let lhs = expr_bp(lexer, 0);\n            assert_eq!(lexer.next(), Token::Op(')'));\n            lhs\n        }\n        Token::Op(op) => {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t => panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof => break,\n            Token::Op(op) => op,\n            t => panic!(\"bad token: {:?}\", t),\n        };\n\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp < min_bp {\n                break;\n            }\n            lexer.next();\n\n            lhs = if op == '[' {\n                let rhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(']'));\n                S::Cons(op, vec![lhs, rhs])\n            } else {\n                S::Cons(op, vec![lhs])\n            };\n            continue;\n        }\n\n        if let Some((l_bp, r_bp)) = infix_binding_power(op) {\n            if l_bp < min_bp {\n                break;\n            }\n            lexer.next();\n\n            lhs = if op == '?' {\n                let mhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(':'));\n                let rhs = expr_bp(lexer, r_bp);\n                S::Cons(op, vec![lhs, mhs, rhs])\n            } else {\n                let rhs = expr_bp(lexer, r_bp);\n                S::Cons(op, vec![lhs, rhs])\n            };\n            continue;\n        }\n\n        break;\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -> ((), u8) {\n    match op {\n        '+' | '-' => ((), 9),\n        _ => panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -> Option<(u8, ())> {\n    let res = match op {\n        '!' => (11, ()),\n        '[' => (11, ()),\n        _ => return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -> Option<(u8, u8)> {\n    let res = match op {\n        '=' => (2, 1),\n        '?' => (4, 3),\n        '+' | '-' => (5, 6),\n        '*' | '/' => (7, 8),\n        '.' => (14, 13),\n        _ => return None,\n    };\n    Some(res)\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\");\n\n    let s = expr(\"a + b * c * d + e\");\n    assert_eq!(s.to_string(), \"(+ (+ a (* (* b c) d)) e)\");\n\n    let s = expr(\"f . g . h\");\n    assert_eq!(s.to_string(), \"(. f (. g h))\");\n\n    let s = expr(\" 1 + 2 + f . g . h * 3 * 4\");\n    assert_eq!(\n        s.to_string(),\n        \"(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))\",\n    );\n\n    let s = expr(\"--1 * 2\");\n    assert_eq!(s.to_string(), \"(* (- (- 1)) 2)\");\n\n    let s = expr(\"--f . g\");\n    assert_eq!(s.to_string(), \"(- (- (. f g)))\");\n\n    let s = expr(\"-9!\");\n    assert_eq!(s.to_string(), \"(- (! 9))\");\n\n    let s = expr(\"f . g !\");\n    assert_eq!(s.to_string(), \"(! (. f g))\");\n\n    let s = expr(\"(((0)))\");\n    assert_eq!(s.to_string(), \"0\");\n\n    let s = expr(\"x[0][1]\");\n    assert_eq!(s.to_string(), \"([ ([ x 0) 1)\");\n\n    let s = expr(\n        \"a ? b :\n         c ? d\n         : e\",\n    );\n    assert_eq!(s.to_string(), \"(? a b (? c d e))\");\n\n    let s = expr(\"a = 0 ? b : c = d\");\n    assert_eq!(s.to_string(), \"(= a (= (? 0 b c) d))\")\n}\n\nfn main() {\n    for line in std::io::stdin().lock().lines() {\n        let line = line.unwrap();\n        let s = expr(&line);\n        println!(\"{}\", s)\n    }\n}\n```\n\nì½”ë“œëŠ” [ì´ ë ˆí¬](https://github.com/matklad/minipratt)ì—ì„œë„ í™•ì¸í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. Eof.\n","title":"Simple but Powerful Pratt Parsing","tags":["parsing","ko"],"date":"2023-04-30"},{"id":"20230415-after-navy-software-developer","content":"\n2021ë…„ 9ì›” ì…ëŒ€í•˜ê¸° ì§ì „ì— ë¸”ë¡œê·¸ í•˜ë‚˜ëŠ” ê°–ê³  ì‹¶ë‹¤ëŠ” ìƒê°ì´ ë“¤ì–´ ë¶€ë´ë¶€ë´ ë¸”ë¡œê·¸ë¥¼ ë§Œë“¤ì—ˆë‹¤. ê·¸ë¦¬ê³  í•´êµ° ê°œë°œë³‘ì— ëŒ€í•œ ì •ë³´ê°€ ì¸í„°ë„·ì— ì›Œë‚™ ë¶€ì¡±í–ˆì–´ì„œ ì´ë¥¼ ì¡°ê¸ˆì´ë¼ë„ í•´ì†Œí•˜ê³  ì‹¶ì–´ ì§€ì› í›„ê¸°ë¥¼ ì‘ì„±í–ˆì—ˆë‹¤. ê·¸ ê¸°ì–µë“¤ì´ ì•„ì§ ìƒìƒí•œë°, ì§€ê¸ˆ ì „ì—­ì„ ì•ë‘ê³  ìˆëŠ” ë‚˜ë¥¼ ë³´ë‹ˆ êµ°ìƒí™œì´ ìƒê°ë³´ë‹¤ ë¹¨ë¦¬ ì§€ë‚˜ê°„ ê²ƒ ê°™ë‹¤. ì´ ê¸€ì—ëŠ” **ê°œë°œë³‘ìœ¼ë¡œì„œ** ë³µë¬´í•œ í›„ê¸°ë¥¼ ì ì–´ë³´ê² ë‹¤. ëˆ„êµ°ê°€ì—ê²Œ ì´ ê¸€ì´ ë„ì›€ì´ ëìœ¼ë©´ ì¢‹ê² ë‹¤.\n\n## ì‹¤ì œë¡œ ê°œë°œì„ í•˜ë‚˜ìš”?\n\në‚´ê°€ ê°€ì¥ ê±±ì •í–ˆë˜ ë¶€ë¶„ ì¤‘ í•˜ë‚˜ì´ë‹¤. ë§ì€ ì •ë³´ë¥¼ ì•Œì§€ ëª»í•œ ì±„ í›ˆë ¨ì†Œì— ì…ëŒ€í–ˆì—ˆëŠ”ë°, ê·¸ ê¸°ìˆ˜ì—ëŠ” ê°œë°œë³‘ì´ ë‚˜ í˜¼ìì˜€ë‹¤(21\\~22ë…„ ê¸°ì¤€ í‰ê·  2ê¸°ìˆ˜ë‹¹ 1\\~2ëª… ì…ëŒ€). ê·¸ë˜ì„œ í›ˆë ¨ì†Œ ë™ê¸°ë“¤ì€ ë¬¼ë¡ , í›ˆë ¨ì†Œì— ìˆëŠ” í›ˆë ¨ êµê´€ë“¤ë„ ê°œë°œë³‘ ì§ë³„ì— ëŒ€í•´ ëª¨ë¥¸ë‹¤. ë°–ì´ë‘ ë‹¨ì ˆëœ ì±„ë¡œ 6ì£¼ë¥¼ ìˆìœ¼ë ¤ë‹ˆ ìëŒ€ëŠ” ì–´ë”˜ì§€, ì§„ì§œ ê°œë°œì€ í•˜ëŠ”ì§€, ê·¸ëƒ¥ ë‹¤ë¥¸ ì „ì‚°ë³‘ë“¤ì´ë‘ ê°™ì´ ì»´í“¨í„° ì •ë¹„ë¥¼ í•˜ê²Œ ë˜ì§„ ì•Šì„ì§€ ê³ ë¯¼í•˜ë‹¤ ë³´ë©´ ë³„ê±¸ ë‹¤ ìƒìƒí•˜ê²Œ ëœë‹¤. ì˜†ì— ìˆëŠ” í›ˆë ¨ì†Œ ë™ê¸°ë“¤ì—ê²Œ, \"ì§„ì§œ ê°œë°œ í•˜ê² ì–´? ê·¸ëƒ¥ ì»´í“¨í„° ì¢€ ê³ ì¹˜ê² ì§€\"ë¼ëŠ” ë§ì„ ëª‡ë²ˆ ë“£ê³  ë‚˜ë©´ ê½¤ ë¶ˆì•ˆí•´ì§„ë‹¤. ê·¼ë° ì•Œê³ ë³´ë‹ˆ ìëŒ€ëŠ” í•œ ê³³ìœ¼ë¡œ ì •í•´ì ¸ ìˆê³ (ë©´ì ‘ë³¸ ê³³), ì£¼ ì—…ë¬´ëŠ” ì •ë§ ê°œë°œì´ ë§ì•˜ì—ˆë‹¤. ì˜¤íˆë ¤ ê°œë°œì„ ì‹¤ì»· í•  ìˆ˜ ìˆë‹¤. ê°œë°œ ê°€ëŠ¥í•œ ì¸ë ¥ì´ ë³‘ë°–ì— ì—†ê¸° ë•Œë¬¸ì´ë‹¤.\n\n## ê°œë°œ í™˜ê²½ì€ ì–´ë–¤ê°€ìš”?\n\nì‚¬ë¬´ì‹¤ì—ì„œëŠ” ì•±/ì›¹ì— ì˜¬ë¼ê°€ëŠ” ë‹¤ì–‘í•œ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•œë‹¤. ë•Œë¬¸ì— í”„ë¡œì íŠ¸ì˜ íŠ¹ì„±ì€ ì œê°ê°ì´ì§€ë§Œ, ê·¸ ì¤‘ ì¸íŠ¸ë¼ë„· í™˜ê²½ì— ëŒ€í•´ ì´ì•¼ê¸°í•´ë³´ê³  ì‹¶ë‹¤.\n\nêµ° ë¶€ëŒ€ëŠ” ë³´ì•ˆ ìœ ì§€ë¥¼ ìœ„í•´ ì¸íŠ¸ë¼ë„·ì„ ì‚¬ìš©í•œë‹¤. ì‰½ê²Œ ë§í•´ ì „êµ­ì˜ êµ° ë¶€ëŒ€ë“¤ì´ ì‚¬ìš©í•˜ëŠ” íì‡„ë§ì´ ìˆë‹¤ëŠ” ê±´ë°, ì´ëŠ” ì¸í„°ë„·ì´ë‘ ì—°ê²°ë˜ì–´ìˆì§€ ì•Šë‹¤. ê°œë°œ ë˜í•œ ì¸íŠ¸ë¼ë„· í™˜ê²½ì—ì„œ í•˜ëŠ”ë°, ì´ë¡œ ì¸í•´ ìƒê¸°ëŠ” ë¬¸ì œê°€ ëª‡ ê°€ì§€ ìˆë‹¤.\n\nìš°ì„  íŒ¨í‚¤ì§€ ë‹¤ìš´ë¡œë“œì— ì œì•½ì´ ìƒê¸´ë‹¤. ìš”ìƒˆ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—†ì´ ê°œë°œí•˜ëŠ” ê±´ ìƒìƒí•˜ê¸° í˜ë“¤ë‹¤. íŠ¹íˆ ì›¹, ì•± ê°œë°œì€ ì •ë§ ë§ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ê¸°ëŠ¥ì„ ê°€ì ¸ë‹¤ ì“°ëŠ”ë°, ì¸í„°ë„· ì ‘ì†ì´ ì•ˆëœë‹¤ëŠ” ê²ƒì€ `npm`ì´ë‚˜ `maven`ì˜ ì ‘ì†ì´ ì•ˆëœë‹¤ëŠ” ì´ì•¼ê¸°ë‹¤. ë”°ë¼ì„œ íŒ¨í‚¤ì§€ë¥¼ ì™¸ë¶€ì—ì„œ ë‹¤ìš´ë°›ì•„ ë³´ì•ˆì ˆì°¨ë¥¼ ê±°ì³ ì¸íŠ¸ë¼ë„·ìœ¼ë¡œ ê°€ì ¸ì˜¤ëŠ”ë°, ë³´ì•ˆì ˆì°¨ê°€ ì‚¬ì´ì— ìˆëŠ” ê²ƒì´ ê°œë°œìƒì‚°ì„± ì¸¡ë©´ì—ì„œ ê½¤ ë°©í•´ê°€ ëœë‹¤. ë¯¸ë¦¬ ì„¤ì¹˜í•´ì„œ ê°€ì ¸ì˜¨ë‹¤ëŠ” ê±´ ë¬´ì—‡ì„ ì“¸ì§€ í•œë²ˆì— ìƒê°í•´ì„œ ì „ë¶€ ë¯¸ë¦¬ ë°›ì•„ì˜¨ë‹¤ëŠ” ê²ƒì¸ë°, ë¬´ì—‡ì„ ì“¸ì§€ ë¯¸ë¦¬ ìƒê°í•œë‹¤ëŠ” ê²ƒì´ ì‰½ì§€ê°€ ì•Šë‹¤.\n\në‹¤ìŒìœ¼ë¡œëŠ” ì¬ì‚¬ìš© ë¬¸ì œê°€ ìˆë‹¤. ì¸í„°ë„·ì—ì„œ ì¸íŠ¸ë¼ë„·ìœ¼ë¡œ íŒ¨í‚¤ì§€ë¥¼ ë“¤ê³  ì™€ ì‚¬ìš©í•œë‹¤ê³  ì´ì•¼ê¸°ë¥¼ í–ˆëŠ”ë°, ìŠ¬í”„ê²Œë„ í˜ë“¤ê²Œ ê°€ì ¸ì˜¨ íŒ¨í‚¤ì§€ë¥¼ ë‹¤ë¥¸ í”„ë¡œì íŠ¸ì— ì¬ì‚¬ìš©í•˜ê¸°ê°€ ì‰½ì§€ë§ì€ ì•Šë‹¤. ì–´ë–¤ íŒ¨í‚¤ì§€ì˜ ì˜ì¡´ì„±ì„ ìˆ˜ë™ìœ¼ë¡œ í™•ì¸í•˜ê¸°ê°€ ë„ˆë¬´ ì–´ë µê³ , ì˜ì¡´ì„±ì˜ ë²„ì „ë„ ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆê¸° ë•Œë¬¸ì´ë‹¤.\n\níŒ¨í‚¤ì§€ë¿ë§Œì´ ì•„ë‹ˆë‹¤. ê°œë°œ íˆ´ë“¤ë„ ì·¨í–¥ê» ì“°ê¸°ê°€ ì–´ë µë‹¤. ì´ìœ ëŠ” ì•ê³¼ ë™ì¼í•œë°, ê·¸ë˜ì„œ ê¸°ì¡´ì— ì¸íŠ¸ë¼ë„·ì— ìˆëŠ” íˆ´ë“¤ì„ ì‚¬ìš©í•˜ëŠ” ë° ì–´ëŠì •ë„ ë§Œì¡±í•´ì•¼ í•œë‹¤. ì´ ë¶€ë¶„ì€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë„ ë§ˆì°¬ê°€ì§€ë‹¤. ë‚˜ëŠ” ë¦¬ëˆ…ìŠ¤ í™˜ê²½ì„ ì„ í˜¸í•´ì„œ WSLì„ ì“°ê³  ì‹¶ì—ˆëŠ”ë° ê·¸ëŸ¬ì§€ ëª»í•´ì„œ ì•„ì‰¬ì› ë‹¤.\n\n## ì„±ì¥í•  ìˆ˜ ìˆì—ˆë‚˜ìš”?\n\nê°™ì´ í•œ ì‚¬ëŒë“¤ ëª¨ë‘ê°€ ë™ì˜í• ì§€ëŠ” ëª¨ë¥´ê² ìœ¼ë‚˜, ê°œì¸ì ìœ¼ë¡œ ë§ì´ ë°°ìš¸ ìˆ˜ ìˆëŠ” ì§ë³„ì´ë¼ê³  ëŠë‚€ë‹¤. ìëŒ€ì— ì²˜ìŒ ê°”ì„ ë•ŒëŠ”, ë¬¼ë¡  ê·¸ë§Œí•œ ì´ìœ ëŠ” ìˆì—ˆì§€ë§Œ ê°œë°œì ì…ì¥ì—ì„œëŠ” ìƒëŒ€ì ìœ¼ë¡œ ì—´ì•…í•œ í™˜ê²½ì— ì‹¤ë§í–ˆë‹¤. í•˜ì§€ë§Œ ì˜¤íˆë ¤ í™˜ê²½ì— ì¡°ê¸ˆ ì œì•½ì´ ìˆìœ¼ë‹ˆ ê°™ì€ ë¬¸ì œì—¬ë„ ê³ ë¯¼ì„ ë” ë§ì´ í•˜ê³ , í™˜ê²½ì„ ê°œì„ í•˜ê¸° ìœ„í•´ ì§ì ‘ ë…¸ë ¥í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ì´ ìˆì–´ ê²½í—˜ì„ ìŒ“ì„ ìˆ˜ ìˆì—ˆë‹¤. ë‚˜ëŠ” ìë°”ì— ëŒ€í•´ ì›ë˜ ì•…ê°ì •ì´ ìˆì—ˆëŠ”ë° ê°€ì„œ ë°±ì—”ë“œ ê°œë°œì„ ìë°”ì™€ ìŠ¤í”„ë§ìœ¼ë¡œ í•´ì•¼ í–ˆì—ˆë‹¤. ë•ë¶„ì— ì²˜ìŒìœ¼ë¡œ ìŠ¤í”„ë§(ë¶€íŠ¸ X. ë ˆê±°ì‹œ O)ì„ ë°°ì›Œë³¼ ê¸°íšŒê°€ ìƒê²¼ê³ , ì‚¬ìš©í•´ë³´ë‹ˆ ê½¤ ì¢‹ì€ í”„ë ˆì„ì›Œí¬ë¼ëŠ” ê²ƒì„ ëŠê¼ˆë‹¤. ë˜í•œ ë¹„ë¡ ì–¸ì–´ë¡œì„œì˜ ë‹¨ì ì€ ì¡´ì¬í•˜ëŠ” ìë°”ì§€ë§Œ, ì–¸ì–´ë¥¼ ë‘˜ëŸ¬ì‹¼ ìƒíƒœê³„ê°€ ì •ë§ íƒ„íƒ„í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œê²Œ ë˜ì—ˆë‹¤. ì‚¬ì‹¤ ìë°”ëŠ” ì–¸ì–´ë¡œì„œë„ ì´ë¯¸ ê½¤ ë§ì´ ë°œì „í–ˆëŠ”ë°, ì•„ì§ ë§ì€ ì‚¬ìš©ìë“¤ì´ ìë°” 1.8 / 11ì— ë¨¸ë¬´ëŠë¼(í˜„ì¬ ìë°” 20ê¹Œì§€ ì¶œì‹œë¨) ê·¸ ê¸°ëŠ¥ë“¤ê³¼ í–¥ìƒëœ JVMì„ ì‚¬ìš©í•˜ì§€ ëª»í•˜ê³  ìˆë‹¤ëŠ” ê²ƒì€ ìŠ¬í”ˆ ì¼ì´ë‹¤.\n\në³‘ 1~2ëª…ì´ í•œ í”„ë¡œì íŠ¸ë¥¼ ì£¼ë„í•˜ê¸° ë•Œë¬¸ì— ì§ì ‘ í•´ê²°í•´ì•¼ í•˜ëŠ” ë¬¸ì œë“¤ë„ ë§ì•˜ë‹¤. ë³‘ìœ¼ë¡œ ì…ëŒ€í•˜ëŠ” ì‚¬ëŒì´ë©´ ë³´í†µ ë‚˜ì´ê°€ 20ëŒ€ ì´ˆì¤‘ë°˜ì¸ë°, ë‚˜ëŠ” ë°©í•™ ë•Œ ì¸í„´ ëª‡ ë²ˆ ë¹¼ê³¤ í•™êµë§Œ ë‹¤ë‹ˆë‹¤ ê°”ê³ , ì£¼ë³€ì— íšŒì‚¬ìƒí™œ ëª‡ ë…„ í•˜ê³  ì˜¨ ì‚¬ëŒë“¤ë„ ìˆì§€ë§Œ ë³‘ë“¤ ì‹¤ë ¥ì´ ë§ì´ í•´ë´ì•¼ ì£¼ë‹ˆì–´ ì •ë„ë‹¤. í•˜ì§€ë§Œ ê·¸ê³³ì—ì„  ëª¨ë“  ê°œë°œì„ í•´ì•¼ í•˜ë‹ˆ ì´ê³³ì €ê³³ì—ì„œ ë¬¸ì œë¥¼ ë§ì´ ë§Œë‚˜ê¸° ë§ˆë ¨ì´ì—ˆë‹¤. ê·¸ë˜ì„œ ë‚´ê°€ ë§Œë“  ì„œë¹„ìŠ¤ë¥¼ ì“°ëŠ” ì‚¬ìš©ìë“¤ì—ê²ŒëŠ” ì¡°ê¸ˆ ë¯¸ì•ˆí•˜ì§€ë§Œ ì˜¤íˆë ¤ ë‚˜ì—ê²ŒëŠ” ì§ì ‘ ê²½í—˜ì„ ìŒ“ì„ ìˆ˜ ìˆëŠ” ì‹œê°„ì´ê¸°ë„ í–ˆë‹¤.\n\nì—¬ê°€ì‹œê°„ë„ ì¶©ë¶„í–ˆë‹¤. ê·¼ë¬´ì‹œê°„ì— ê°œë°œì„ í•˜ì§€ ì•Šì•˜ì–´ë„ ì—¬ê°€ì‹œê°„ì„ ì˜ í™œìš©í•˜ë©´ ê°œë°œ ê³µë¶€ë¥¼ ì¶©ë¶„íˆ í•  ìˆ˜ ìˆëŠ” ì‹œê°„ì´ì—ˆë‹¤. ë‚˜ëŠ” ì—¬ê°€ì‹œê°„ì— í°í•˜ê³  í…Œë‹ˆìŠ¤ë¥¼ ë§ì´ í–ˆë‹¤.\n\në¬´ì—‡ë³´ë‹¤ í•¨ê»˜ ì§€ë‚´ëŠ” ì„ í›„ì„ ë³‘ì‚¬ë“¤ì´ ì •ë§ ì¢‹ì€ ì‚¬ëŒë“¤ì´ì—ˆë‹¤. ì–´ëŠì •ë„ ê°™ì€ ë¶„ì•¼ë¥¼ ê³µë¶€í•˜ëŠ” ì‚¬ëŒë“¤ë¼ë¦¬ ë‹¤ê°™ì´ ìˆìœ¼ë‹ˆ í‰ì†Œì— ê°œë°œ ì´ì•¼ê¸°ë„ í•  ìˆ˜ ìˆê³ , ì¢‹ì€ ê°œë°œ ì„œì ë“¤ë„ ì£¼ë³€ì—ì„œ ë§ì´ ì¶”ì²œí•´ì¤˜ì„œ ìœ ìµí•œ ê²½í—˜ì„ í•  ìˆ˜ ìˆì—ˆë‹¤.\n\n## ì´í‰\n\nì „ì²´ì ìœ¼ë¡œ ê½¤ ë§Œì¡±í•˜ëŠ” í¸ì´ë‹¤. í˜ë“  ì ì´ ìˆë‹¤ë©´ ë‹¹ì§ê·¼ë¬´ê°€ ê½¤ ìì£¼ ìˆì—ˆë‹¤ëŠ” ì ì´ì§€ë§Œ, ì¤€ë¹„ë¥¼ ì¢€ í•œë‹¤ë©´ ê·¸ë³´ë‹¤ ë§ì€ í¸ì˜ë¥¼ ìëŒ€ì—ì„œ ëˆ„ë¦´ ìˆ˜ ìˆëŠ” ì§ë³„ì´ë¼ê³  ìƒê°í•œë‹¤. ë˜ ì´ ê¸€ì—ì„œëŠ” ê°œë°œ ì´ì•¼ê¸°ë§Œ ì£¼ë¡œ í–ˆìœ¼ë‚˜ ë¶€ëŒ€ ìì²´ê°€ ì›Œë‚™ ì¢‹ì€ í¸ì´ê³ , ì£¼ë³€ ì‚¬ëŒë“¤ë„ ì¢‹ì•„ì„œ í”íˆ ì–˜ê¸°í•˜ëŠ” ì•…ì„± ì„ í›„ì„ì„ ë³¼ ì¼ì´ ê±°ì˜ ì—†ëŠ” ì ë„ í° ë©”ë¦¬íŠ¸ì´ë‹¤.\n","title":"í•´êµ° SW ê°œë°œë³‘ ë³µë¬´ í›„ê¸°","tags":["general","diary","military","ko"],"date":"2023-04-15"},{"id":"20230108-linkwaiter","content":"\në§í¬ í˜ì´ì§€ë¥¼ ê°œì—…í•˜ë©´ì„œ ì˜¤ëœë§Œì— ë¸”ë¡œê·¸ë¥¼ ì—…ë°ì´íŠ¸í–ˆë‹¤. ë¯¸ë””ì–´ ì¿¼ë¦¬ë¥¼ ì†ë³¸ë‹¤ê±°ë‚˜ í°íŠ¸ ì‚¬ì´ì¦ˆë¥¼ ë°˜ì‘í˜•ìœ¼ë¡œ ë°”ê¾¼ë‹¤ê±°ë‚˜ ì£¼ë¡œ ëª¨ë°”ì¼ì—ì„œ ë” ë³¼ë§Œí•˜ê²Œ í•˜ëŠ” ë³€í™”ë“¤ì´ì—ˆë‹¤.\n\në§í¬ í˜ì´ì§€ë¥¼ ê°œì—…í•œ ì´ìœ ëŠ” ì§€ê·¹íˆ ê°œì¸ì ì´ë‹¤. ë‚œ ìœ íŠœë¸Œë‚˜ ë ˆë”§ì—ì„œ ê°œë°œ ê´€ë ¨ ì˜ìƒì´ë‚˜ ê²Œì‹œë¬¼ì´ ìì£¼ ì¶”ì²œë˜ëŠ” í¸ì´ë‹¤. í•´ë‹¹ ìë£Œë“¤ì„ í†µí•´ ì¡°ê¸ˆì”© ê´€ë ¨ ë¶„ì•¼ ì§€ì‹ë“¤ì„ ìŒ“ëŠ” í¸ì¸ë°, ë¬¸ì œê°€ í•˜ë‚˜ ìˆë‹¤. ì¢‹ì€ ê²Œì‹œë¬¼ì´ë‚˜ ì˜ìƒë“¤ì€ ë³´í†µ ê¸¸ì´ì™€ ê¹Šì´ê°€ ê½¤ ëœë‹¤ëŠ” ì ì´ë‹¤. ê·¸ë˜ì„œ íœ´ëŒ€í°ì—ì„œ ì–´ë–¤ ì¢‹ì€ ë§í¬ë¥¼ ì ‘í•˜ê²Œ ë˜ì—ˆì„ ë•Œ ê·¸ê±¸ í•œ ë²ˆ ì•‰ì•„ì„œ ëê¹Œì§€ ì½ì„ ìˆ˜ê°€ ì—†ë‹¤. ë³´í†µ ì§‘ì¤‘í•  ìˆ˜ ìˆëŠ” í™˜ê²½ë„ ì•„ë‹ˆê³ , ê²°ì‹¬í•˜ê³  ì½ì–´ì•¼ ì´í•´í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ì€ ìë£Œë“¤ë„ ê½¤ ë§ë‹¤. íŠ¹íˆë‚˜ íœ´ëŒ€í°ìœ¼ë¡œëŠ” ë‹¤ë¥¸ ë”´ì§“ì„ í•˜ê¸° ê½¤ ì‰¬ì›Œì„œ ì½ë‹¤ê°€ íƒ­ì„ ë‹«ê³  ìŠì–´ë²„ë¦¬ëŠ” ì¼ë„ ìì£¼ ìˆë‹¤. ì´ëŸ¬í•œ ë¬¸ì œì ìœ¼ë¡œ ì¸í•´ ë‚´ ê´€ì‹¬ì‚¬ëŠ” ê³„ì† ë°”ë€ŒëŠ” ë°ì— ë°˜í•´ ì¡°ê¸ˆì´ë¼ë„ ì•Œì•„ë³´ê³  ë„˜ì–´ê°€ëŠ” ê²½ìš°ê°€ ë§ì´ ì—†ë‹¤ëŠ” ê²ƒì„ ì˜¤ëœ ì‹œê°„ì´ ì§€ë‚œ ë’¤ì—ì•¼ ì•Œì•˜ë‹¤.\n\nê·¸ë˜ì„œ í¥ë¯¸ë¡œìš´ ë§í¬ë“¤ì„ í•œ ê³³ì— ëª¨ì•„ë‘˜ í•„ìš”ì„±ì„ ëŠê¼ˆê³ , ëŒì•„ë³´ë‹ˆ ê·¸ë ‡ê²Œ í•˜ëŠ” ì‚¬ëŒë“¤ì„ ê½¤ ë§ì´ ë³¸ ì ì´ ìˆì—ˆë‹¤ëŠ” ê²ƒì´ ê¸°ì–µë‚¬ë‹¤. ë§í¬ í˜ì´ì§€ë¥¼ ë¸”ë¡œê·¸ì— ì¶”ê°€í•˜ê¸°ë¡œ í•˜ì˜€ê³  ë°”ë¡œ í˜ì´ì§€ë¥¼ ë§Œë“¤ì—ˆë‹¤. ë§í¬ë“¤ì€ [ì´ ì„¹ì…˜](https://pacokwon.org/links)ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\nì´ ë§í¬ë“¤ì„ ì–´ë–»ê²Œ ê´€ë¦¬í• ì§€ ë˜í•œ ë¬¸ì œì˜€ë‹¤. í¥ë¯¸ë¡œìš´ ë§í¬ë¥¼ ë§ˆì£¼ì¹  ë•Œ ë¹ ë¥´ê²Œ ìŒ“ì•„ë‘˜ ìˆ˜ ìˆëŠ” êµ¬ì¡°ì—¬ì•¼ í•˜ê³ , ë¸”ë¡œê·¸ì—ë„ ê·¸ ë³€ê²½ì‚¬í•­ì„ ë°˜ì˜í•  ìˆ˜ ìˆì–´ì•¼í•œë‹¤. ê·¼ë° ì´ ë¸”ë¡œê·¸ëŠ” ì •ì ìœ¼ë¡œ ë§Œë“¤ì–´ì ¸ ìˆê³ , ë§í¬ë¥¼ ì¶”ê°€í•˜ê³  ì‹¶ë‹¤ê³  ì½”ë“œë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ëŠ”ê±´ ë„ˆë¬´ ì ‘ê·¼ì„±ì´ ë–¨ì–´ì§€ëŠ” ë°©ë²•ì´ì—ˆë‹¤. ì„œë²„ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ í•˜ë‚˜ í•„ìš”í•˜ë‹¤ëŠ” ê²ƒì´ ê±°ì˜ ë‹¹ì—°í•´ì ¸ì„œ ê°„ë‹¨í•œ í”„ë¡œì íŠ¸ë¥¼ í•˜ë‚˜ ë§Œë“¤ê¸°ë¡œí–ˆë‹¤. ë‹¹ì‹œì—ëŠ” ë‚´ê°€ [Elixir](https://elixir-lang.org)ë¼ëŠ” ì–¸ì–´ì— ê´€ì‹¬ì´ ë†’ì•˜ì„ ë•Œë¼ Elixirë¥¼ ë°°ì›Œë³´ëŠ” ê¹€ì— ë§í¬ë¥¼ ì‰½ê²Œ ë“±ë¡í•  ìˆ˜ ìˆëŠ” ì›¹ ê¸°ë°˜ í˜ì´ì§€ë¥¼ ì‘ì„±í–ˆë‹¤. Elixirì—ëŠ” [Phoenix Framework](https://www.phoenixframework.org/)ë¼ëŠ” í‰ê°€ê°€ ì¢‹ì€ ì„œë²„ í”„ë ˆì„ì›Œí¬ê°€ ìˆëŠ”ë°, ë„ˆë¬´ ê¸°ëŠ¥ì´ ë§ì€ ê²ƒ ê°™ì•„ì„œ Phoenixê°€ ê¸°ë°˜ì„ ë‘ê³  ìˆê¸°ë„ í•œ [Plug](https://github.com/elixir-plug/plug)ë¡œ ë°±ì—”ë“œë¥¼ ì‘ì„±í–ˆë‹¤. ì¨ë³´ë‹ˆ PlugëŠ” ì •ë§ barebonesì—¬ì„œ ì‹¤ì œ í”„ë¡œì íŠ¸ì—ëŠ” ì“°ê¸° ì–´ë ¤ìš¸ ê²ƒ ê°™ì•˜ì§€ë§Œ ì´ ë§í¬ ê´€ë¦¬ í˜ì´ì§€ë¥¼ ë§Œë“œëŠ” ë°ì—ëŠ” ì¢‹ì€ ê²½í—˜ì´ì—ˆê³ , íŠ¹íˆ [ì´ ë°œí‘œ](https://www.youtube.com/watch?v=Z0Z4wu4CPgQ&t=1364s)ê°€ ì •ë§ ìœ ìµí–ˆë‹¤.\n\nê²°ê³¼ì ìœ¼ë¡œ ë§í¬ ê´€ë¦¬ í˜ì´ì§€ë¥¼ ì´ìš©í•´ ì›í•  ë•Œ ë¸”ë¡œê·¸ì˜ ë°ì´í„°ë¥¼ ìˆ˜ì •í•´ì„œ ì§ì ‘ Githubì— pushë¥¼ í•˜ì—¬ ìë™ ì—…ë°ì´íŠ¸ë˜ë„ë¡ ë§Œë“¤ì—ˆê³ , ì•„ì§ê¹Œì§€ëŠ” ë§Œì¡±ìŠ¤ëŸ½ê²Œ ë™ì‘í•˜ê³  ìˆë‹¤. ê´€ë¦¬ í˜ì´ì§€ êµ¬í˜„ì²´ëŠ” [ì´ê³³](https://github.com/pacokwon/linkwaiter)ì— ìˆë‹¤. ì´ë¥¼ ì ê·¹ í™œìš©í•˜ì—¬ í¥ë¯¸ë¡œìš´ ê²ƒì´ ë§ì„ ë•ŒëŠ” í˜ì´ì§€ì— ì˜ ìŒ“ì•„ë‘ê³ , í¥ë¯¸ë¡œìš´ ê²ƒì´ ë–¨ì–´ì§ˆ ë•ŒëŠ” í˜ì´ì§€ì—ì„œ ì˜ ë½‘ì•„ ê³µë¶€í•´ì•¼ê² ë‹¤.\n","title":"ë§í¬ í˜ì´ì§€ ê°œì—…","tags":["blog","links"],"date":"2023-01-08"},{"id":"20210920-devenv-neovim","content":"\nì´ ê¸€ì—ëŠ” ë‚´ê°€ ì£¼ë¡œ ì‚¬ìš©í•˜ëŠ” neovim ì—ë””í„° í™˜ê²½ì„¤ì •, ê·¸ ì¤‘ í”ŒëŸ¬ê·¸ì¸ì— ëŒ€í•´ ì ì–´ë³´ë ¤ í•œë‹¤ (í•œë§ˆë””ë¡œ ë³„ ì“¸ë°ì—†ìŒ).\n\nneovimì´ `0.5.0` ì—…ë°ì´íŠ¸ ì´í›„ë¡œ luaì˜ first class supportë¥¼ ì¶”ê°€í•˜ì˜€ê³ , ì ì  ì“°ê¸° í¸í•˜ê²Œ ê°œë°œì´ ì§„í–‰ë˜ê³  ìˆëŠ” ìƒíƒœì´ë‹¤. ë‚˜ëŠ” vimscriptì™€ lua ëª¨ë‘ ì•„ì£¼ ì˜ ì•Œì§€ëŠ” ì•Šì§€ë§Œ ê·¸ëƒ¥ ê¶ê¸ˆí•´ì„œ í™˜ê²½ì„¤ì • ì¼ë¶€ëŠ” luaë¡œ ë°”ê¿”ë‘” ìƒíƒœì´ë‹¤. ë¬¼ë¡  ì´ë ‡ê²Œ í•˜ê³  ë‚˜ë‹ˆ ê·¸ëƒ¥ vim ì“¸ ë•ŒëŠ” í˜¸í™˜ì´ ì•ˆë˜ëŠ”ê²Œ ì¢€ ë¶ˆí¸í•´ì„œ vim ìš© ì„¤ì •ì€ ë”°ë¡œ ìœ ì§€ë¥¼ í•´ì•¼ í•˜ë‚˜ ì‹¶ë‹¤...ì•”íŠ¼ ê·¸ë˜ì„œ ë‚´ í˜„ì¬ neovim ì„¤ì •ì€ ì¼ë¶€ê°€ luaë¡œ ì í˜€ìˆì„ ë¿ë§Œ ì•„ë‹ˆë¼ ì•„ì£¼ ë§ì€ lua pluginì„ ì‚¬ìš©í•˜ê³  ìˆë‹¤.\n\në‚´ í™˜ê²½ì„¤ì •ì€ [ì—¬ê¸°](https://github.com/pacokwon/nvim-config)ì—ì„œ ê´€ë¦¬í•˜ê³  ìˆë‹¤. í˜„ì¬ ì„¤ì • ëª¨ìŠµì€ ì´ë ‡ë‹¤.\n\n```plaintext\n.\nâ”œâ”€â”€ init.vim            # config root file\nâ””â”€â”€ lua                 # configs written in lua\n   â”œâ”€â”€ colors.lua       # theme\n   â”œâ”€â”€ init.lua         # root file written in lua\n   â”œâ”€â”€ mappings.lua     # keymappings\n   â”œâ”€â”€ opts.lua         # editor options\n   â””â”€â”€ plugins          # plugin configuration\n```\n\n## Plugin Manager\n\në‚˜ëŠ” í•œë™ì•ˆ `vim-plug` ë¥¼ ì‚¬ìš©í•˜ë‹¤ê°€ `packer.nvim` ìœ¼ë¡œ í”ŒëŸ¬ê·¸ì¸ ë§¤ë‹ˆì €ë¥¼ ê°ˆì•„íƒ„ ìƒíƒœë‹¤. luaë¡œ ì‘ì„±ë¼ìˆë‹¤. ìœ ì €ë„ ë§ê³  êµ‰ì¥íˆ ë¹ ë¥´ë‹¤ê³  ë˜ì–´ìˆê¸¸ë˜ í•œ ë²ˆ ê°ˆì•„íƒ€ë´¤ëŠ”ë° ì‹¤ì œë¡œ ë¹ ë¥¸ ê²ƒ ê°™ê¸°ë„ í•˜ê³  ë³„ ë¬¸ì œì—†ì´ ì‘ë™í•˜ëŠ” ê²ƒ ê°™ì•„ì„œ ê·¸ëƒ¥ ê³„ì† ì‚¬ìš©í•˜ê³  ìˆëŠ” ì¤‘ì´ë‹¤.\n\n## Plugins\n\në‚´ê°€ ì£¼ë¡œ ì‚¬ìš©í•˜ëŠ” í”ŒëŸ¬ê·¸ì¸ ëª©ë¡ì´ë‹¤. ì‹¤ì œ ì‚¬ìš©í•˜ëŠ”ê±´ ë‚˜ì—´í•œ ê²ƒì˜ 1.5 ~ 2ë°° ì •ë„ ë˜ì§€ ì•Šì„ê¹Œ ì‹¶ë‹¤.\n\n### [nvim-miniyank](https://github.com/bfredl/nvim-miniyank)\n\nclipboardë¥¼ system clipboardë¡œ ì—°ê²°í•´ë‘” ìƒíƒœì¼ ë•Œ neovimì—ì„œ Visual Block ë¶™ì—¬ë„£ê¸°ê°€ ì˜ ì‘ë™í•˜ì§€ ì•ŠëŠ” ë²„ê·¸ê°€ ìˆë‹¤. ì´ìœ ê°€ ë­”ì§€ëŠ” ê¹Œë¨¹ì—ˆì—ˆëŠ”ë° í”ŒëŸ¬ê·¸ì¸ì˜ í˜•íƒœë¡œ ì†”ë£¨ì…˜ì´ ì¡´ì¬í•´ì„œ ì‚¬ìš©í•˜ê³  ìˆë‹¤.\n\n### [galaxyline.nvim](https://github.com/glepnir/galaxyline.nvim)\n\nì•„ì£¼ ë¯¸ë‹ˆë©€í•˜ê³  ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ì‰¬ìš´ statuslineì´ë‹¤. ëª¨ë“  ê±¸ ì§ì ‘ ì„¤ì •í•´ì¤˜ì•¼ í•œë‹¤ëŠ” ì¥ë²½ì´ ìˆì§€ë§Œ í•œë²ˆ ì„¤ì •í•´ë†“ìœ¼ë©´ ë¬¸ì œì—†ë‹¤. ê·¸ë˜ì„œ ì•„ì£¼ ì‹¬í”Œí•œ statuslineì„ ì“°ê³  ìˆë‹¤. luaë¡œ ë˜ì–´ìˆë‹¤.\n\n### [lspsaga.nvim](https://github.com/glepnir/lspsaga.nvim)\n\nì•„ì£¼ í•„ìˆ˜ì ì¸ í”ŒëŸ¬ê·¸ì¸ì€ ì•„ë‹ˆë‹¤. ë‚˜ëŠ” LSP diagnosticsë¥¼ ì¡°ê¸ˆ ë” ê¾¸ë©°ì§„ floating windowì—ì„œ ë³´ê³  ì‹¶ì–´ì„œ ì„¤ì¹˜í•´ ë‘ì—ˆë‹¤. LSP hover docsì˜ ê²½ìš° ìš” í”ŒëŸ¬ê·¸ì¸ì—ì„œ ì œê³µí•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê³  ìˆì—ˆëŠ”ë° lspconfig í”ŒëŸ¬ê·¸ì¸ì—ì„œ ê±°ì˜ ê°™ì€ ê¸°ëŠ¥ì„ ì œê³µí•˜ê³  ìˆì–´ì„œ ê°ˆì•„íƒ”ì—ˆë‹¤. diagnostic ìª½ë„ ê°™ì€ ê¸°ëŠ¥ì„ lspconfigì—ì„œ ì œê³µí•˜ê³  ìˆìœ¼ë©´ ê·¸ëƒ¥ ì•ˆ ì¨ë„ ë¬´ë°©í•  ê²ƒ ê°™ë‹¤.\n\n### [nvim-compe](https://github.com/hrsh7th/nvim-compe)\n\nLSP autocompletionì„ completion listë¡œ ë³´ì—¬ì£¼ëŠ” í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. ì´ë¯¸ LSPê°€ ìˆì–´ë„ ì´ëŸ¬í•œ í”ŒëŸ¬ê·¸ì¸ì´ ìˆì–´ì•¼ LSP ìë™ì™„ì„±ì„ í¸í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.\n\nì•„ë§ˆ ì§€ê¸ˆ ê¸€ ì“°ëŠ” ì‹œì ì—ì„œëŠ” deprecatedëœ ê²ƒìœ¼ë¡œ ì•„ëŠ”ë° ì•„ë¬´ ë¬¸ì œ ì—†ì–´ì„œ ê·¸ëƒ¥ ì“°ê³  ìˆë‹¤ã…‹ã…‹ë“£ê¸°ë¡œëŠ” ê°™ì€ ê°œë°œìì˜ `nvim-cmp` ë¼ëŠ” í”ŒëŸ¬ê·¸ì¸ì´ ê±°ì˜ ê°™ì€ ì—­í• ì„ í•˜ëŠ”ë° scalabilityë¥¼ ì—¼ë‘ì— ë‘ê³  ë‹¤ì‹œ ì‘ì„±í•œ ê²ƒìœ¼ë¡œ ì•Œê³  ìˆë‹¤.\n\nì²˜ìŒì— LSP ì§€ì›ì´ ë‚˜ì™”ì„ ë•ŒëŠ” `nvim-completion` ì¸ê°€? ë¼ëŠ” í”ŒëŸ¬ê·¸ì¸ì´ ê±°ì˜ ìœ ì¼í–ˆëŠ”ë° ì´ê²Œ í›¨ì”¬ ë‚˜ì•„ì„œ ë‚˜ í¬í•¨í•´ì„œ ì‚¬ëŒë“¤ì´ ìš”ê±¸ë¡œ ê°ˆì•„íƒ”ì—ˆë‹¤.\n\n### [fzf.vim](https://github.com/junegunn/fzf.vim)\n\n`fzf` ë¼ëŠ” fuzzy finderë¥¼ vimì—ì„œ ì‰½ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•œ wrapperì´ë‹¤. ë†“ì¹  ìˆ˜ ì—†ëŠ” í”ŒëŸ¬ê·¸ì¸ë“¤ ì¤‘ í•˜ë‚˜ë‹¤. ë§¤ìš° ë¹ ë¥´ë‹¤ëŠ” ê²ƒì´ ì¥ì ì´ê³  Silver Searcher, ripgrep, fd ë“± ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” ì»¤ë§¨ë“œ ë˜í•œ ë³€ê²½ ê°€ëŠ¥í•´ì„œ gitignoreë¥¼ respectí•˜ê²Œ í•˜ëŠ” ë“±ì˜ ê¸°ëŠ¥ ë˜í•œ ê°€ëŠ¥í•˜ë‹¤.\n\n### [gitsigns.nvim](https://github.com/lewis6991/gitsigns.nvim)\n\në¼ì¸ë§ˆë‹¤ ê¹ƒ ìƒíƒœë¥¼ ë³´ì—¬ì£¼ëŠ” í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. íŠ¹ì • ì¤„ë“¤ì´ë‚˜ ë¸”ë¡ì„ stage, unstage, resetí•˜ëŠ” í•¨ìˆ˜ë“¤ì„ ì œê³µí•œë‹¤. vscodeì˜ gitlensì—ì„œ ì œê³µí•˜ëŠ” ë¼ì¸ë³„ blame ì •ë³´ ë³´ì—¬ì£¼ê¸°ë‚˜, ê¹ƒ ìƒíƒœê°€ ë°”ë€ ì¤„ì— ëŒ€í•˜ì—¬ floating windowì—ì„œ diffë¥¼ ë³´ì—¬ì£¼ëŠ” ê¸°ëŠ¥ ë˜í•œ ë§¤ìš° ìœ ìš©í•˜ë‹¤. luaë¡œ ì‘ì„±ë˜ì–´ ìˆìœ¼ë©° ì´ì „ì—ëŠ” gitgutterë¼ëŠ” vim í”ŒëŸ¬ê·¸ì¸ì„ ì¼ì—ˆë‹¤.\n\n### [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)\n\nLSP ì„¤ì •ì„ ìœ„í•œ í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. LSP Client ê¸°ëŠ¥ ìì²´ëŠ” neovimì— ë‚´ì¥ë˜ì–´ ìˆì§€ë§Œ, ì„¤ì •ì„ ê°„í¸í•˜ê²Œ í•´ì£¼ëŠ” ìš©ë„ë¡œ ì¡´ì¬í•˜ëŠ” í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. LSPê°€ ì—†ìœ¼ë©´ ì•ˆë˜ëŠ” ê²ƒì€ ì•„ë‹ˆì§€ë§Œ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ ì‚¶ì˜ ì§ˆì´ ë§ì´ ì˜¬ë¼ê°€ê¸° ë•Œë¬¸ì— ë‚˜ëŠ” ë˜ë„ë¡ì´ë©´ ì“°ë ¤ê³  í•œë‹¤. ê·¼ë° ì„¤ì •ì´ ì¢€ ì–´ë ¤ìš´ ê²½ìš°ë„ ìˆê¸°ëŠ” í•˜ë‹¤.\n\n### [nvim-treesitter](https://github.com/nvim-treesitter/nvim-treesitter)\n\nTreesitter ì„¤ì •ì„ ìœ„í•œ í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. ì„¤ì •ì—ì„œ ì–´ë–¤ ì–¸ì–´ë“¤ì— ëŒ€í•˜ì—¬ treesitterë¥¼ ì‚¬ìš©í• ì§€ ì„ íƒí•  ìˆ˜ ìˆê³ , ê·¸ì— ë”°ë¥¸ treesitter syntax highlightingì„ ì œê³µí•œë‹¤. í›¨ì”¬ ì¼ê´€ì ì¸ highlightingì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì´ í”ŒëŸ¬ê·¸ì¸ì´ ìˆìœ¼ë©´ ì–¸ì–´ë³„ë¡œ ì¶”ê°€ì ì¸ highlight groupì„ ë‹´ê³  ìˆëŠ” í”ŒëŸ¬ê·¸ì¸ì„ ì„¤ì¹˜í•´ì„œ ì‚¬ìš©í•  í•„ìš”ê°€ ì—†ì–´ì§„ë‹¤.\n\n### [pears.nvim](https://github.com/steelsojka/pears.nvim)\n\nautopairs í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. luaë¡œ ì‘ì„±ë˜ì–´ ìˆìœ¼ë©° ë‚´ê°€ í•œì°½ luaë¡œ ì‘ì„±ëœ í”ŒëŸ¬ê·¸ì¸ë“¤ì„ ì‹œë„í•˜ë˜ ì™€ì¤‘ ê°ˆì•„íƒ”ì—ˆë‹¤. autopairsë¼ëŠ” ê²ƒì€ ì˜ˆë¥¼ ë“¤ì–´ `(` ë¥¼ ì…ë ¥í•˜ë©´ ê·¸ ì˜†ì— `)` ê°€ ìë™ìœ¼ë¡œ ì…ë ¥ëœë‹¤ê±°ë‚˜, `)` ë°”ë¡œ ì™¼ìª½ì—ì„œ `)` ë¥¼ ëˆ„ë¥´ë©´ í•´ë‹¹ ë¬¸ìë¥¼ í•œ ë²ˆ ë” ì ëŠ” ê²Œ ì•„ë‹ˆë¼ ì•Œì•„ì„œ ê±´ë„ˆë›°ëŠ” ê¸°ëŠ¥ì„ ì´ì•¼ê¸°í•œë‹¤. ê·¼ë° ì´ í”ŒëŸ¬ê·¸ì¸ì˜ ê²½ìš° ê°œë°œì´ í™œë°œí•˜ì§€ëŠ” ì•Šì•„ì„œ ì—„ì²­ ì¶”ì²œí•˜ì§€ëŠ” ì•ŠëŠ”ë‹¤. ì˜¤íˆë ¤ ê¸°ì¡´ì— ì‚¬ìš©í•˜ë˜ jiangmiaoì˜ auto-pairsê°€ ê¸°ëŠ¥ë„ ì¡°ê¸ˆ ë” ë§ê³  ì•ˆì •ì ì¸ ê²ƒ ê°™ë‹¤. luaë¡œ ì‘ì„±ëœ ë‹¤ë¥¸ autopairs í”ŒëŸ¬ê·¸ì¸ë„ ë§ë‹¤.\n\n### [vim-commentary](https://github.com/tpope/vim-commentary)\n\nì£¼ì„ ì²˜ë¦¬ìš© í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. ë†“ì¹  ìˆ˜ ì—†ëŠ” í”ŒëŸ¬ê·¸ì¸ë“¤ ì¤‘ í•˜ë‚˜ë‹¤. ì„¤ì¹˜ë¥¼ í•˜ë©´ `gc` ë¼ëŠ” verbê°€ ìƒê¸´ë‹¤. verbë¼ëŠ” ê²ƒì€ `d`, `c`, `v` ê°™ì€ ë™ì‘ì„ í•˜ëŠ” í‚¤ë°”ì¸ë”©ì„ ì´ì•¼ê¸°í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `gcj` ë¥¼ ì…ë ¥í•˜ë©´ í˜„ì¬ ì¤„ê³¼ ì•„ë˜ ì¤„ì´ ì£¼ì„ ì²˜ë¦¬ëœë‹¤. ë§¤ìš° í¸ë¦¬í•˜ê³  ì‚¬ìš©í•˜ê¸°ë„ ìì—°ìŠ¤ëŸ¬ì›Œì„œ ê·¸ëƒ¥ vim ì½”ì–´ì— í†µí•©ë¼ë„ ì•„ë¬´ ë¬¸ì œê°€ ì—†ì„ ê²ƒ ê°™ë‹¤.\n\n### [vim-surround](https://github.com/tpope/vim-surround)\n\n`(`, `{`, `[`, `'`, `\"` ì²˜ëŸ¼ ì§ê¿ì´ ìˆëŠ” ë¬¸ìë“¤ì„ ìœ„í•œ í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. ë†“ì¹  ìˆ˜ ì—†ëŠ” í”ŒëŸ¬ê·¸ì¸ë“¤ ì¤‘ í•˜ë‚˜ë‹¤. ì„¤ì¹˜í•˜ë©´ `ys`, `ds`, `cs` ë“±ì˜ verbê°€ ìƒê¸´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `ysiw(` ë¥¼ í•˜ë©´ í˜„ì¬ ì»¤ì„œê°€ ìˆëŠ” ë‹¨ì–´ë¥¼ `()` ë¡œ ê°ì‹¼ë‹¤. `ds(` ë¥¼ í•˜ë©´ ê´„í˜¸ë¥¼ ì‚­ì œí•˜ê³ , `cs({` ë¥¼ í•˜ë©´ ì†Œê´„í˜¸ë¥¼ ì¤‘ê´„í˜¸ë¡œ ë°”ê¿”ì¤€ë‹¤. ìš©ë²•ì´ ë§¤ìš° ìì—°ìŠ¤ëŸ½ê³  ì´ê²ƒë„ ê·¸ëƒ¥ ì½”ì–´ì— í†µí•©ë¼ë„ ë¬¸ì œ ì—†ì„ ê²ƒ ê°™ì€ë°...\n\n### [vim-fugitive](https://github.com/tpope/vim-fugitive)\n\nGit wrapper í”ŒëŸ¬ê·¸ì¸ì´ë‹¤. í”ŒëŸ¬ê·¸ì¸ ì¤‘ ê±°ì˜ 1ìˆœìœ„ë‹¤. ìˆìœ¼ë©´ git ê´€ë¦¬ê°€ ì •ë§ í¸í•´ì§„ë‹¤.\n\n## Colorschemes\n\ní…Œë§ˆë„ ì‹ ê²½ì“°ëŠ” í¸ì´ë‹¤. ë‚˜ëŠ” ëŒ€ì²´ë¡œ high contrast í…Œë§ˆë¥¼ ì¢‹ì•„í•œë‹¤.\n\n- [tokyonight.nvim](https://github.com/folke/tokyonight.nvim) - ì°¨ê°€ìš´ ê³„ì—´ì˜ í…Œë§ˆë‹¤\n- [srcery-vim](https://github.com/srcery-colors/srcery-vim) - ë”°ëœ»í•œ ê³„ì—´ì˜ í…Œë§ˆë‹¤\n- [modus-theme-vim](https://github.com/ishan9299/modus-theme-vim) - high contrast ë§Œë•…ì´ë©´ì„œ ìƒ‰ê¹”ì´ ë§ˆìŒì— ë“ ë‹¤\n- [panic.vim](https://github.com/pacokwon/panic.vim) - ì—­ì‹œ high contrast ë§Œë•…ì´ë‹¤. ë‹¤ë§Œ ìœ ì§€ë³´ìˆ˜ê°€ ë˜ê³  ìˆì§€ëŠ” ì•Šì•„ì„œ forkí•´ì„œ ë‚´ê°€ ì‚¬ìš©í•˜ëŠ” í”ŒëŸ¬ê·¸ì¸ë“¤ì—ì„œ ìš”í•˜ëŠ” highlight groupë“¤ì„ ì¶”ê°€í•´ ì“°ëŠ” ì¤‘ì´ë‹¤.\n- [onedarkhc.vim](https://github.com/pacokwon/onedarkhc.vim) - ê¸°ì¡´ì— ìˆë˜ onedarkì˜ ìƒ‰ê¹”ë“¤ì„ ìˆ˜ì •í•´ì„œ ì¡°ê¸ˆ ë” high contrastë¡œ ë§Œë“¤ì–´ ë‘ì—ˆë‹¤. ì‚¬ì‹¤ ìƒ‰ê¹”ë§Œ ë°”ê¾¼ê±°ë¼ forkí•˜ëŠ”ê²Œ ë§ëŠ”ë° 1í•™ë…„ ë•Œ ì•” ìƒê°ì—†ì´ ë§Œë“¤ì—ˆì–´ì„œ READMEì— creditë§Œ í•´ë†“ì€ ìƒíƒœë‹¤.\n","title":"Development Environment - Neovim","tags":["neovim","ko"],"date":"2021-09-20"},{"id":"20210914-chip8-emulator-in-rust","content":"\nRustë¡œ ë­”ê°€ëŠ” ë§Œë“¤ì–´ë³´ê³  ì‹¶ì€ë° ë§ˆì¹¨ ì—ë®¬ë ˆì´í„°ë„ ë§Œë“¤ì–´ë³´ê³  ì‹¶ì–´ì„œ ì…ë¬¸ìš© í”„ë¡œì íŠ¸ë¡œ ë§ì´ í•œë‹¤ëŠ” Chip-8 ì—ë®¬ë ˆì´í„°ë¥¼ ì‘ì„±í•´ë³´ë ¤ê³  í•œë‹¤. ì•„ì§ ì‹œì‘ë„ ì•ˆí–ˆê¸° ë•Œë¬¸ì— ì—¬ê¸° ì ì„ ë‚´ìš©ì€ ë§ì§€ ì•Šë‹¤. ì´ í¬ìŠ¤íŠ¸ë¥¼ ì—…ë°ì´íŠ¸í•´ê°€ë©° ì§œë ¤ê³  í•œë‹¤.\n\n### Update:\n\nìƒê°ë³´ë‹¤ instruction ê°œìˆ˜ê°€ ì ê³  êµ¬ì¡°ë„ ë‹¨ìˆœí•œ í¸ì´ë¼ êµ¬í˜„ì´ ì´í‹€ ì •ë„ë§Œì— ì™„ì„±ë˜ì—ˆë‹¤. ì¢€ ìƒì†Œí–ˆë˜ ë¶€ë¶„ë“¤ì€ í¬ê²Œ ë‘ ê°€ì§€ì˜€ëŠ”ë°, ì²« ë²ˆì§¸ëŠ” opcode êµ¬í˜„ ì‹œ ëª…ì„¸ê°€ ì¸í„°ë„·ì— ìˆëŠ” ì°¸ê³ ìë£Œë§ˆë‹¤ ë‹¤ë¥¸ ê²½ìš°ê°€ ìˆì—ˆë‹¤ëŠ” ê±°ë‹¤. ê·¸ë˜ì„œ ë‡Œí”¼ì…œ + ë‹¤ìˆ˜ì˜ ì˜ê²¬ì„ ë”°ë¼ êµ¬í˜„ì„ í–ˆë‹¤. ë‘ ë²ˆì§¸ëŠ” SDL2 ì‚¬ìš©ì¸ë°, [SDL2 binding for Rust](https://github.com/Rust-SDL2/rust-sdl2) ì˜ ë¬¸ì„œí™”ê°€ ê½¤ ì˜ ë¼ìˆì–´ì„œ ë°ëª¨ ì½”ë“œë¥¼ ì°¸ê³ í•˜ë‹ˆ ìƒê°ë³´ë‹¤ ìˆ˜ì›”í–ˆë‹¤.\n\nì•„ì£¼ ì œëŒ€ë¡œ ëœ í…ŒìŠ¤íŒ…ì€ ì§„í–‰í•˜ì§€ ì•Šì•˜ì§€ë§Œ [í…ŒìŠ¤íŠ¸ ROM](https://github.com/corax89/chip8-test-rom) í˜•íƒœë¡œ ì•„ì£¼ ì†ì‰½ê²Œ í…ŒìŠ¤íŒ…í•´ë³¼ ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ìˆì–´ì„œ ì´ ROMì„ ì‹¤í–‰í•´ë³´ê¸´ í–ˆë‹¤. ì´ ROMì„ í†µí•´ ì¡ì€ ë²„ê·¸ëŠ” Rustì—ì„œ ì •ìˆ˜ ì—°ì‚° ì˜¤ë²„í”Œë¡œìš°ê°€ ìë™ìœ¼ë¡œ ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì ì´ì—ˆë‹¤. ê·¸ë˜ì„œ ê±°ì˜ ëª¨ë“  ì—°ì‚° ë¶€ë¶„ì„ ê·¸ëƒ¥ ì˜¤ë²„í”Œë¡œìš°ê°€ ë˜ë„ë¡ ìˆ˜ì •í–ˆë‹¤. `Wrapping`ì´ë¼ëŠ” íƒ€ì…ìœ¼ë¡œ í•´ì•¼ í•˜ë˜ë° í¼í¬ë¨¼ìŠ¤ ì €í•˜ëŠ” ì—†ëŠ” ê²ƒìœ¼ë¡œ ì•Œê³  ìˆë‹¤. ê·¸ëƒ¥ ì½”ë“œê°€ ì¡°ê¸ˆ ë” verboseí•´ì§ˆ ë¿..\n\nì˜¤ë””ì˜¤ êµ¬í˜„ì€ ì•ˆ(ëª»)í–ˆëŠ”ë° í° ê´€ì ì—ì„œ ì¤‘ìš”ë„ê°€ ë–¨ì–´ì§€ëŠ” ë°˜ë©´ trivialí•œ í•´ê²° ë°©ë²•ì´ ì—†ì–´ ê·¸ëƒ¥ ëƒ…ë‘” ìƒíƒœì´ë‹¤. `'\\a'` ì½”ë“œì²˜ëŸ¼ ì‚‘ ì†Œë¦¬ë§Œ ë‚˜ë„ ì¶©ë¶„í•  ê²ƒ ê°™ë˜ë° ì˜¤ë˜ëœ ê·œì•½ì´ë‹¤ ë³´ë‹ˆ ê¸°ê¸°ë§ˆë‹¤ `'\\a'` ê°€ ì‘ë™í•˜ì§€ ì•ŠëŠ” ê²½ìš°ë„ C í”„ë¡œê·¸ë˜ë°ì„ í•  ë•Œ ì¢…ì¢… ë³´ì•˜ëŠ”ë° Rustì—ì„œëŠ” ê·¸ëƒ¥ ì§€ì›ì´ ì•ˆ ë˜ëŠ” ê²ƒ ê°™ì•˜ë‹¤. ë­”ê°€ ë‚´ê°€ ëª¨ë¥´ëŠ” ì‰¬ìš´ ë°©ë²•ì„ ì°¾ê±°ë‚˜ ì•„ì£¼ ë¯¸ë‹ˆë©€í•œ ì˜¤ë””ì˜¤ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ë©´ ë  ê²ƒ ê°™ë‹¤.\n\nì´ ì‘ì€ í”„ë¡œì íŠ¸ë¥¼ í†µí•´ ì—ë®¬ë ˆì´í„°ë¥¼ ì¡°ê¸ˆ ë” ìì„¸íˆ ì´í•´í•  ìˆ˜ ìˆì—ˆë˜ ê²ƒ ê°™ë‹¤. ê·¸ ë‹¤ìŒ ë‹¨ê³„ëŠ” NESë‚˜ Gameboy ì—ë®¬ë ˆì´í„° êµ¬í˜„ì¼í…ë°, ë‚œì´ë„ ìƒìŠ¹ í­ì´ ì¡°ê¸ˆ í° ê²ƒìœ¼ë¡œ ë³´ì¸ë‹¤.\n\n## Repository\n\nhttps://github.com/pacokwon/scaters\n\n## References\n\nì°¸ê³ ìë£Œë“¤ì´ë‹¤. ê½¤ ì˜¤ë˜ëœ ë§¤ë‰´ì–¼ë“¤ì¸ë° í•„ìš”í•œ ë‚´ìš©ì€ ëª¨ë‘ ë‹´ê³  ìˆê³  ìƒë‹¹íˆ ë„ì›€ì´ ë§ì´ ë˜ì—ˆë‹¤.\n\n- http://www.cs.columbia.edu/~sedwards/classes/2016/4840-spring/designs/Chip8.pdf\n- http://devernay.free.fr/hacks/chip8/C8TECH10.HTM\n","title":"Building a Chip-8 Emulator in Rust","tags":["rust","emulator","ko"],"date":"2021-09-14"},{"id":"20210913-neovim-users-perspective","content":"\nIt's been two years since I've first used Vim.\n\nThe reason I started to learn Vim was because I saw so many experience programmers using it. I thought that there must be something special to it, and I had to give it a try.\n\nIt wasn't easy at first. There certainly is a learning curve, and I often was tempted to go back to my old editor. But once I got used to it, it only got better from there. I loved the speed, the efficient keybindings, the ecosystem of plugins, and the fact that it's still a minimal editor that I configured for myself.\n\nThen there was Neovim. The first time I've heard about it was from [coc.nvim](https://github.com/neoclide/coc.nvim), which was one of the few plugins that had great LSP support out of the box. It was from then I started using Neovim.\n\nI suspect that Neovim was version `0.4.x` at the time. I couldn't feel _any_ differences from Vim whatsoever, but it turns out Neovim at that time was in the verge of a major breakthrough: `0.5.0`.\n\n## Neovim `0.5.0`\n\nNeovim `0.5.0` introduced a ton of new updates to the editor, as a user, there were 3 major featuresthat were added in this release.\n\n### Built-in LSP client support\n\nThe Language Server Protocol is a spec that allows independent \"language servers\" to communicate with and provide useful functionalities such as `Hover Docs`, `Goto Definition`, `Format` to editors that implement a \"language client\". The separation of responsibilities allowed: language servers to do what they do best, and editors to offer rich features without implementing it themselves.\n\nPreviously, plugins were acting as LSP clients to communicate with the respective servers, and this is what coc.nvim was doing really well. But I felt guilty using it because one could easily see that it was a little bloated. It did too many things at once, not to mention that it spawned node processes in the background.\n\nThe built-in LSP support in the `0.5.0` release allowed users to configure lsp servers to their own preference by providing a generic configuration interface. It felt minimal, it was less laggy, I knew what it was doing, and I loved it. One downside might be that it requires a fair amount of code to configure.\n\n### tree-sitter syntax highlighting support\n\nThe way Vim does highlighting is through regexes (AFAIK). It parses tokens through regexes and applies the corresponding highlight groups to them. tree-sitter is a replacement for this highlighting method.\n\ntree-sitter is a dedicated parser generator, meaning that it outputs a parser given a certain language's grammar. I've heard good things about tree-sitter such as its performance and tolerance to syntax errors, but I won't go further because I don't have background knowledge to back it up - for all I know, it does its job really well, and it is capable of providing consistent syntax highlighting across a ton of languages.\n\nSo far, the syntax highlighting that tree-sitter provides has been really great, and it's making me happy.\n\n### lua as a first class configuration language\n\nPreviously and still in Vim 8, vimscript remains the primary language for editor configuration. And vimscript is.. such an odd language. I tried learning it, but the experience was not so good. It was not like any other language that I've learned, and not in a good way either. IMO this would have certainly prevented some users from being able to comfortably write their `vimrc`s or plugins.\n\nAnd then lua came in. It's a very small scripting language that got integrated into Neovim from `0.5.0`. Unlike vimscript it's a general purpose language, it makes more sense and knowledge can be transferred from and to other languages more easily. This allowed users to write their `vimrc`s and plugins in lua and only using lua. The pace at which new plugins came out after lua was first integrated into Neovim was astonishing. Although there now exists incompatibilities between Vim and Neovim with lua plugins, I'm still very happy that the ecosystem is thriving much faster now.\n\nAs someone who loves using and making tools for developers, Neovim stands as my favorite open source project. And because of that, one of my goals is to try to create plugins and/or contribute to the Neovim project. At least I hope to do so.\n","title":"Neovim 0.5.0 - A User's Perspective","tags":["neovim","en"],"date":"2021-09-13"},{"id":"20210913-destructuring-refs-in-rust","content":"\nWhile teaching myself some Rust, it was common to see some code that \"looked like\" it was destructuring references, like:\n\n```rust\nfn main() {\n    let vec = vec![1, 2, 3];\n    let mut iter = vec.into_iter();\n\n    println!(\"Find 2 in vec: {:?}\", iter.find(|&x| x == 2)); // Find 2 in vec: Some(2)\n}\n```\n\nAt first glance, the semantics were a little hard to predict. My curiosity all came down to this: does this copy the whole value? So I decided to write some code to make things clear.\n\n```rust\n#[derive(Debug,Clone,Copy)]\nstruct Foo {\n    a: u32,\n    b: u32,\n}\n\nfn main() {\n    let mut x = Foo { a: 3, b: 4 };\n    let &mut mut y = &mut x;        // destructure mutable reference, AND the variable is mutable\n    y.a = 50;\n    println!(\"{:?} {:?}\", x, y);    // ??\n}\n```\n\n### Output:\n\n```bash\nFoo { a: 3, b: 4 } Foo { a: 50, b: 4 }\n```\n\nA pretty minimal example here, but the syntax looks real weird. I actually had a hard time trying to express what I wanted to because of the syntax.\n\nOnce we try to mutate the struct's field, the output shows that only `y` is mutated. It shows us that it indeed copies the whole value.\n\nWhat if we try to destructure something that does not implement the `Copy` trait, like a vector?\n\n```rust\nfn main() {\n    let mut x = vec![1, 2, 3];\n    let &mut mut y = &mut x;\n    println!(\"{:?}\", y);\n}\n```\n\n### Output:\n\n```bash\nerror[E0507]: cannot move out of a mutable reference\n  --> src/main.rs:10:22\n   |\n10 |     let &mut mut y = &mut x;\n   |         ----------   ^^^^^^\n   |         |    |\n   |         |    data moved here\n   |         |    move occurs because `y` has type `Vec<i32>`, which does not implement the `Copy` trait\n   |         help: consider removing the `&mut`: `mut y`\n\nerror: aborting due to previous error; 1 warning emitted\n```\n\nPretty much the same example except that it's a vector, but the compiler complains for the exact reason why we tried this example in the first place. The destructure does not work because the `Vec` struct does not implement `Copy`. What I've understood from these examples, is that such destructuring is meant to be used on types that support cheap copying.\n\n## References\n\n- https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_pointers.html\n","title":"Destructuring & References in Rust","tags":["rust","quicknote","en"],"date":"2021-09-13"},{"id":"20210911-simple-state-monad","content":"\n_This post is based on [this video](https://www.youtube.com/watch?v=WYysg5Nf7AU) from Graham Hutton's playlist on advanced functional programming. I tried to write this post without rewatching the video, to deliver my own understanding of the concept._\n\n## Defining `State`\n\nStateë¥¼ í‘œí˜„í•˜ëŠ” ì–´ë–¤ ê°’ì´ ìˆì„ ë•Œ, ì´ stateë¥¼ ë³€ê²½ì‹œí‚¤ëŠ” ì–´ë–¤ black boxê°€ ìˆë‹¤ê³  í•˜ì. ê·¸ black boxëŠ” ì´ë ‡ê²Œ í‘œí˜„í•  ìˆ˜ ìˆì„ ê²ƒ ê°™ë‹¤.\n\n```haskell\nblackBox :: a -> a -- where a denotes the state's type\n```\n\nì´ë•Œ black boxì—ì„œ inputìœ¼ë¡œ ë“¤ì–´ì˜¨ stateë¥¼ ì´ìš©í•´ ì–´ë–¤ ê°’ì„ ê³„ì‚°í•œë‹¤ê³  ê°€ì •í•œë‹¤ë©´, í˜„ì¬ í•¨ìˆ˜ì˜ íƒ€ì… ì •ë³´ë¡œëŠ” í•´ë‹¹ ê²°ê³¼ë¥¼ ì˜ í‘œí˜„í•˜ê¸° ì–´ë µë‹¤. ë”°ë¼ì„œ outputì„ ë‘ ê°œ ëŒë ¤ì£¼ëŠ” ë‹¤ìŒê³¼ ê°™ì€ íƒ€ì…ì´ ë” í¸ë¦¬í•˜ë‹¤.\n\n```haskell\nblackBox :: a -> (b, a) -- where a denotes the state's type, and b the return value's type\n```\n\nì´ëŸ¬í•œ black boxì— í•´ë‹¹í•˜ëŠ” ìƒˆë¡œìš´ íƒ€ì…ì„ ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•´ë³´ì. Recordì— ëŒ€í•´ ë§¤ë²ˆ pattern matchë¥¼ í•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´, `State`ì™€ state ê°’ì´ ì£¼ì–´ì¡Œì„ ë•Œ, transformerë¥¼ í˜¸ì¶œí•´ì£¼ëŠ” helper ë˜í•œ ì •ì˜í•˜ì.\n\n```haskell\nnewtype State a b = S {getState :: a -> (b, a)}\n\nrunState :: State a b -> a -> (b, a)\nrunState S {getState = f} = f\n```\n\n0ë¶€í„° ì‹œì‘í•˜ëŠ” idë¥¼ ìƒì„±í•˜ëŠ” í•¨ìˆ˜ê°€ ìˆë‹¤ê³  í•˜ì. ì´ëŸ¬í•œ ìƒí™©ì—ì„œëŠ” STë¥¼ ë‹¤ìŒê³¼ ê°™ì´ í‘œí˜„í•˜ì—¬ idë¥¼ ë½‘ì•„ë‚¼ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.\n\n```haskell\n-- Plain.hs\nnext :: State Int Int\nnext = S $ \\n -> (n, n + 1)\n\nmain :: IO ()\nmain = do\n    let n0 = 0\n    let (id, n)     = runState next n0\n    let (id', n')   = runState next n\n    let (id'', n'') = runState next n'\n    print id        -- 0\n    print id'       -- 1\n    print id''      -- 2\n    print n''       -- 3\n```\n\n`next` ë¼ëŠ” state transformerë¥¼ ì‚¬ìš©í•˜ë©´ idë¥¼ í•˜ë‚˜ ìƒì„±í•˜ê³  stateë¥¼ í•˜ë‚˜ ì¦ê°€ì‹œí‚¤ëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ `id`, `id'`, `id''`ë“± `next` STì— ìƒˆë¡œìš´ stateë¥¼ inputìœ¼ë¡œ ë„£ì–´ ìƒì„±í•œ idë“¤ì€ ê°ê° 0, 1, 2, 3ì˜ ê°’ì„ ê°€ì§€ê²Œ ëœë‹¤.\n\n## ê¸°ì¡´ ë°©ì‹ì˜ ë¬¸ì œì ê³¼ `bind` í•¨ìˆ˜\n\nìœ„ ì½”ë“œì—ì„œ ë¬¸ì œì ì´ ìˆë‹¤ê³  í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ì€ compositionì´ ë¶ˆí¸í•˜ë‹¤ëŠ” ì ì´ë‹¤. `runState` ëŠ” ìƒˆë¡œìš´ stateë¥¼ ë§Œë“¤ì–´ ë‚´ê¸° ë•Œë¬¸ì—, ì´ í•¨ìˆ˜ë¥¼ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•´ì•¼ í•˜ëŠ” ìƒí™©ì—ì„œëŠ” ìµœì‹  stateë¥¼ ì˜ ë„˜ê²¨ì£¼ë„ë¡ ìœ ì˜í•´ì•¼ í•œë‹¤. ì´ë¥¼ ìœ„í•´ ë§¤ë²ˆ pattern matchë¥¼ í•´ì•¼ í•˜ê³ , ë§¤ë²ˆ stateë¥¼ explicití•˜ê²Œ ë„˜ê²¨ì£¼ì–´ì•¼ í•œë‹¤. íë¦„ ìƒìœ¼ë¡œë§Œ ë³´ë©´ ë°˜ë³µë˜ëŠ” ì½”ë“œì¸ë° í•„ìš”ëŠ” í•˜ê¸° ë•Œë¬¸ì— ì¼ì¢…ì˜ boilerplateì¸ ê²ƒì´ë‹¤. ì´ëŠ” ì½”ë“œë¥¼ ì‘ì„±í•  ë•Œ error proneí•˜ê³ , ì½ì„ ë•Œë„ ë¶ˆí•„ìš”í•œ ë””í…Œì¼ì´ë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ë¬¸ì œì ì„ monadë¥¼ í†µí•´ í•´ê²°í•´ë³´ì!\n\në¨¼ì € `bind` í•¨ìˆ˜ë¥¼ ì •ì˜í•´ë³´ì. `bind` ì˜ íƒ€ì…ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.\n\n```haskell\nbind :: m a -> (a -> m b) -> m b\n```\n\nì´ë•Œ `m` ì€ type constructorìœ¼ë¡œ, í˜„ì¬ ìƒí™©ì˜ ê²½ìš° `State s` ì— í•´ë‹¹í•œë‹¤.\n\n```haskell\nbind :: State s a -> (a -> State s b) -> State s b\n```\n\nstate transformationì„ ë‘ ë²ˆ ì‹œí–‰í•¨ìœ¼ë¡œì¨ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.\n\n```haskell\nbind :: State s a -> (a -> State s b) -> State s b\nbind sa f = S $ \\s ->\n  let (a, s') = runState sa s in runState (f a) s'\n```\n\nì´ í•¨ìˆ˜ë§Œ ìˆì–´ë„ compositionì´ ë” ê¹”ë”í•´ì§„ë‹¤. ìœ„ì— ìˆëŠ” `main` í•¨ìˆ˜ë¥¼ ë¦¬íŒ©í† ë§í•´ë³´ì.\n\n```haskell\n-- Bind.hs\nnext :: State Int Int\nnext = S $ \\n -> (n, n + 1)\n\nmain :: IO ()\nmain = fst $ runState (\n    next `bind` \\id ->\n    next `bind` \\id' ->\n    next `bind` \\id'' ->\n    S $ \\s -> (\n      do\n        print id\n        print id'\n        print id'',\n      s\n    ))\n  0\n```\n\n(í‘œì¤€ ì¶œë ¥ì„ ìœ„í•œ IO ì¡°ì‘ ì½”ë“œê°€ ìˆëŠ”ë°...ë¬´ì‹œí•˜ê³  ë³´ì)\n\n`runState` ì˜ ì²« ë²ˆì§¸ ì¸ìë¡œ ë„˜ê²¨ì§„ `State` ì½”ë“œì™€, ìœ„ì— ìˆëŠ” ë¦¬íŒ©í† ë§ ì´ì „ ì½”ë“œë¥¼ ë¹„êµí–ˆì„ ë•Œ, trivialí•œ state ê´€ë¦¬ ì½”ë“œê°€ ì•„ì˜ˆ ì‚¬ë¼ì§„ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤. compositionì„ ìœ„í•´ ë§¤ë²ˆ ìƒˆë¡œìš´ stateë¥¼ ë‹¤ìŒ í˜¸ì¶œì— ë„˜ê²¨ì£¼ë˜ íŒ¨í„´ì„ `bind` ë¼ëŠ” í•¨ìˆ˜ ì•ˆì— ë„£ì–´ë‘ì—ˆê¸° ë•Œë¬¸ì— í•µì‹¬ ì½”ë“œê°€ ë”ìš± ì¤‘ì ì ìœ¼ë¡œ ë“œëŸ¬ë‚˜ê²Œ ë˜ì—ˆë‹¤.\n\nì´ `bind` ë¼ëŠ” í•¨ìˆ˜ëŠ” `Monad` íƒ€ì…í´ë˜ìŠ¤ì— `(>>=)` ë¼ëŠ” í•¨ìˆ˜ì˜ í˜•íƒœë¡œ ì¡´ì¬í•œë‹¤. `State` ë¥¼ `Monad` íƒ€ì…í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ ë§Œë“¤ë©´ `do` notationì˜ syntactic sugar ë˜í•œ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ëœë‹¤. ë‹¤ë§Œ `Monad` íƒ€ì…í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¡œ ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” ê·¸ superclassì¸ `Applicative` ê¹Œì§€ êµ¬í˜„ì„ í•´ì•¼ í•˜ê³ , `Applicative` ì˜ superclassì¸ `Functor` ê¹Œì§€ êµ¬í˜„í•´ì•¼ í•œë‹¤. êµ¬í˜„ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.\n\n```haskell\nimport Control.Applicative\n\n-- a type that contains a state transformer\n-- the state transformer accepts a state, and returns a state with some return value\nnewtype State a b = S {getState :: a -> (b, a)}\n\nrunState :: State a b -> a -> (b, a)\nrunState S {getState = f} = f\n\ninstance Functor (State a) where\n  -- fmap :: (a -> b) -> State s a -> State s b\n  fmap f (S transform) = S (\\s -> let (r, s') = transform s in (f r, s'))\n\ninstance Applicative (State a) where\n  -- pure :: a -> State s a\n  pure x = S $ \\s -> (x, s)\n\n  -- (<*>) :: State s (a->b) -> State s a -> State s b\n  sf <*> sa = S $ \\s ->\n    let (f', s') = runState sf s\n     in runState (f' `fmap` sa) s'\n\ninstance Monad (State a) where\n  -- (>>=) :: State s a -> (a -> State s b) -> State s b\n  (S f) >>= t = S $ \\s ->\n    let (a, s') = f s in runState (t a) s'\n```\n\nì´ì œ `do` notationì„ ì´ìš©í•´ ì½”ë“œë¥¼ 2ì°¨ë¡œ ë¦¬íŒ©í† ë§í•´ë³´ì.\n\n```haskell\nnext :: State Int Int\nnext = S $ \\n -> (n, n + 1)\n\nmain :: IO ()\nmain = fst $ runState (\n  do\n    id <- next\n    id' <- next\n    id'' <- next\n    S $ \\s ->\n      ( do\n          print id\n          print id'\n          print id'',\n        s\n      )\n  )\n  0\n```\n\n`bind` í˜¸ì¶œì´ ì—†ìœ¼ë‹ˆ ì¡°ê¸ˆ ë” ê°„ê²°í•´ì¡Œë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ, `State` monadë¥¼ ì‚¬ìš©í•˜ëŠ” ì½”ë“œë¥¼ ë¶„ë¦¬í•˜ì—¬ ë¦¬íŒ©í† ë§ì„ í•´ë³´ì.\n\n```haskell\n-- Main.hs\nnext :: State Int Int\nnext = S $ \\n -> (n, n + 1)\n\nnextThree :: State Int (Int, Int, Int)\nnextThree = do\n  id <- next\n  id' <- next\n  id'' <- next\n  return (id, id', id'')\n\ngetThreeIds :: Int -> (Int, Int, Int)\ngetThreeIds start = fst $ runState nextThree start\n\nmain :: IO ()\nmain = do\n  let (id, id', id'') = getThreeIds 0\n  print id\n  print id'\n  print id''\n```\n\níŠ¹íˆ ì²˜ìŒì— ë¹„í•˜ë©´ ì½”ë“œê°€ í›¨ì”¬ ê°„ê²°í•´ì§„ ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.\n\n## Tree Labeling\n\ní•´ë‹¹ monadë¥¼ ë˜ ë‹¤ë¥¸ ì˜ˆì‹œì— ì ìš©í•´ë³´ì. ì´ëŠ” ìœ„ì— ì–¸ê¸‰ëœ ë™ì˜ìƒì— ìˆëŠ” ì˜ˆì‹œì´ê¸°ë„ í•˜ë‹¤.\n\n```haskell\ndata Tree a = Leaf a | Node (Tree a) (Tree a) deriving Show\n```\n\në‹¤ìŒê³¼ ê°™ì€ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ê°€ ìˆì„ ë•Œ, ê°ê° leafë§ˆë‹¤ ìˆ«ì idë¥¼ ë¶™ì—¬ `label`í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•´ë³´ì. ë¨¼ì € monad ì—†ì´ ë§¤ë‰´ì–¼í•˜ê²Œ ì‘ì„±í•´ë³´ì.\n\n```haskell\nlabel :: Tree a -> Int -> (Tree Int, Int)\nlabel (Leaf v) n = (Leaf n, n + 1)\nlabel (Node l r) n = (Node l' r', n'')\n  where\n    (l', n') = label l n\n    (r', n'') = label r n'\n```\n\nì´ í•¨ìˆ˜ëŠ” stateë¥¼ ê´€ë¦¬í•œë‹¤. ê·¸ ë‹¤ìŒì— ì‚¬ìš©í•  idì¸ `n`ì´ë‹¤. í•¨ìˆ˜ë¥¼ pureí•˜ê²Œ ìœ ì§€í•˜ê¸° ìœ„í•´ì„œëŠ” ë°”ëŠ˜êµ¬ë©ì— ì‹¤ ê¶¤ë§¤ë“¯ì´ ì´ stateë¥¼ ê³„ì† ë“¤ê³  ë‹¤ë…€ì•¼ í•œë‹¤.ê·¸ëŸ¼ ìœ„ì—ì„œ ë§Œë“  `State` ë¥¼ ì´ìš©í•˜ì—¬ ê°™ì€ ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì.\n\n```haskell\nmlabel :: Tree a -> State Int (Tree Int)\nmlabel (Leaf v) = do\n  n <- next\n  return (Leaf n)\n\nmlabel (Node l r) = do\n  l' <- mlabel l\n  r' <- mlabel r\n  return (Node l' r')\n```\n\nì‹¤ ê¿°ë§¤ë“¯ stateë¥¼ ìš´ë°˜í•˜ëŠ” ì½”ë“œëŠ” ë”ì´ìƒ ë³´ì´ì§€ ì•ŠëŠ”ë‹¤. ì´ í•¨ìˆ˜ëŠ” ì´ë ‡ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.\n\n```haskell\n-- Tree.hs\ntestTree :: Tree String\ntestTree = Node (Leaf \"foo\") (Node (Leaf \"bar\") (Leaf \"baz\"))\n\nmain :: IO ()\nmain = do\n  let labeled = fst $ runState (mlabel testTree) 0\n  print labeled\n```\n\n(`runState` ë‘ 0ì´ ë¶ˆí¸í•˜ë©´ ë‹¤ë¥¸ í•¨ìˆ˜ë¡œ ë§Œë“¤ì–´ë‘ë©´ ëœë‹¤...ì—¬ê¸°ì„  ìƒëµí•œë‹¤)\n\nì´ë¡œì¨ ìˆœìˆ˜ í•¨ìˆ˜í˜• ì–¸ì–´ì¸ haskellì—ì„œ monadë¥¼ í†µí•´ stateë¥¼ ê¹”ë”í•˜ê²Œ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ì•˜ë‹¤! ê¸€ì„ ì“°ë©° ë‚˜ ì—­ì‹œ ë§ì´ ë°°ìš´ ê²ƒ ê°™ë‹¤. ì´ ê²Œì‹œê¸€ì—ì„œ ì‚¬ìš©í•œ ì½”ë“œëŠ” [ì´ ë ˆí¬](https://github.com/pacokwon/simple-state-monad-demo)ì— ì—…ë¡œë“œë˜ì–´ìˆë‹¤!\n","title":"Simple State Monad in Haskell with Examples","tags":["haskell","ko"],"date":"2021-09-11"},{"id":"20210903-building-a-blog","content":"\nIn this post I'll be briefly going through how I built my blog with Next.js and some difficulties that I've faced. This will only be a personal reflection, not a tutorial.\n\nSo one day, I decided to build a personal blog. Nothing fancy but a rather simple blog to put my personal info with posting capability. Yes, you can use a given template, but I personally have this avoidance for templates. I wish to have complete control of what I use and build, and thus I decided to use a SSG/SSR framework called Next.js.\n\nAnd so, here are the main tools/packages that I've used to build my blog:\n\n- Next.js\n- Remark / Rehype\n- Material UI React\n- GitHub Pages & Workflow\n  I'll go through each of these to address my thoughts on them.\n\n## Next.js\n\nNext.js is a SSG/SSR framework for React. I haven't done SSG nor SSR ever before. It looked like Next.js and Gatsby both offer SSG functionality, so I had to choose. After a bit of research, I knew that Next.js would suit me better. To me Gatsby looked like a full fledged ecosystem with plugins and all, while Next.js was more like plug-and-play. It seemed like I would not have as much control over the project if I used Gatsby, so I chose Next.js. Of course, I haven't used Gatsby so there's the benefit of the doubt.\n\n## Remark / Rehype\n\nRemark / Rehype are libraries that transform markdown and html. I used these packages to convert them into React components, so that I could upload my posts.\n\nThe overall process of conversion is: `Markdown File - Remark - Rehype - React Component`. The markdown file is parsed with remark, translated to html using rehype, and then to a React component. The ecosystem allows you to plug processors in between. For example, I've used the `rehype-highlight` package that highlights code with `highlight.js` under the hood.\n\nWhat I really liked about this package is that it allows users to use their own components for each html tag from markdown. For now, rounding corners in code blocks remain my only usage for this feature (...) but I'm sure I could do much more.\n\n## Material UI React\n\nMaterial UI component library provides many useful components that follow the Material UI design. _I like pretty things, but I don't like CSS._ This library is for me. The familiarity helps as well. Most (if not all) google products use this guideline. The documentation is top notch as well. It also allows easy custom styling.\n\n## GitHub Pages & Workflow\n\nI've used GitHub pages as my blog hosting service. It serves static assets for free. I heard good things about it, but have never used it before. I had some difficulty initially setting it up, only to find out that I haven't changed the branch for github pages.\n\nSince generating static files requires a building process using Next.js, I have also set up GitHub Actions to automatically build as I push.\n\nI hope to keep my blog minimal, but the minimum functionality will grow larger as the need arises. Eventually the stack will grow as well, and maybe I'll do version 2 of this post when it happens.\n","title":"Building a Personal Blog in Next.js","tags":["nextjs","en"],"date":"2021-09-03"},{"id":"20210831-navy-software-developer","content":"\në¸”í•˜ (ë¸”ë¡œê·¸ í•˜ì´ë¼ëŠ” ëœ»)\n\nì•„ë¬´ ìƒê° ì—†ì´ ëŒ€í•™êµë¥¼ ë‹¤ë‹ˆë‹¤ê°€ ë³´ë‹ˆ ì‹œê°„ì´ ì°¸ ë¹¨ë¦¬ ì§€ë‚˜ê°”ë‹¤. ê³ ë“±í•™êµ ë™ê¸°ë“¤ ì¤‘ì—ì„œëŠ” êµ°ëŒ€ê°€ëŠ” ì¹œêµ¬ë“¤ì„ ì—¬ëŸ¿ ë³´ì•˜ëŠ”ë°, ì…ëŒ€ë¥¼ 3í•™ë…„ ì´í›„ë¡œ ìƒê°í•˜ê³  ìˆë˜ ì´ìœ ëŠ” ë§ì•˜ë‹¤.\n\n1. ìš°ë¦¬ í•™êµëŠ” ë‹¤ë“¤ êµ°ëŒ€ë¥¼ ì¢€ ëŠ¦ê²Œ ê°€ëŠ” ë¶„ìœ„ê¸°ì˜€ì–´ì„œ..\n2. ì…ëŒ€í•˜ê¸° ì „ì— í•™êµì—ì„œ ìµœëŒ€í•œ ë§ì´ ë°°ì›Œë³´ê³  ì‹¶ì€ ìš•êµ¬ë„ ì¢€ ìˆì—ˆë‹¤. ë¬¼ë¡  ê·¸ë˜ë´ì•¼ ì „ê³µ ìˆ˜ì—…ë“¤ì´ê¸´ í–ˆì§€ë§Œ ì‹¤ì œë¡œ í•™ì ì„ êµ‰ì¥íˆ ëª°ì•„ ë“¤ì—ˆë‹¤. ì¡¸ì—… ì´ëŸ°ê±° ë•Œë¬¸ì´ ì•„ë‹ˆê³  ë§›ë³´ê³  ì‹¶ì€ê²Œ ë§ì•˜ë‹¤.\n3. ì´ì™• ê°€ëŠ”ê±° ê°œë°œ ìª½ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆìœ¼ë©´ ì¢‹ì„ ê±°ë¼ ìƒê°í–ˆë‹¤. ê·¼ë° ê·¸ëŸ¬ë ¤ë©´ 2í•™ë…„ì€ ë§ˆì³ì•¼ ê°€ëŠ¥ì„±ì´ ì¡°ê¸ˆì´ë¼ë„ ìƒê¸´ë‹¤.\n\n3ë²ˆ ì´ìœ ê°€ ê°€ì¥ ì»¸ë‹¤. ë³‘íŠ¹ì„ ê³ ë ¤í•˜ì§€ ì•Šì€ ì´ìœ ëŠ” ë‚´ê°€ ëŒ€í•™ì›ì„ ê°€ê²Œ ë˜ë©´ ê·¸ ì „ì— ì‹œê°„ì„ ë„ˆë¬´ ë§ì´ ì¨ì•¼ í•´ì„œ..ê·¸ë¦¬ê³  ë‚œ ëŒ€í•™ì› ì˜µì…˜ì„ ë²„ë¦¬ê³  ì‹¶ì§€ëŠ” ì•Šì•˜ë‹¤. ì „ë¬¸ì—°ì„ ê³ ë ¤í•˜ì§€ ì•Šì€ ì´ìœ ëŠ” ì™¸êµ­ ëŒ€í•™ì› ì˜µì…˜ì„ ë²„ë¦¬ê³  ì‹¶ì§€ ì•Šì•„ì„œ. ë˜ ê·¸ë ‡ë‹¤ê³  ëŒ€í•™ì›ì„ ê°€ì•¼ê² ë‹¤ëŠ” í™•ì‹ ì´ ë“¤ì§€ ì•ŠëŠ” ìƒí™©ì´ì—ˆë‹¤. ì´ê²ƒì €ê²ƒ ê³ ë¯¼í•˜ë‹¤ë³´ë‹ˆ ë¨¸ë¦¬ê°€ ìƒë‹¹íˆ ë³µì¡í•´ì ¸ì„œ, ì¢‹ì€ ë³´ì§ì— ì„ ë°œë˜ë©´ ê·¸ëƒ¥ ê°€ìëŠ” ê²°ë¡ ì„ ë‚´ë ¸ë‹¤.\n\n## ìœ¡êµ° SW ê°œë°œë³‘ ì§€ì›\n\n2í•™ë…„ ë•Œ ì…ëŒ€ ê³ ë¯¼ì„ í•  ë‹¹ì‹œì—ëŠ” ì´ê±¸ ì§€ì›í•´ì„œ ê°ˆ ìƒê°ì´ì—ˆë‹¤. ì„ ë°œì€ 1ì°¨ ì„œë¥˜ + 2ì°¨ ë©´ì ‘ìœ¼ë¡œ ì´ë£¨ì–´ì¡Œì—ˆë‹¤. 1ì°¨ ì„œë¥˜ëŠ” í•™ë…„ ì ìˆ˜ + ìê²©ì¦ + ê³ êµ ì¶œì„ë¥  3ê°œë¡œ ì´ë£¨ì–´ì ¸ ìˆì—ˆë‹¤. ë‚œ ëª¨ë²”ìƒì´ì—ˆìœ¼ë‹ˆ ê³ êµ ì¶œì„ë¥ ì€ ë¬¸ì œ ì—†ì—ˆê³ , í•™ë…„ì€ ë‚´ê°€ ë‹¹ì¥ ë°”ê¿€ ìˆ˜ ì—†ì—ˆê¸°ì— í•™ë…„ ì ìˆ˜ë„ ê³ ì •ì´ì—ˆë‹¤. ë§ˆì§€ë§‰ ë‚¨ì€ ìê²©ì¦ì˜ ê²½ìš° 10ì ì´ ìµœê³  ì ìˆ˜ì˜€ëŠ”ë°, 10ì ì„ ì£¼ëŠ” ìê²©ì¦ë“¤(ê¸°ì‚¬ê¸‰)ì´ ì—¬ëŸ¬ê°œ ìˆì—ˆê³ , ê·¸ ë‹¤ìŒì´ 8ì (ì‚°ì—…ê¸°ì‚¬ê¸‰), ë§ˆì§€ë§‰ì´ 6ì ì´ì—ˆë‹¤. ë‚œ ìê²©ì¦ì€ ì—†ëŠ” ìƒí™©ì´ì—ˆì–´ì„œ ì£¼ë³€ ì‚¬ëŒë“¤ì´ ë§ì´ ë”°ëŠ” ì •ë³´ì²˜ë¦¬ ìê²©ì¦ì„ ì·¨ë“í•˜ê¸°ë¡œ í–ˆëŠ”ë°, 10ì ì„ ì£¼ëŠ” ì •ë³´ì²˜ë¦¬ê¸°ì‚¬ ìê²©ì¦ì€ ì¡¸ì—…(4í•™ë…„ì´ì—ˆë‚˜?)ì„ í•´ì•¼ ë”¸ ìˆ˜ ìˆê³ , 8ì ì„ ì£¼ëŠ” ì •ë³´ì²˜ë¦¬ì‚°ì—…ê¸°ì‚¬ ìê²©ì¦ì€ 3í•™ë…„ì´ ë¼ì•¼ ë”¸ ìˆ˜ ìˆì—ˆë‹¤. 6ì  ì£¼ëŠ” ê¸°ëŠ¥ì‚¬ ìê²©ì¦ì€ ì´ˆë“±í•™ìƒë„ ë”¸ ìˆ˜ ìˆë˜ ê²ƒ ê°™ë˜ë° ì´ê±¸ë¡œëŠ” ë¶€ì¡±í•  ê²ƒ ê°™ì•˜ë‹¤. ê·¸ë˜ì„œ 3í•™ë…„ ëœ ì§í›„ì— ì •ë³´ì²˜ë¦¬ì‚°ì—…ê¸°ì‚¬ ìê²©ì¦ ë”´ë‹¤ê³  í•„ê¸°ì‹œí—˜ì€ íšŒì‚¬ ë‹¤ë‹ˆë©´ì„œ ê³µë¶€í•˜ê³ , ì‹¤ê¸°ì‹œí—˜ì€ ìˆ˜ìš”ì¼ì— ì¤‘ê°„ê³ ì‚¬ ëë‚˜ê³  ë©°ì¹  ê³µë¶€í•˜ê³ , ì°¸ ë°”ìœ ì‹œê°„ ìª¼ê°œê°€ë©° ê³µë¶€í–ˆëŠ”ë° ì–´ì©Œë‹¤ ì·¨ë“ì€ í–ˆë‹¤.\n\nì•„ë¬´íŠ¼ ë‚´ê°€ ë‹¹ì‹œì— ë‚¼ ìˆ˜ ìˆëŠ” ìµœëŒ€ ì ìˆ˜ë¥¼ ëƒˆëŠ”ë° 1ì°¨ì—ì„œ íƒˆë½í•´ë²„ë ¸ë‹¤. ëª¨ì§‘ ì¸ì›ì€ 3ëª…, 1ì°¨ í†µê³¼ëŠ” 3ë°°ìˆ˜ì˜€ê³ , ë‚´ ì ìˆ˜ëŠ” ì»¤íŠ¸ë³´ë‹¤ 3ì  ë‚®ì•„ì„œ ë–¨ì–´ì¡Œë‹¤. ë‚´ ì ìˆ˜ëŠ” ì„ ë°œ ìˆœìœ„ê°€ 27ìœ„ì˜€ë‹¤. ê·¸ë§Œí¼ 1ì ì”©ì´ ì¤‘ìš”í–ˆë˜ ê²ƒ ê°™ë‹¤. ê·¼ë° í•œì°½ í•™ê¸° ì¤‘ì´ë¼ ë°”ìœ ì‹œê¸°ì˜€ë˜ ê²ƒë„ ìˆì—ˆê³ , ë‚˜ëŠ” ë‚˜ë¦„ ìµœì„ ì„ ë‹¤í–ˆì–´ì„œ ë³„ë¡œ í›„íšŒë˜ê±°ë‚˜ ì•„ì‰¬ìš´ ì ì€ ì—†ì—ˆë‹¤. ëˆ„êµ´ íƒ“í•  ìˆœ ì—†ì—ˆë‹¤.\n\n## í•´êµ° SW ê°œë°œë³‘ ì§€ì›\n\nìœ¡êµ°ì„ ë–¨ì–´ì§€ê³  ë°”ë¡œ í•´êµ°ì„ ë„£ì—ˆë‹¤. í•´êµ°ë„ 1ì°¨ ì„œë¥˜ - 2ì°¨ ë©´ì ‘ ë°©ì‹ìœ¼ë¡œ ì„ ë°œì„ í•˜ëŠ”ë° 1ì°¨ëŠ” ëª¨ë‘ í†µê³¼ì‹œí‚¤ê³  ë©´ì ‘ì„ ë³´ëŠ” ë°©ì‹ì´ì—ˆë‹¤. ë°°ì ì€ ìê²©(30) + ê²½ë ¥(30) + ì „ê³µ(40) + ë©´ì ‘(100)ì´ì—ˆëŠ”ë° ì†”ì§íˆ ëª¨ë¥´ê³  ê·¸ëƒ¥ ë©´ì ‘ë³´ëŸ¬ ê°”ì—ˆë‹¤. ë©´ì ‘ì€ ëŒ€ë©´ìœ¼ë¡œ ëª¨ë“  ëŒ€ìƒìë“¤ì´ ê³„ë£¡ëŒ€ì—ì„œ ë³´ì•˜ë‹¤. ë‚˜ëŠ” í•™êµì— ìˆì—ˆëŠ”ë° ê°€ê¹Œì´ ìˆì–´ì„œ íƒì‹œíƒ€ê³  ê°”ë‹¤. ê·¼ë° **ë©´ì ‘ì„ ë³´ëŠ” ê±´ë¬¼ì´ ì§€ë„ì— ì•ˆ ë‚˜ì˜¤ë‹ˆ ì˜ ì°¾ì•„ê°€ì•¼ í•œë‹¤...**, íƒì‹œì—ì„œ ìƒê°ì—†ì´ ë‚´ë¦¬ê³  ê¸¸ë„ ëª¨ë¥´ê³  ê±¸ì–´ê°€ë‹¤ ëŠ¦ì„ ë»”í–ˆëŠ”ë° ì–´ë–¤ ì€ì¸ì´ ë‚˜íƒ€ë‚˜ì„œ ë©´ì ‘ì¥ê¹Œì§€ íƒœì›Œì£¼ì…¨ë‹¤. ì§„ì§œ ê°ì‚¬í•©ë‹ˆë‹¤...ì´ê±¸ ë³´ì‹œê²Œ ë˜ë©´ ì—°ë½í•´ì£¼ì„¸ìš”. ë³´ìƒì´ë¼ë„ í•´ë“œë¦¬ê³  ì‹¶ìŠµë‹ˆë‹¤.\n\nì„ ë°œì€ 1ëª… ì„ ë°œì´ë¼ ì í˜€ ìˆì—ˆê³ , ë³‘ë¬´ì²­ ì›¹ì‚¬ì´íŠ¸ì—ì„œ ì¡°íšŒí–ˆì„ ë•ŒëŠ” ë‚˜ì˜ 1ì°¨ ì ìˆ˜ëŠ” 3ìœ„, ìµœì¢… ì ìˆ˜ê°€ 1ìœ„ì˜€ë‹¤. ì´ 13~15ëª… ì •ë„ ì§€ì›í–ˆë˜ ê²ƒìœ¼ë¡œ ê¸°ì–µí•œë‹¤. ë‹¤ë§Œ ì§€ì›í•  ë•Œ 1ëª…ë³´ë‹¤ ë§ì´ ë½‘ì„ ìˆ˜ë„ ìˆë‹¤ê³  ì í˜€ ìˆì–´ ì‹¤ì œë¡œ ì–¼ë§ˆë‚˜ ë½‘ì•˜ëŠ”ì§€ëŠ” ëª¨ë¥´ê² ë‹¤.\n\n### ë©´ì ‘ í›„ê¸°\n\në‚˜ì—ê²Œ ë¬¼ì–´ë³´ì‹  ì§ˆë¬¸ë“¤ì„ ì§ì ‘ ì ì„ ìƒê°ì€ ì—†ë‹¤. ëŒ€ì‹  ì–´ë–¤ ëŠë‚Œìœ¼ë¡œ ë‚˜ì™”ëŠ”ì§€ ì„¤ëª…í•˜ê² ë‹¤.\n\n#### ìë£Œë¥¼ ì„±ì‹¬ì„±ì˜ê» ì¤€ë¹„í•˜ì\n\në‚˜ëŠ” ì´ ìë£Œë¡œë¶€í„° ë‚˜ì˜¤ëŠ” ì§ˆë¬¸ì´ ë§ì•˜ë‹¤. ê³ ì •ì§ˆë¬¸ì´ë‘ ë¹„ìŠ·í•œ ìˆ˜ì˜ ì§ˆë¬¸ì„ í•˜ì‹  ê²ƒ ê°™ë‹¤. ê·¸ë§Œí¼ ì£¼ì˜ê¹Šê²Œ ì´ ìë£Œë¥¼ ë³´ì‹œë‹ˆ ì¤€ë¹„ë¥¼ ì˜í•˜ì!\n\në§¤ìˆ˜ ë˜í•œ ë„‰ë„‰í•˜ê²Œ ì¶œë ¥í•´ê°€ëŠ” ê²ƒì´ ì¢‹ë‹¤. ë‚˜ëŠ” í‰ì†Œì— ì •ë§ ìƒê°ì´ ì—†ëŠ” í¸ì´ë¼ í•œ ì¥ë§Œ ë½‘ì•˜ì—ˆëŠ”ë° ìš´ì´ ì¢‹ê²Œë„ ì—¬ëŸ¬ ê°œ ë½‘ì„ ìƒê°ì„ í–ˆì—ˆë‹¤. ë©´ì ‘ ë³´ëŸ¬ ë“¤ì–´ê°€ë‹ˆ ë©´ì ‘ê´€ì´ í•œ ë¶„ë³´ë‹¤ ë§ì´ ê³„ì…”ì„œ ë‹¤í–‰ì´ í•œ ë¶€ì”© ë“œë¦´ ìˆ˜ ìˆì—ˆë‹¤.\n\nìš°ì„  1ì°¨ë¥¼ í†µê³¼í•˜ê³ (2021ë…„ë„ ê¸°ì¤€ 100%) í¬íŠ¸í´ë¦¬ì˜¤ë‚˜ ìê¸°ì†Œê°œì„œ ë“±ì˜ ìë£Œë¥¼ ììœ ë¡­ê²Œê³  ì§€ì°¸í•˜ë¼ëŠ” ì—°ë½ì„ ë°›ì•˜ë‹¤. ê·¼ë° ë‚˜ëŠ” ë‘˜ ë‹¤ ì—†ëŠ” ìƒí™©ì´ì—ˆë‹¤. ì‚¬ì‹¤ ë°˜ë…„ ì „ì— íšŒì‚¬ ì¸í„´ ì§€ì›í•˜ë©´ì„œ ì‘ì„±í•œ ê²Œ ìˆì—ˆëŠ”ë° ì •ë§ í¸í•œ ëŠë‚Œìœ¼ë¡œ ì¨ë†“ì€ ê±°ë¼ ê·¸ëŒ€ë¡œ ë‚´ê¸°ì—ëŠ” ë¶€ë‹´ìŠ¤ëŸ¬ì› ë‹¤. ê·¸ë˜ì„œ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‘ì„±í–ˆë‹¤. ì–´ë–¤ ë‚´ìš©ì„ ë„£ì„ì§€ëŠ” ê³ ë¯¼ì„ ë§ì´ í•œ ë¶€ë¶„ì´ë‹¤. ë‚˜ëŠ” `ì§§ì€ ì†Œê°œ + ê²½ë ¥ + í”„ë¡œì íŠ¸ ê²½í—˜ + ë³´ìœ ê¸°ìˆ  + ì–´í•™ëŠ¥ë ¥ + êµìœ¡ + ê¸°íƒ€ í™œë™`ìœ¼ë¡œ êµ¬ì„±í–ˆë‹¤. ê·¸ëƒ¥ ë‚´ ë§ˆìŒëŒ€ë¡œ ë§Œë“  êµ¬ì„±ì´ë‹ˆ ë”°ë¼í• ê±°ë©´ ìœ„í—˜ì€ ì•Œì•„ì„œ ê°ìˆ˜í•˜ë„ë¡.\n\ní¬íŠ¸í´ë¦¬ì˜¤ë¼ëŠ” ë§ì„ ëª°ë¼ ì·¨ì—…í•œ í˜•ì—ê²Œ ë¬¼ì–´ë³´ë‹ˆ ë³´í†µ PPT í˜•íƒœë¼ê³  í•˜ë˜ë°, ì–´ë–»ê²Œ ê°€ì ¸ì˜¤ë¼ëŠ” ê±´ì§€ ì•½ê°„ ì˜ë¬¸ì´ì–´ì„œ ê·¸ëƒ¥ ë¬¸ì„œ í˜•ì‹ìœ¼ë¡œ ì‘ì„±í•´ê°”ì—ˆë‹¤. ê°€ë³´ê³  ë‚˜ë‹ˆ ê·¸ë ‡ê²Œ ì¤€ë¹„í•´ê°€ê¸¸ ì˜í–ˆë‹¤. ê°€ì„œ ë³´ë‹ˆ ë””ì§€í„¸ë¡œ ë°œí‘œë¥¼ í•  í™˜ê²½ì€ ì•„ë‹ˆì—ˆë‹¤. ë¬¼ë¡  ë‘˜ ë‹¤ ì¤€ë¹„ë¥¼ í•˜ë©´ ìµœê³ ê² ë‹¤. ë‚˜ëŠ” ì‹œê°„ì— ì«“ê²¨ ì¤€ë¹„í–ˆì—ˆê¸° ë•Œë¬¸ì—..\n\n#### ê¸°ë³¸ì ì¸ ì¡°ì‚¬ëŠ” í•˜ì\n\nêµ°ë©´ì ‘ì˜ ì„±ê²©ì„ ë¤ ì§ˆë¬¸ë“¤ë„ ë§ì´ í•˜ì‹ ë‹¤. ëŒ€í•œë¯¼êµ­ êµ°ëŒ€ì™€ ì—­ì‚¬ì— ëŒ€í•´ ìµœì†Œí•œìœ¼ë¡œëŠ” ì•Œì•„ê°€ë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤. ë‚˜ëŠ” í•´êµ°ì— ì§€ì›í–ˆê¸°ì— í•´êµ°ê³¼ ê´€ë ¨ëœ ì§€ì‹ì„ ì¢€ ìŒ“ê³  ê°€ëŠ” ê²ƒë„ ì¢‹ì„ ê²ƒì´ë‹¤.\nì´ì™¸ì—ë„ ë¶€ëŒ€ ë‚´ì—ì„œì˜ ìƒí™©ì„ ì£¼ì‹œê³  ì´ëŸ° ìƒí™©ì—ì„œ ì–´ë–»ê²Œ í–‰ë™í•  ê²ƒì¸ì§€ì— ê´€í•œ ì§ˆë¬¸ë“¤ ë˜í•œ í•˜ì‹ ë‹¤. ì—¬ëŸ¬ ê°€ì§€ ìƒí™©ì„ ì¤€ë¹„í•´ê°€ëŠ” ê²ƒë„ ë°©ë²•ì¼ ê²ƒ ê°™ë‹¤. ë‚˜ëŠ” ì•½ê°„ ìƒì†Œí•œ ìƒí™©ì„ ì§ˆë¬¸í•˜ì…”ì„œ ë‚´ í‰ì†Œ ê°€ì¹˜ê´€ì´ë‘ ë¶€ì¡±í•œ ìˆœë°œë ¥ì— ì˜ì§€í•´ì„œ ëŒ€ë‹µì„ ë“œë ¤ì•¼ í–ˆë‹¤.\n\në‚´ê°€ ì‹œê°„ì´ ì§€ë‚˜ë©´ ìœ„ ë‚´ìš©ë“¤ì„ ìŠì„ ê²ƒ ê°™ì•„ ê¸€ì„ ì‘ì„±í•˜ê¸°ë„ í–ˆì§€ë§Œ í•´êµ° ê°œë°œë³‘ì— ì§€ì›í•  ë•Œ í›„ê¸°ê°€ ì „í˜€ ì—†ì–´ ì¤€ë¹„í•˜ê¸°ê°€ ì¡°ê¸ˆ ì–´ë ¤ì›Œì„œ ëˆ„êµ°ê°€ ì´ ê¸€ì„ ë³´ê³  ì¡°ê¸ˆ ë” ìˆ˜ì›”í•˜ê²Œ ì¤€ë¹„í–ˆìœ¼ë©´ í•˜ëŠ” ë§ˆìŒë„ ìˆë‹¤. ì§€ê¸ˆ ì œ ë¸”ë¡œê·¸ê°€ ë°”ë‹¥ë¶€í„° ë§Œë“ ê±°ë¼ ëŒ“ê¸€ ê¸°ëŠ¥ì´ ì—†ëŠ”ë°, ì¶”ê°€ ë¬¸ì˜ì‚¬í•­ì´ ìƒê¸°ë©´ ë©”ì¼ë¡œ ë¬¸ì˜ë¥¼ ì£¼ì‹œê±°ë‚˜ ë³´ì‹¤ ì ì— ëŒ“ê¸€ ê¸°ëŠ¥ì´ ìˆìœ¼ë©´ ëŒ“ê¸€ ë‹¬ì•„ì£¼ì„¸ìš”:)\n","title":"í•´êµ° SW ê°œë°œë³‘ ì§€ì› í›„ê¸°","tags":["general","diary","military","ko"],"date":"2021-08-31"},{"id":"20210829-genesis","content":"\n## Hello World!\n\në¸”ë¡œê·¸ë¥¼ ì‹œì‘í•˜ê²Œ ë˜ì—ˆë‹¤.\n\në¸”ë¡œê·¸ ìš´ì˜ì€ ê±°ì˜ ì˜¬í•´ ì´ˆë¶€í„° í•´ë³´ê³  ì‹¶ì—ˆëŠ”ë°, ë³¸ì—… ë•Œë¬¸ì— ì‹œê°„ì´ ë¶€ì¡±í•˜ë‹¤ëŠ” ë³€ëª…ì„ ìŠ¤ìŠ¤ë¡œì—ê²Œ í•˜ë©° ì‹œì‘í•˜ì§€ ì•Šê³  ìˆì—ˆë‹¤... ë‚˜ëŠ” \"From Scratch\"ë¥¼ êµ‰ì¥íˆ ì¢‹ì•„í•˜ëŠ” í¸ì´ë¼ ë¸”ë¡œê·¸ë„ í…œí”Œë¦¿ì— ì˜ì¡´í•˜ì§€ ì•Šê³  ì§ì ‘ ë§Œë“¤ì–´ì•¼ í•œë‹¤ëŠ” ìƒê° ë•Œë¬¸ì— ì‹œì‘í•˜ëŠ”ë° ì¡°ê¸ˆ ì¥ë²½ì´ ë˜ì—ˆì„ ìˆ˜ë„ ìˆì—ˆì„ ê²ƒ ê°™ë‹¤ëŠ” ìƒê°ì´ ë“ ë‹¤.\n\n21ë…„ ì—¬ë¦„ì—ëŠ” ë³¸êµ PLRGì—ì„œ ê°œë³„ì—°êµ¬ë¥¼ í–ˆëŠ”ë°, ë© ë¯¸íŒ… ë•Œ êµìˆ˜ë‹˜ê»˜ì„œ \"í‰ì†Œì— ê¸€ì„ ì“°ëŠ” ìŠµê´€ì„ ë“¤ì´ëŠ” ê²ƒì´ ì¢‹ë‹¤\"ë¼ëŠ” ë§ì”€ì„ í•˜ì‹  ê²ƒì„ ë“£ê³  ì¡°ê¸ˆ ë” ë™ê¸°ë¶€ì—¬ê°€ ë˜ì—ˆë˜ ê²ƒ ê°™ë‹¤. ì–¼ë§ˆ ë’¤ì¸ì§€ë¶€í„°ëŠ” ëª¨ë¥´ê² ëŠ”ë° ì•„ë¬´íŠ¼ ë¸”ë¡œê·¸ ê°œë°œì„ ì‹œì‘í–ˆê³ , ì†Œê°œ, bio, ê·¸ë¦¬ê³  ê²Œì‹œê¸€ ì¡°íšŒ ê¸°ëŠ¥ì„ ë§Œë“  ë’¤ì— ì´ ê¸€ì„ ì‘ì„±í•˜ê³  ìˆë‹¤.\n\në™ê¸°ë¶€ì—¬ê°€ ë˜ì—ˆë˜ ë˜ ë‹¤ë¥¸ ì¼ì€ ì…ëŒ€ê°€ ì–¼ë§ˆ ì•ˆ ë‚¨ì•˜ë‹¤ëŠ” ì ì´ë‹¤. ì´ ì´ì•¼ê¸°ëŠ” ë³„ë„ì˜ ê¸€ì— ë” ìì„¸í•˜ê²Œ ë‹´ê² ì§€ë§Œ, ë¶ˆê³¼ ì´í‹€ ì „ì— í•´êµ° SW ê°œë°œë³‘ì— í•©ê²©í–ˆëŠ”ë°, í•œ ëª… ë½‘ëŠ” ë³´ì§ì´ë‹¤ ë³´ë‹ˆ ë  ê¸°ëŒ€ë¥¼ í¬ê²Œ ì•ˆí•˜ê³  ìˆì—ˆì–´ì„œ ì…ì˜ ë‚ ì§œë¥¼ ëª¨ë¥´ê³  ìˆì—ˆë‹¤. ì•Œê³  ë³´ë‹ˆ 10ì›” 5ì¼ ì…ì˜ì´ì—ˆê³  ë°±ì‹  ë¬¸ì œ ë•Œë¬¸ì— ì •í™•íˆ ê·¸ë•Œ ê°ˆì§€ëŠ” ëª¨ë¥´ê² ì§€ë§Œ ì‹œê°„ì´ í•œ ë‹¬...ì •ë„ë°–ì— ë‚¨ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—, ì‹œê°„ì´ ìˆì„ ë•Œë¼ë„ ì¢€ ì •ë¦¬ë¥¼ í•˜ê³  ê°€ì•¼ê² ë‹¤ëŠ” ìƒê°ì„ í–ˆë‹¤. ë¬¼ë¡  ì•„ì§ ë‚¨ì€ ì‹œê°„ë™ì•ˆ ì–´ë– í•œ ì¼ì„ í• ì§€ ì œëŒ€ë¡œ ìƒê°ì„ ëª»í•´ë´¤ëŠ”ë°, ìµœëŒ€í•œ ë¸”ë¡œê·¸ ì •ë¦¬ë¥¼ í•˜ê³  ê°ˆ ìˆ˜ ìˆì—ˆìœ¼ë©´ í•œë‹¤.\n\në¸”ë¡œê·¸ ê²Œì‹œê¸€ë“¤ì€ ë‚¨ì´ ë³¼ ê²ƒì´ë¼ê³  ê¸°ëŒ€í•˜ì§€ëŠ” ì•Šê³  ì˜¤íˆë ¤ ê°œì¸ ì¼ê¸° ëŠë‚Œì— ê°€ê¹ë„ë¡ í¸í•˜ê²Œ ì ì„ ê²ƒ ê°™ì€ë°, ë˜ ë‚˜ë§Œ ì•Œì•„ë“¤ì„ ìˆ˜ ìˆë„ë¡ ì ì§€ëŠ” ì•Šì„ ìƒê°ì´ë‹¤. ì£¼ ë‚´ìš©ì€ ë‚´ê°€ í‰ì†Œì— ê´€ì‹¬ìˆë˜ í¸ì§‘ê¸° ì´ì•¼ê¸° ë° ê°œë°œì„ ë°°ìš°ë©´ì„œ ì‚¬ì†Œí•˜ê²Œ ë°°ì› ë˜ ê²ƒë“¤ì„ ì ì„ ê²ƒ ê°™ë‹¤! ë˜ ì˜ˆì „ë¶€í„° ê°œì¸ ë…¸ì…˜ì´ë‚˜ `vimwiki` ë“± ì—¬ê¸°ì €ê¸° ì ì–´ëŠ” ë†“ì•˜ëŠ”ë° ì •ë¦¬ê°€ ì•ˆëœ ìë£Œë“¤ë„ ê³¼ê±° ì‘ì„± ë‚ ì§œì— ë§ì¶° ì—…ë¡œë“œí•  ìƒê°ì´ë‹¤.\n","title":"ë¸”ë¡œê·¸ ê°œì—…!","tags":["general","diary","ko"],"date":"2021-08-29"},{"id":"20200711-esModuleInterop-in-tsconfig","content":"\nWhy is it that different patterns of imports are shown across typescript examples?\n\n```typescript\nimport * as React from 'react';\nimport React from 'react';\n```\n\nLet us look at how the two examples are compiled to javascript code using `tsc`.\n\nFirst, intialize a project with the following commands:\n\n```bash\nmkdir esminterop-example && cd esminterop-example   # create project directory\nyarn init -y                                        # initialize npm project\nyarn add react                                      # add react package (opt.)\nyarn add -D typescript @types/node @types/react     # add typescript compiler and type definitions (req.)\ntouch star.ts plain.ts\n```\n\nFill in the files `star.ts` and `plain.ts` with the following code:\n\n`star.ts`\n\n```typescript\nimport * as React from 'react';\nconsole.log(React);\n```\n\n`plain.ts`\n\n```typescript\nimport React from 'react';\nconsole.log(React);\n```\n\nFirst, let's compile `star.ts` with `tsc` and see the output.\n\n```bash\nnpx tsc star.ts\n```\n\n`star.js`\n\n```javascript\n'use strict';\nexports.__esModule = true;\nvar React = require('react');\nconsole.log(React);\n```\n\nAll good. Now try to compile `plain.ts`, and an error will occur.\n\n```bash\nnpx tsc plain.ts\n\nplain.ts:1:8 - error TS1259: Module '\"/Users/pacokwon/workspace/esminterop-example/node_modules/@types/react/index\"' can only be default-imported using the 'esModuleInterop' flag\n\n1 import React from 'react';\n         ~~~~~\n\n  node_modules/@types/react/index.d.ts:65:1\n    65 export = React;\n       ~~~~~~~~~~~~~~~\n    This module is declared with using 'export =', and can only be used with a default import when using the 'esModuleInterop' flag.\n\n\nFound 1 error.\n```\n\nThe problem occurs because while `react` does not have a default export, our typescript file is attempting to default import it. One way of solving this issue might be to use the wildcard(asterisk) import above. Another way is to use the `--esModuleInterop` flag. Now let's see how the latter way works, by using that flag in our compiler.\n\n```bash\nnpx tsc --esModuleInterop plain.ts\n```\n\nThere are no errors, which is a good thing. The compiled file looks like this:\n\n```javascript\n'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nexports.__esModule = true;\nvar react_1 = __importDefault(require('react'));\nconsole.log(react_1['default']);\n```\n\nOne can find out that a wrapper to the require is added. The wrapper provides additional logic, that allows flexible resolution between es6 modules and commonjs modules. It can also be observed that a \"default\" export or import is, from a commonjs module point of view, the value that corresponds to the key `\"default\"` in the `module.exports` object.\n\nAFAIK, javascript packages are usually shipped with the original source code transpiled into using commonjs modules, so the `esModuleInterop` flag is a flag that I commonly use in my `tsconfig.json`.\n","title":"Understanding the esModuleInterop option in tsconfig.json","tags":["typescript","quicknote","en"],"date":"2020-07-11"},{"id":"20200605-spellchecking-in-vim","content":"\nJust until stumbling upon some random video on youtube about spellchecking in Vim, I didn't know such capability even existed in Vim. Turns out that you can, and it can be utilized in markdown files, commit messages and etc. This post is a demonstration of how you can enable and utilize spellchecking in Vim.\n\n## Enabling Spellchecking in Vim\n\n```vim\n:set spell spellang=en_us \" use english dictionary for spellchecking\n```\n\nTo only set it for local buffers, use:\n\n```vim\n:setlocal spell spelllang=en_us\n```\n\nI utilize this primarily in autocmds, like this:\n\n```vim\nautocmd BufRead,BufNewFile *.md setlocal spell spelllang=en_us \" enable spellchecking in markdown files\nautocmd FileType gitcommit setlocal spell spelllang=en_us \" enable spellchecking in git commit files\n```\n\nOnce you have these set up, words that are recognized by the spellchecker will be highlighted according to the highlight groups `SpellBad`, `SpellCap`, `SpellRare`, `SpellLocal`. For further reference, consulting the `:help spell-quickstart` docs will come in handy. In my neovim setup, the words are shown underlined (Not exactly sure where it comes from).\n\n## Utilizing it\n\nOne can get recommendations from the spellchecker from the completion engine. Run `set complete+=kspell`, as in:\n\n```vim\nautocmd FileType gitcommit setlocal spell spelllang=en_us | set complete+=kspell\n```\n\nOne can navigate between recommendations in insert mode using `^N` and `^P`, and spellchecking recommendations will show up among the options.\n\nHere are some commands I found useful:\n\n- `]s` and `[s`: navigate between misspelled words. Former moves forward, the latter backwards.\n- `z=`: see alternatives to the word under the cursor. For example, if I write `file` and run `z=` on it, it will recommend a list of words from the dictionary.\n- `zg`: register a word as correct in the dictionary. The Vim dictionary does not know a lot of words, so it will mark a lot of words as incorrect. One way to solve that issue is to register a word to the dictionary. This command does that.\n- `zw`: just like `zg`, but marks a word as incorrect.\n\nFor more, as always, consult the helpdocs. For spellchecking, `:help spell` is where you should go to.\n","title":"Spellchecking in Vim / Neovim","tags":["vim","neovim","quicknote","en"],"date":"2020-06-05"}]},"__N_SSG":true}