{"pageProps":{"post":{"id":"20210913-destructuring-refs-in-rust","content":"\nWhile teaching myself some Rust, it was common to see some code that \"looked like\" it was destructuring references, like:\n\n```rust\nfn main() {\n    let vec = vec![1, 2, 3];\n    let mut iter = vec.into_iter();\n\n    println!(\"Find 2 in vec: {:?}\", iter.find(|&x| x == 2)); // Find 2 in vec: Some(2)\n}\n```\n\nAt first glance, the semantics were a little hard to predict. My curiosity all came down to this: does this copy the whole value? So I decided to write some code to make things clear.\n\n```rust\n#[derive(Debug,Clone,Copy)]\nstruct Foo {\n    a: u32,\n    b: u32,\n}\n\nfn main() {\n    let mut x = Foo { a: 3, b: 4 };\n    let &mut mut y = &mut x;        // destructure mutable reference, AND the variable is mutable\n    y.a = 50;\n    println!(\"{:?} {:?}\", x, y);    // ??\n}\n```\n\n### Output:\n\n```bash\nFoo { a: 3, b: 4 } Foo { a: 50, b: 4 }\n```\n\nA pretty minimal example here, but the syntax looks real weird. I actually had a hard time trying to express what I wanted to because of the syntax.\n\nOnce we try to mutate the struct's field, the output shows that only `y` is mutated. It shows us that it indeed copies the whole value.\n\nWhat if we try to destructure something that does not implement the `Copy` trait, like a vector?\n\n```rust\nfn main() {\n    let mut x = vec![1, 2, 3];\n    let &mut mut y = &mut x;\n    println!(\"{:?}\", y);\n}\n```\n\n### Output:\n\n```bash\nerror[E0507]: cannot move out of a mutable reference\n  --> src/main.rs:10:22\n   |\n10 |     let &mut mut y = &mut x;\n   |         ----------   ^^^^^^\n   |         |    |\n   |         |    data moved here\n   |         |    move occurs because `y` has type `Vec<i32>`, which does not implement the `Copy` trait\n   |         help: consider removing the `&mut`: `mut y`\n\nerror: aborting due to previous error; 1 warning emitted\n```\n\nPretty much the same example except that it's a vector, but the compiler complains for the exact reason why we tried this example in the first place. The destructure does not work because the `Vec` struct does not implement `Copy`. What I've understood from these examples, is that such destructuring is meant to be used on types that support cheap copying.\n\n## References\n\n- https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_pointers.html\n","title":"Destructuring & References in Rust","tags":["rust","quicknote","en"],"date":"2021-09-13"}},"__N_SSG":true}