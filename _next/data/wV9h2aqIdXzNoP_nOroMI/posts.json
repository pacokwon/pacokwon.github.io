{"pageProps":{"posts":[{"id":"20210913-destructuring-refs-in-rust","content":"\nWhile teaching myself some Rust, it was common to see some code that \"looked like\" it was destructuring references, like:\n\n```rust\nfn main() {\n    let vec = vec![1, 2, 3];\n    let mut iter = vec.into_iter();\n\n    println!(\"Find 2 in vec: {:?}\", iter.find(|&x| x == 2)); // Find 2 in vec: Some(2)\n}\n```\n\nAt first glance, the semantics were a little hard to predict. My curiosity all came down to this: does this copy the whole value? So I decided to write some code to make things clear.\n\n```rust\n#[derive(Debug,Clone,Copy)]\nstruct Foo {\n    a: u32,\n    b: u32,\n}\n\nfn main() {\n    let mut x = Foo { a: 3, b: 4 };\n    let &mut mut y = &mut x;        // destructure mutable reference, AND the variable is mutable\n    y.a = 50;\n    println!(\"{:?} {:?}\", x, y);    // ??\n}\n```\n\n### Output:\n\n```\nFoo { a: 3, b: 4 } Foo { a: 50, b: 4 }\n```\n\nA pretty minimal example here, but the syntax looks real weird. I actually had a hard time trying to express what I wanted to because of the syntax.\n\nOnce we try to mutate the struct's field, the output shows that only `y` is mutated. It shows us that it indeed copies the whole value.\n\nWhat if we try to destructure something that does not implement the `Copy` trait, like a vector?\n\n```rust\nfn main() {\n    let mut x = vec![1, 2, 3];\n    let &mut mut y = &mut x;\n    println!(\"{:?}\", y);\n}\n```\n\n### Output:\n\n```\nerror[E0507]: cannot move out of a mutable reference\n  --> src/main.rs:10:22\n   |\n10 |     let &mut mut y = &mut x;\n   |         ----------   ^^^^^^\n   |         |    |\n   |         |    data moved here\n   |         |    move occurs because `y` has type `Vec<i32>`, which does not implement the `Copy` trait\n   |         help: consider removing the `&mut`: `mut y`\n\nerror: aborting due to previous error; 1 warning emitted\n```\n\nPretty much the same example except that it's a vector, but the compiler complains for the exact reason why we tried this example in the first place. The destructure does not work because the `Vec` struct does not implement `Copy`. What I've understood from these examples, is that such destructuring is meant to be used on types that support cheap copying.\n\n## References\n\n- https://doc.rust-lang.org/rust-by-example/flow_control/match/destructuring/destructure_pointers.html\n","title":"Destructuring & References in Rust","tags":["rust","quicknote","en"],"date":"2021-09-13"},{"id":"20210911-simple-state-transformer-monad","content":"\n_This post is based on [this video](https://www.youtube.com/watch?v=WYysg5Nf7AU) from Graham Hutton's playlist on advanced functional programming. I tried to write this post without rewatching the video, to deliver my own understanding of the concept._\n\n## Defining `StateT`\n\nState를 표현하는 어떤 값이 있을 때, 이 state를 변경시키는 어떤 black box가 있다고 하자. 그 black box는 이렇게 표현할 수 있을 것 같다.\n\n```haskell\nblack_box :: a -> a -- where a denotes the state's type\n```\n\n이때 black box에서 input으로 들어온 state를 이용해 어떤 값을 계산한다고 가정한다면, 현재 함수의 타입 정보로는 해당 결과를 잘 표현하기 어렵다. 따라서 output을 두 개 돌려주는 다음과 같은 타입이 더 편리하다.\n\n```haskell\nblack_box :: a -> (b, a) -- where a denotes the state's type, and b the return value's type\n```\n\n이러한 black box를 `state transformer (StateT)` 이라고 부르기로 하고, 그에 해당하는 새로운 타입을 다음과 같이 작성해보자. Record에 대해 매번 pattern match를 하는 것을 방지하기 위해, `StateT`와 state 값이 주어졌을 때, transformer를 호출해주는 helper 또한 정의하자.\n\n```haskell\nnewtype StateT a b = S {getStateT :: a -> (b, a)}\n\nrunStateT :: StateT a b -> a -> (b, a)\nrunStateT S {getStateT = f} = f\n```\n\n0부터 시작하는 id를 생성하는 함수가 있다고 하자. 이러한 상황에서는 ST를 다음과 같이 표현하여 id를 뽑아낼 수 있을 것이다.\n\n```haskell\n-- Plain.hs\nnext :: StateT Int Int\nnext = S $ \\n -> (n, n + 1)\n\nmain :: IO ()\nmain = do\n    let n0 = 0\n    let (id, n)     = runStateT next n0\n    let (id', n')   = runStateT next n\n    let (id'', n'') = runStateT next n'\n    print id        -- 0\n    print id'       -- 1\n    print id''      -- 2\n    print n''       -- 3\n```\n\n`next` 라는 state transformer를 사용하면 id를 하나 생성하고 state를 하나 증가시키는 것을 확인할 수 있다. 따라서 `id`, `id'`, `id''`등 `next` ST에 새로운 state를 input으로 넣어 생성한 id들은 각각 0, 1, 2, 3의 값을 가지게 된다.\n\n## 기존 방식의 문제점과 `bind` 함수\n\n위 코드에서 문제점이 있다고 할 수 있는 부분은 composition이 불편하다는 점이다. `runStateT` 는 새로운 state를 만들어 내기 때문에, 이 함수를 여러 번 호출해야 하는 상황에서는 최신 state를 잘 넘겨주도록 유의해야 한다. 이를 위해 매번 pattern match를 해야 하고, 매번 state를 explicit하게 넘겨주어야 한다. 흐름 상으로만 보면 반복되는 코드인데 필요는 하기 때문에 일종의 boilerplate인 것이다. 이는 코드를 작성할 때 error prone하고, 읽을 때도 불필요한 디테일이다. 다음과 같은 문제점을 monad를 통해 해결해보자!\n\n먼저 `bind` 함수를 정의해보자. `bind` 의 타입은 다음과 같다.\n\n```haskell\nbind :: m a -> (a -> m b) -> m b\n```\n\n이때 `m` 은 type constructor으로, 현재 상황의 경우 `StateT s` 에 해당한다.\n\n```haskell\nbind :: StateT s a -> (a -> StateT s b) -> StateT s b\n```\n\nstate transformation을 두 번 시행함으로써 구현할 수 있다.\n\n```haskell\nbind :: StateT s a -> (a -> StateT s b) -> StateT s b\nbind sa f = S $ \\s ->\n  let (a, s') = runStateT sa s in runStateT (f a) s'\n```\n\n이 함수만 있어도 composition이 더 깔끔해진다. 위에 있는 `main` 함수를 리팩토링해보자.\n\n```haskell\n-- Bind.hs\nnext :: StateT Int Int\nnext = S $ \\n -> (n, n + 1)\n\nmain :: IO ()\nmain = fst $ runStateT (\n    next `bind` \\id ->\n    next `bind` \\id' ->\n    next `bind` \\id'' ->\n    S $ \\s -> (\n      do\n        print id\n        print id'\n        print id'',\n      s\n    ))\n  0\n```\n\n(표준 출력을 위한 IO 조작 코드가 있는데...무시하고 보자)\n\n`runStateT` 의 첫 번째 인자로 넘겨진 `StateT` 코드와, 위에 있는 리팩토링 이전 코드를 비교했을 때, trivial한 state 관리 코드가 아예 사라진 것을 확인할 수 있다. composition을 위해 매번 새로운 state를 다음 호출에 넘겨주던 패턴을 `bind` 라는 함수 안에 넣어두었기 때문에 핵심 코드가 더욱 중점적으로 드러나게 되었다.\n\n이 `bind` 라는 함수는 `Monad` 타입클래스에 `(>>=)` 라는 함수의 형태로 존재한다. `StateT` 를 `Monad` 타입클래스의 인스턴스로 만들면 `do` notation의 syntactic sugar 또한 사용할 수 있게 된다. 다만 `Monad` 타입클래스의 인스턴스로 만들기 위해서는 그 superclass인 `Applicative` 까지 구현을 해야 하고, `Applicative` 의 superclass인 `Functor` 까지 구현해야 한다. 구현 코드는 다음과 같이 작성할 수 있다.\n\n```haskell\nimport Control.Applicative\n\n-- a type that contains a state transformer\n-- the state transformer accepts a state, and returns a state with some return value\nnewtype StateT a b = S {getStateT :: a -> (b, a)}\n\nrunStateT :: StateT a b -> a -> (b, a)\nrunStateT S {getStateT = f} = f\n\ninstance Functor (StateT a) where\n  -- fmap :: (a -> b) -> StateT s a -> StateT s b\n  fmap f (S transform) = S (\\s -> let (r, s') = transform s in (f r, s'))\n\ninstance Applicative (StateT a) where\n  -- pure :: a -> StateT s a\n  pure x = S $ \\s -> (x, s)\n\n  -- (<*>) :: StateT s (a->b) -> StateT s a -> StateT s b\n  sf <*> sa = S $ \\s ->\n    let (f', s') = runStateT sf s\n     in runStateT (f' `fmap` sa) s'\n\ninstance Monad (StateT a) where\n  -- (>>=) :: StateT s a -> (a -> StateT s b) -> StateT s b\n  (S f) >>= t = S $ \\s ->\n    let (a, s') = f s in runStateT (t a) s'\n```\n\n이제 `do` notation을 이용해 코드를 2차로 리팩토링해보자.\n\n```haskell\nnext :: StateT Int Int\nnext = S $ \\n -> (n, n + 1)\n\nmain :: IO ()\nmain = fst $ runStateT (\n  do\n    id <- next\n    id' <- next\n    id'' <- next\n    S $ \\s ->\n      ( do\n          print id\n          print id'\n          print id'',\n        s\n      )\n  )\n  0\n```\n\n`bind` 호출이 없으니 조금 더 간결해졌다. 마지막으로, `StateT` monad를 사용하는 코드를 분리하여 리팩토링을 해보자.\n\n```haskell\n-- Main.hs\nnext :: StateT Int Int\nnext = S $ \\n -> (n, n + 1)\n\nnextThree :: StateT Int (Int, Int, Int)\nnextThree = do\n  id <- next\n  id' <- next\n  id'' <- next\n  return (id, id', id'')\n\ngetThreeIds :: Int -> (Int, Int, Int)\ngetThreeIds start = fst $ runStateT nextThree start\n\nmain :: IO ()\nmain = do\n  let (id, id', id'') = getThreeIds 0\n  print id\n  print id'\n  print id''\n```\n\n특히 처음에 비하면 코드가 훨씬 간결해진 것을 확인할 수 있다.\n\n## Tree Labeling\n\n해당 monad를 또 다른 예시에 적용해보자. 이는 위에 언급된 동영상에 있는 예시이기도 하다.\n\n```haskell\ndata Tree a = Leaf a | Node (Tree a) (Tree a) deriving Show\n```\n\n다음과 같은 트리 자료구조가 있을 때, 각각 leaf마다 숫자 id를 붙여 `label`하는 함수를 작성해보자. 먼저 monad 없이 매뉴얼하게 작성해보자.\n\n```haskell\nlabel :: Tree a -> Int -> (Tree Int, Int)\nlabel (Leaf v) n = (Leaf n, n + 1)\nlabel (Node l r) n = (Node l' r', n'')\n  where\n    (l', n') = label l n\n    (r', n'') = label r n'\n```\n\n이 함수는 state를 관리한다. 그 다음에 사용할 id인 `n`이다. 함수를 pure하게 유지하기 위해서는 바늘구멍에 실 궤매듯이 이 state를 계속 들고 다녀야 한다.그럼 위에서 만든 `StateT` 를 이용하여 같은 코드를 작성해보자.\n\n```haskell\nmlabel :: Tree a -> StateT Int (Tree Int)\nmlabel (Leaf v) = do\n  n <- next\n  return (Leaf n)\n\nmlabel (Node l r) = do\n  l' <- mlabel l\n  r' <- mlabel r\n  return (Node l' r')\n```\n\n실 꿰매듯 state를 운반하는 코드는 더이상 보이지 않는다. 이 함수는 이렇게 사용할 수 있을 것이다.\n\n```haskell\n-- Tree.hs\ntestTree :: Tree String\ntestTree = Node (Leaf \"foo\") (Node (Leaf \"bar\") (Leaf \"baz\"))\n\nmain :: IO ()\nmain = do\n  let labeled = fst $ runStateT (mlabel testTree) 0\n  print labeled\n```\n\n(`runStateT` 랑 0이 불편하면 다른 함수로 만들어두면 된다...여기선 생략한다)\n\n이로써 순수 함수형 언어인 haskell에서 monad를 통해 state를 깔끔하게 처리하는 방법을 알아보았다! 글을 쓰며 나 역시 많이 배운 것 같다. 이 게시글에서 사용한 코드는 [이 레포](https://github.com/pacokwon/simple-statet-monad-demo)에 업로드되어있다!\n","title":"Simple State Transformer Monads in Haskell with Examples","tags":["haskell","ko"],"date":"2021-09-11"},{"id":"20210909-chip8-emulator-in-rust","content":"\nRust로 뭔가는 만들어보고 싶은데 마침 에뮬레이터도 만들어보고 싶어서 입문용 프로젝트로 많이 한다는 Chip-8 에뮬레이터를 작성해보려고 한다. 아직 시작도 안했기 때문에 여기 적을 내용은 많지 않다. 이 포스트를 업데이트해가며 짜려고 한다.\n\n## TODO\n\n- [ ] Design CPU Struct\n- [ ] Implement Opcodes\n- [ ] Choose graphics library & integrate with project\n","title":"Building a Chip-8 Emulator in Rust","tags":["rust","emulator","en"],"date":"2021-09-09"},{"id":"20210903-building-a-blog","content":"\n(This post will be in english. I haven't used english properly in a long time, I might as well start using it in posts like this)\n\nIn this post I'll be briefly going through how I built my blog with Next.js and some difficulties that I've faced. This will only be a personal reflection, not a tutorial.\n\nSo one day, I decided to build a personal blog. Nothing fancy but a rather simple blog to put my personal info with posting capability. Yes, you can use a given template, but I personally have this innate avoidance for templates. I wish to have complete control of what I use and build, and thus I decided to use a SSG/SSR framework called Next.js.\n\nAnd so, here are the main tools/packages that I've used to build my blog:\n\n- Next.js\n- Remark / Rehype\n- Material UI React\n- GitHub Pages & Workflow\n  I'll go through each of these to address my thoughts on them.\n\n## Next.js\n\nNext.js is a SSG/SSR framework for React. I haven't done SSG nor SSR ever before. It looked like Next.js and Gatsby both offer SSG functionality, so I had to choose. After a bit of research, I knew that Next.js would suit me better. To me Gatsby looked like a full fledged ecosystem with plugins and all, while Next.js was more like plug-and-play. It seemed like I would not have as much control over the project if I used Gatsby, so I chose Next.js. Of course, I haven't used Gatsby so there's the benefit of the doubt.\n\n## Remark / Rehype\n\nRemark / Rehype are libraries that transform markdown and html. I used these packages to convert them into React components, so that I could upload my posts.\n\nThe overall process of conversion is: `Markdown File - Remark - Rehype - React Component`. The markdown file is parsed with remark, translated to html using rehype, and then to a React component. The ecosystem allows you to plug processors in between. For example, I've used the `rehype-highlight` package that highlights code with `highlight.js` under the hood.\n\nWhat I really liked about this package is that it allows users to use their own components for each html tag from markdown. For now, rounding corners in code blocks remain my only usage for this feature (...) but I'm sure I could do much more.\n\n## Material UI React\n\nThis one's a banger. The Material UI component library provides many useful components that follow the Material UI design. _I like pretty things. I don't like CSS._ This library is for me. The familiarity helps as well. Most (if not all) google products use this guideline. The documentation is top notch as well. It also allows easy custom styling. This one's a must have.\n\n## GitHub Pages & Workflow\n\nI've used GitHub pages as my blog hosting service. It serves static assets for free. I heard good things about it, but have never used it before. I had some difficulty initially setting it up, only to find out that I haven't changed the branch for github pages.\n\nSince generating static files requires a building process using Next.js, I have also set up GitHub Actions to automatically build as I push.\n\nI hope to keep my blog minimal, but the minimum functionality will grow larger as the need arises. Eventually the stack will grow as well, and maybe I'll do version 2 of this post when it happens.\n","title":"Building a Personal Blog in Next.js","tags":["nextjs","en"],"date":"2021-09-03"},{"id":"20210831-navy-software-developer","content":"\n블하 (블로그 하이라는 뜻)\n\n아무 생각 없이 대학교를 다니다가 보니 시간이 참 빨리 지나갔다. 고등학교 동기들 중에서는 군대가는 친구들을 여럿 보았는데, 입대를 3학년 이후로 생각하고 있던 이유는 많았다.\n\n1. 우리 학교는 다들 군대를 좀 늦게 가는 분위기였어서..\n2. 입대하기 전에 학교에서 최대한 많이 배워보고 싶은 욕구도 좀 있었다. 물론 그래봐야 전공 수업들이긴 했지만 실제로 학점을 굉장히 몰아 들었다. 졸업 이런거 때문이 아니고 맛보고 싶은게 많았다.\n3. 이왕 가는거 개발 쪽으로 갈 수 있으면 좋을 거라 생각했다. 근데 그러려면 2학년은 마쳐야 가능성이 조금이라도 생긴다. 이유는 후술\n\n3번 이유가 가장 컸다. 병특을 고려하지 않은 이유는 내가 대학원을 가게 되면 그 전에 시간을 너무 많이 써야 해서..그리고 난 대학원 갈 생각이 아직은 꽤 있다. 전문연을 고려하지 않은 이유는 해외로 나가고 싶은 개인적인 로망을 실현하는데 걸림돌이 될 것 같아서. 또 그렇다고 대학원이나 유학을 가야겠다는 확신은 들지 않는 상황이었다. 이것저것 가정하고 고민하다보니 머리가 상당히 복잡해져서, `좋은 보직에 선발되면 그냥 가자!`라는 결론을 내렸다.\n\n## 육군 SW 개발병 지원\n\n2학년 때 입대 고민을 할 당시에는 이걸 지원해서 갈 생각이었다. 선발은 1차 서류 + 2차 면접으로 이루어졌었다. 1차 서류는 학년 점수 + 자격증 + 고교 출석률 3개로 이루어져 있었다. 난 모범생이었으니 고교 출석률은 문제 없었고, 학년은 내가 당장 바꿀 수 없었기에 학년 점수도 고정이었다. 마지막 남은 자격증의 경우 10점이 최고 점수였는데, 10점을 주는 자격증들(기사급)이 여러개 있었고, 그 다음이 8점(산업기사급), 마지막이 6점이었다. 난 자격증은 없는 상황이었어서 주변 사람들이 많이 따는 정보처리 자격증을 취득하기로 했는데, 10점을 주는 정보처리기사 자격증은 졸업을 해야 딸 수 있고, 8점을 주는 정보처리산업기사 자격증은 3학년이 돼야 딸 수 있었다. 6점 주는 기능사 자격증은 초등학생도 딸 수 있던 것 같던데 이걸로는 부족할 것 같았다. 그래서 3학년 된 직후에 정보처리산업기사 자격증 딴다고 필기시험은 회사 다니면서 밤에 공부하고, 실기시험은 수요일에 중간고사 끝나고 수목금 공부해서 가고..참 바쁜 시간 쪼개가며 공부했는데 어쩌다 취득은 했다.\n\n아무튼 내가 당시에 낼 수 있는 최대 점수를 냈는데 1차에서 탈락해버렸다. 모집 인원은 3명, 1차 통과는 3배수였고, 내 점수는 커트보다 3점 낮아서 떨어졌다. 내 점수는 선발 순위가 27위였다. 그만큼 1점이 중요했던 것 같다. 근데 한창 학기 중이라 바쁜 시기였던 것도 있었고, 나는 나름 최선을 다했어서 별로 후회되거나 아쉬운 점은 없었다. 누굴 탓하랴!\n\n## 해군 SW 개발병 지원\n\n육군을 떨어지고 바로 해군을 넣었다. 해군도 1차 서류 - 2차 면접 방식으로 선발을 하는데 1차는 모두 통과시키고 면접을 보는 방식이었다. 배점은 자격(30) + 경력(30) + 전공(40) + 면접(100)이었는데 솔직히 모르고 그냥 면접보러 갔었다. 면접은 대면으로 모든 대상자들이 계룡대에서 보았다. 나는 학교에 있었는데 가까이 있어서 택시타고 갔다. 근데 **면접을 보는 건물이 지도에 안 나오니 잘 찾아가야 한다...**, 택시에서 생각없이 내리고 길도 모르고 걸어가다 늦을 뻔했는데 은인이 나타나서 면접장까지 태워주셨다. 진짜 감사합니다...이걸 보시게 되면 연락해주세요. 보상이라도 해드리고 싶습니다.\n\n선발은 1명 선발이라 적혀 있었고, 병무청 웹사이트에서 조회했을 때는 나의 1차 점수는 3위, 최종 점수가 1위였다. 총 13~15명 정도 지원했던 것으로 기억한다. 다만 지원할 때 1명보다 많이 뽑을 수도 있다고 적혀 있어 실제로 얼마나 뽑았는지는 모르겠다. 내가 2등이었는데 뽑혔으면 여러 명 뽑았구나 할텐데 그렇지 않으니..\n\n### 면접 후기\n\n_다음 문단은 면접 내용을 다룹니다. 문제가 된다면 삭제하겠습니다._\n\n나에게 물어보신 질문들을 직접 적을 생각은 없다. 대신 어떤 느낌으로 나왔는지 설명하겠다.\n\n#### 자료를 성심성의껏 준비하자\n\n나는 이 자료로부터 나오는 질문이 많았다. 고정질문이랑 비슷한 수의 질문을 하신 것 같다. 그만큼 주의깊게 이 자료를 보시니 준비를 잘하자!\n\n매수 또한 넉넉하게 출력해가는 것이 좋다. 나는 평소에 정말 생각이 없는 편이라 한 장만 뽑았었는데 운이 좋게도 여러 개 뽑을 생각을 했었다. 면접 보러 들어가니 면접관이 한 분보다 많이 계셔서 다행이 한 부씩 드릴 수 있었다.\n\n우선 1차를 통과하고(2021년도 기준 100%) 포트폴리오나 자기소개서 등의 자료를 자유롭게고 지참하라는 연락을 받았다. 근데 나는 둘 다 없는 상황이었다. 사실 반년 전에 회사 인턴 지원하면서 작성한 게 있긴 했는데 정말 편한 느낌으로 써놓은 거라 그대로 내기에는 부담스러웠다. 그래서 처음부터 다시 작성했다. 어떤 내용을 넣을지는 고민을 많이 한 부분이다. 나는 `짧은 소개 + 경력 + 프로젝트 경험 + 보유기술 + 어학능력 + 교육 + 기타 활동`으로 구성했다. 그냥 내 마음대로 만든 구성이다. _Mimic at your own risk!_\n\n포트폴리오라는 말을 몰라 취업한 형에게 물어보니 보통 피피티 형태라고 하던데, 어떻게 가져오라는 건지 약간 의문이어서 그냥 문서 형식으로 작성해갔었다. 가보고 나니 그렇게 준비해가길 잘했다. 나의 경우 가서 디지털로 발표를 할 환경은 아니었다. 물론 둘 다 준비를 하면 최고겠다. 나는 시간에 쫓겨 준비했었기 때문에...\n\n#### 기본적인 조사는 하자\n\n군면접의 성격을 띤 질문들도 많이 하신다. 대한민국 군대와 역사에 대해 최소한으로는 알아가면 좋을 것 같다. 나는 해군에 지원했기에 해군과 관련된 지식을 좀 쌓고 가는 것도 좋을 것이다.\n이외에도 부대 내에서의 상황을 주시고 이런 상황에서 어떻게 행동할 것인지에 관한 질문들 또한 하신다. 여러 가지 상황을 준비해가는 것도 방법일 것 같다. 나는 약간 생소한 상황을 질문하셔서 내 평소 가치관이랑 순발력에 의지해서 대답을 드려야 했다.\n\n내가 시간이 지나면 위 내용들을 잊을 것 같아 글을 작성하기도 했지만 해군 개발병에 지원할 때 후기가 전혀 없어 준비하기가 조금 어려워서 누군가 이 글을 보고 조금 더 수월하게 준비했으면 하는 마음도 있다. 지금 제 블로그가 바닥부터 만든거라 댓글 기능이 없는데, 추가 문의사항이 생기면 메일로 문의를 주시거나 보실 적에 댓글 기능이 있으면 댓글 달아주세요:)\n","title":"해군 SW 개발병 지원 후기","tags":["general","diary","military","ko"],"date":"2021-08-31"},{"id":"20210829-genesis","content":"\n## Hello World!\n\n블로그를 시작하게 되었다.\n\n블로그 운영은 거의 올해 초부터 해보고 싶었는데, 본업 때문에 시간이 부족하다는 변명을 스스로에게 하며 시작하지 않고 있었다... 나는 \"From Scratch\"를 굉장히 좋아하는 편이라 블로그도 템플릿에 의존하지 않고 직접 만들어야 한다는 생각 때문에 시작하는데 조금 장벽이 되었을 수도 있었을 것 같다는 생각이 든다.\n\n21년 여름에는 본교 PLRG에서 개별연구를 했는데, 랩 미팅 때 교수님께서 \"평소에 글을 쓰는 습관을 들이는 것이 좋다\"라는 말씀을 하신 것을 듣고 조금 더 동기부여가 되었던 것 같다. 얼마 뒤인지부터는 모르겠는데 아무튼 블로그 개발을 시작했고, 소개, bio, 그리고 게시글 조회 기능을 만든 뒤에 이 글을 작성하고 있다.\n\n동기부여가 되었던 또 다른 일은 입대가 얼마 안 남았다는 점이다. 이 이야기는 별도의 글에 더 자세하게 담겠지만, 불과 이틀 전에 해군 SW 개발병에 합격했는데, 한 명 뽑는 보직이다 보니 될 기대를 크게 안하고 있었어서 입영 날짜를 모르고 있었다. 알고 보니 10월 5일 입영이었고 백신 문제 때문에 정확히 그때 갈지는 모르겠지만 시간이 한 달...정도밖에 남지 않았기 때문에, 시간이 있을 때라도 좀 정리를 하고 가야겠다는 생각을 했다. 물론 아직 남은 시간동안 어떠한 일을 할지 제대로 생각을 못해봤는데, 최대한 블로그 정리를 하고 갈 수 있었으면 한다.\n\n블로그 게시글들은 남이 볼 것이라고 기대하지는 않고 오히려 개인 일기 느낌에 가깝도록 편하게 적을 것 같은데, 또 나만 알아들을 수 있도록 적지는 않을 생각이다. 주 내용은 내가 평소에 관심있던 편집기 이야기 및 개발을 배우면서 사소하게 배웠던 것들을 적을 것 같다! 또 예전부터 개인 노션이나 `vimwiki` 등 여기저기 적어는 놓았는데 정리가 안된 자료들도 과거 작성 날짜에 맞춰 업로드할 생각이다.\n","title":"블로그 개업!","tags":["general","diary","ko"],"date":"2021-08-29"},{"id":"20200711-esModuleInterop-in-tsconfig","content":"\nWhy is it that different patterns of imports are shown across typescript examples?\n\n```typescript\nimport * as React from 'react';\nimport React from 'react';\n```\n\nLet us look at how the two examples are compiled to javascript code using `tsc`.\n\nFirst, intialize a project with the following commands:\n\n```bash\nmkdir esminterop-example && cd esminterop-example   # create project directory\nyarn init -y                                        # initialize npm project\nyarn add react                                      # add react package (opt.)\nyarn add -D typescript @types/node @types/react     # add typescript compiler and type definitions (req.)\ntouch star.ts plain.ts\n```\n\nFill in the files `star.ts` and `plain.ts` with the following code:\n\n`star.ts`\n\n```typescript\nimport * as React from 'react';\nconsole.log(React);\n```\n\n`plain.ts`\n\n```typescript\nimport React from 'react';\nconsole.log(React);\n```\n\nFirst, let's compile `star.ts` with `tsc` and see the output.\n\n```bash\nnpx tsc star.ts\n```\n\n`star.js`\n\n```javascript\n'use strict';\nexports.__esModule = true;\nvar React = require('react');\nconsole.log(React);\n```\n\nAll good. Now try to compile `plain.ts`, and an error will occur.\n\n```bash\nnpx tsc plain.ts\n\nplain.ts:1:8 - error TS1259: Module '\"/Users/pacokwon/workspace/esminterop-example/node_modules/@types/react/index\"' can only be default-imported using the 'esModuleInterop' flag\n\n1 import React from 'react';\n         ~~~~~\n\n  node_modules/@types/react/index.d.ts:65:1\n    65 export = React;\n       ~~~~~~~~~~~~~~~\n    This module is declared with using 'export =', and can only be used with a default import when using the 'esModuleInterop' flag.\n\n\nFound 1 error.\n```\n\nThe problem occurs because while `react` does not have a default export, our typescript file is attempting to default import it. One way of solving this issue might be to use the wildcard(asterisk) import above. Another way is to use the `--esModuleInterop` flag. Now let's see how the latter way works, by using that flag in our compiler.\n\n```bash\nnpx tsc --esModuleInterop plain.ts\n```\n\nThere are no errors, which is a good thing. The compiled file looks like this:\n\n```javascript\n'use strict';\nvar __importDefault =\n  (this && this.__importDefault) ||\n  function (mod) {\n    return mod && mod.__esModule ? mod : { default: mod };\n  };\nexports.__esModule = true;\nvar react_1 = __importDefault(require('react'));\nconsole.log(react_1['default']);\n```\n\nOne can find out that a wrapper to the require is added. The wrapper provides additional logic, that allows flexible resolution between es6 modules and commonjs modules. It can also be observed that a \"default\" export or import is, from a commonjs module point of view, the value that corresponds to the key `\"default\"` in the `module.exports` object.\n\nAFAIK, javascript packages are usually shipped with the original source code transpiled into using commonjs modules, so the `esModuleInterop` flag is a flag that I commonly use in my `tsconfig.json`.\n","title":"Understanding the esModuleInterop option in tsconfig.json","tags":["typescript","quicknote","en"],"date":"2020-07-11"},{"id":"20200605-spellchecking-in-vim","content":"\nJust until stumbling upon some random video on youtube about spellchecking in Vim, I didn't know such capability even existed in Vim. Turns out that you can, and it can be utilized in markdown files, commit messages and etc. This post is a demonstration of how you can enable and utilize spellchecking in Vim.\n\n## Enabling Spellchecking in Vim\n\n```vim\n:set spell spellang=en_us \" use english dictionary for spellchecking\n```\n\nTo only set it for local buffers, use:\n\n```vim\n:setlocal spell spelllang=en_us\n```\n\nI utilize this primarily in autocmds, like this:\n\n```vim\nautocmd BufRead,BufNewFile *.md setlocal spell spelllang=en_us \" enable spellchecking in markdown files\nautocmd FileType gitcommit setlocal spell spelllang=en_us \" enable spellchecking in git commit files\n```\n\nOnce you have these set up, words that are recognized by the spellchecker will be highlighted according to the highlight groups `SpellBad`, `SpellCap`, `SpellRare`, `SpellLocal`. For further reference, consulting the `:help spell-quickstart` docs will come in handy. In my neovim setup, the words are shown underlined (Not exactly sure where it comes from).\n\n## Utilizing it\n\nOne can get recommendations from the spellchecker from the completion engine. Run `set complete+=kspell`, as in:\n\n```vim\nautocmd FileType gitcommit setlocal spell spelllang=en_us | set complete+=kspell\n```\n\nOne can navigate between recommendations in insert mode using `^N` and `^P`, and spellchecking recommendations will show up among the options.\n\nHere are some commands I found useful:\n\n- `]s` and `[s`: navigate between misspelled words. Former moves forward, the latter backwards.\n- `z=`: see alternatives to the word under the cursor. For example, if I write `file` and run `z=` on it, it will recommend a list of words from the dictionary.\n- `zg`: register a word as correct in the dictionary. The Vim dictionary does not know a lot of words, so it will mark a lot of words as incorrect. One way to solve that issue is to register a word to the dictionary. This command does that.\n- `zw`: just like `zg`, but marks a word as incorrect.\n\nFor more, as always, consult the helpdocs. For spellchecking, `:help spell` is where you should go to.\n","title":"Spellchecking in Vim / Neovim","tags":["vim","neovim","quicknote","en"],"date":"2020-06-05"}]},"__N_SSG":true}