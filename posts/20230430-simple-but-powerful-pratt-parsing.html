<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><title>Simple but Powerful Pratt Parsing</title><meta property="og:title" content="Simple but Powerful Pratt Parsing"/><meta property="og:site_name" content="Paco Kwon&#x27;s Blog"/><meta name="next-head-count" content="5"/><link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark.min.css"/><link id="hljs-light" rel="alternative stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css" disabled=""/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-688XJFWYJL"></script><script>
              window.dataLayer = window.dataLayer || [];
              function gtag(){dataLayer.push(arguments);}
              gtag('js', new Date());
              gtag('config', 'G-688XJFWYJL', { page_path: window.location.pathname });
            </script><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/689295c571d1513e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/689295c571d1513e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-97515393dccb2e54.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-164f91e3b1a225f8.js" defer=""></script><script src="/_next/static/chunks/pages/_app-bc46f6e777959fef.js" defer=""></script><script src="/_next/static/chunks/392-079b0eace61ca2f5.js" defer=""></script><script src="/_next/static/chunks/136-c90a773b183ee435.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-eb8eaceaa2925123.js" defer=""></script><script src="/_next/static/Km9EJmKojR2FE2I-vVgCt/_buildManifest.js" defer=""></script><script src="/_next/static/Km9EJmKojR2FE2I-vVgCt/_ssgManifest.js" defer=""></script><style data-emotion="css-global 12ldfex">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:#fff;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;background-color:#121212;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#121212;}*{padding:0;margin:0;}html{overflow-x:hidden;}body{overflow-x:hidden;position:relative;line-height:1.6;}:root{--fs-800:3rem;--fs-700:2rem;--fs-600:1.5rem;--fs-500:1.25rem;--fs-400:1.125rem;--fs-300:1rem;--fs-200:0.8rem;}</style><style data-emotion="css 670439 5liw95 s621ju dy3din zjuml4 1ps3nxk vubbuv 6ipc24 mfiwgy 16as864 3iet4t icnwll 10ib5jr 1qyknr9 bkna8o 6xgo6 400xyc 186wd1t 18ldivb 1pjtbja 1bas2qp 1jop5q6 v5nfi0 18bh6q1">.css-670439{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;}.css-670439::-moz-focus-inner{border-style:none;}.css-670439.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-670439{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-670439:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-670439:hover{background-color:transparent;}}.css-670439.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-5liw95{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;margin-bottom:32px;}.css-s621ju{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;box-shadow:0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);background-image:linear-gradient(rgba(255, 255, 255, 0.09), rgba(255, 255, 255, 0.09));display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:fixed;z-index:1100;top:0;left:auto;right:0;}@media print{.css-s621ju{position:absolute;}}.css-s621ju.MuiAppBar-root{background-image:unset;}.css-s621ju.MuiAppBar-colorPrimary{box-shadow:none;background-color:#121212;color:#fff;}.css-dy3din{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:56px;}@media (min-width:0px){@media (orientation: landscape){.css-dy3din{min-height:48px;}}}@media (min-width:600px){.css-dy3din{min-height:64px;}}.css-dy3din.MuiToolbar-root{padding:0px 32px;}@media (max-width:599.95px){.css-dy3din.MuiToolbar-root{padding:0px 16px;}}@media (min-width:0px){.css-zjuml4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}@media (min-width:600px){.css-zjuml4{display:none;}}.css-1ps3nxk{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;padding:12px;font-size:1.75rem;}.css-1ps3nxk::-moz-focus-inner{border-style:none;}.css-1ps3nxk.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1ps3nxk{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1ps3nxk:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-1ps3nxk:hover{background-color:transparent;}}.css-1ps3nxk.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}.css-6ipc24{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1.25rem;line-height:1.334;color:#90caf9;-webkit-text-decoration:none;text-decoration:none;}@media (min-width:600px){.css-6ipc24{font-size:1.3118rem;}}@media (min-width:960px){.css-6ipc24{font-size:1.4993rem;}}@media (min-width:1280px){.css-6ipc24{font-size:1.4993rem;}}.css-6ipc24:hover{-webkit-text-decoration:underline;text-decoration:underline;}@media (min-width:0px){.css-6ipc24{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;margin-left:16px;}}@media (min-width:600px){.css-6ipc24{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;margin-right:32px;}}.css-6ipc24.MuiLink-root,.css-6ipc24.MuiLink-underlineHover{color:#4db6ac;font-weight:700;}.css-mfiwgy{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}@media (min-width:0px){.css-mfiwgy{display:none;}}@media (min-width:600px){.css-mfiwgy{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}.css-16as864{margin:0;font-family:inherit;font-weight:inherit;font-size:inherit;line-height:inherit;letter-spacing:inherit;color:#90caf9;-webkit-text-decoration:underline;text-decoration:underline;text-decoration-color:rgba(144, 202, 249, 0.4);margin-right:16px;-webkit-text-decoration:none;text-decoration:none;color:#fff;}.css-16as864:hover{text-decoration-color:inherit;}.css-16as864:hover{-webkit-text-decoration:underline;text-decoration:underline;}.css-3iet4t{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;}.css-icnwll{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:16px;padding-right:16px;min-height:56px;}@media (min-width:600px){.css-icnwll{padding-left:24px;padding-right:24px;}}@media (min-width:0px){@media (orientation: landscape){.css-icnwll{min-height:48px;}}}@media (min-width:600px){.css-icnwll{min-height:64px;}}.css-icnwll.MuiToolbar-root{padding:0px 32px;}@media (max-width:599.95px){.css-icnwll.MuiToolbar-root{padding:0px 16px;}}.css-10ib5jr{margin-bottom:40px;}.css-1qyknr9{width:100%;margin-left:auto;box-sizing:border-box;margin-right:auto;display:block;padding-left:16px;padding-right:16px;}@media (min-width:600px){.css-1qyknr9{padding-left:24px;padding-right:24px;}}@media (min-width:960px){.css-1qyknr9{max-width:960px;}}@media (max-width:599.95px){.css-1qyknr9.MuiContainer-root{padding:0px;}}.css-bkna8o{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:none;background-image:linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0));padding:16px 40px 32px;}@media (max-width:599.95px){.css-bkna8o{padding:8px 16px 32px;}}.css-6xgo6 h1,.css-6xgo6 h2,.css-6xgo6 h3{margin-top:32px;margin-bottom:8px;}.css-6xgo6 p{margin-bottom:12px;font-size:var(--fs-300);}.css-6xgo6 ul,.css-6xgo6 li{list-style-position:inside;}.css-400xyc{font-weight:bold;margin-bottom:16px;}.css-186wd1t{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:8px;margin-bottom:16px;}.css-18ldivb{max-width:100%;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:rgba(0, 0, 0, 0.87);background-color:#90caf9;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;}.css-18ldivb.Mui-disabled{opacity:0.38;pointer-events:none;}.css-18ldivb .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#e0e0e0;font-size:0.75rem;}.css-18ldivb .MuiChip-avatarColorPrimary{color:rgba(0, 0, 0, 0.87);background-color:#42a5f5;}.css-18ldivb .MuiChip-avatarColorSecondary{color:rgba(0, 0, 0, 0.87);background-color:#ab47bc;}.css-18ldivb .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-18ldivb .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-18ldivb .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-18ldivb .MuiChip-deleteIcon:hover{color:rgba(255, 255, 255, 0.4);}.css-18ldivb .MuiChip-deleteIcon:hover,.css-18ldivb .MuiChip-deleteIcon:active{color:rgba(0, 0, 0, 0.87);}.css-18ldivb.MuiChip-colorPrimary{color:white;background:#009688;font-weight:500;}.css-1pjtbja{overflow:hidden;text-overflow:ellipsis;padding-left:8px;padding-right:8px;white-space:nowrap;}.css-1bas2qp{color:#4db6ac;-webkit-text-decoration:unset;text-decoration:unset;}.css-1bas2qp:hover{cursor:pointer;color:#80cbc4;font-weight:500;}.css-1jop5q6{border-radius:8px;font-weight:400;margin-bottom:12px;border:1px solid #212121;position:relative;}.css-1jop5q6 button{position:absolute;top:5px;right:5px;}.css-1jop5q6 code.hljs{background:var(--background-color);}.css-v5nfi0{color:#26a69a;background:#212121;border-radius:4px;font-weight:bold;}.css-18bh6q1{padding:24px 40px;}@media (max-width:599.95px){.css-18bh6q1{padding:24px 16px;}}.css-18bh6q1 .utterances{position:relative;box-sizing:border-box;width:100%;max-width:unset;margin:0;}</style><style data-href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div class="css-5liw95"><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionFixed mui-fixed css-s621ju"><div class="MuiToolbar-root MuiToolbar-regular css-dy3din"><div class="MuiBox-root css-zjuml4"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1ps3nxk" tabindex="0" type="button" aria-label="account of current user" aria-controls="menu-appbar" aria-haspopup="true"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button></div><a class="MuiTypography-root MuiTypography-h5 MuiLink-root MuiLink-underlineHover css-6ipc24" href="/">Paco Kwon</a><div class="MuiBox-root css-mfiwgy"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/bio"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Bio</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/posts"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Posts</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/links"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Links</p></a></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeMedium css-670439" tabindex="0" type="button"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="Brightness7Icon"><path d="M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></svg></button></div></header><div class="MuiToolbar-root MuiToolbar-gutters MuiToolbar-regular css-icnwll"></div></div><main><div class="MuiBox-root css-10ib5jr"><div class="MuiContainer-root MuiContainer-maxWidthMd css-1qyknr9"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 css-bkna8o"><div class="css-6xgo6"><h1>Simple but Powerful Pratt Parsing</h1><div class="css-400xyc">2023-04-30</div><div class="css-186wd1t"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">parsing</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div></div><div><p>아래 글은 <a class="css-1bas2qp">matklad</a>의 <a class="css-1bas2qp">Simple but Powerful Pratt Parsing</a>의 번역 포스팅입니다. 제 스스로의 이해를 돕기 위함이 목적이지만, 유익한 글인 것 같아 블로그에 소개하고도 싶었습니다.</p>
<h2>Simple but Powerful Pratt Parsing</h2>
<p>프랫 파싱 글에 온 것을 환영합니다! 프랫 파싱은 구문 분석계의 모나드 튜토리얼과 같다고도 할 수 있습니다. 이 주제에 관한 소개글은 너무 많아서 <a class="css-1bas2qp">이런 튜토리얼 모음</a>까지 있을 정도입니다.</p>
<p>이 글의 목표는 아래와 같습니다.</p>
<ul>
<li>이른바 left-recursion 문제가 과장되었음을 제기하기 위해</li>
<li>BNF 표기법이 중위표현식을 표현하기에 부적합함을 지적하기 위해</li>
<li>프랫 파싱 알고리즘의 구현을 과한 추상화 없이, 있는 그대로 보여주기 위해</li>
<li>이 알고리즘을 제가 제대로 이해하기 위해 (제가 실사용 용도로 프랫 파서를 <a class="css-1bas2qp">구현</a>한 적이 있는데, 이제는 코드를 봐도 바로 이해되지가 않더라고요)</li>
</ul>
<h2>Introduction</h2>
<p>파싱이라는 것은, 일련의 토큰들이 컴파일러에 의해 트리 구조로 변환되는 과정을 이야기합니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">                            Add
                 Parser     / \
 &quot;1 + 2 * 3&quot;    -------&gt;   1  Mul
                              / \
                             2   3
</code></div></pre>
<p>파싱을 접근하는 방식은 다양한데, 크게 두 부류로 나눠볼 수 있습니다.</p>
<ul>
<li>파싱하려는 언어의 문법을 DSL을 사용하여 표현하고, 그 문법을 이용하여 파서를 생성해내는 방법</li>
<li>직접 손으로 파서를 작성하는 방법</li>
</ul>
<p>두 번째 방식 안에서 가장 널리 사용되는 기법이 바로 프랫 파싱입니다.</p>
<h2>BNF</h2>
<p>문맥 자유(Context-Free) 문법 표기법(주로 BNF concrete syntax를 사용)은 구문분석 이론에 중요한 발견이었습니다. BNF를 사용하면 다음과 같이 본래 선형적인 문장 구조를 트리 형태로 나타낼 수 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">Item ::=
    StructItem
  | EnumItem
  | ...

StructItem ::=
    &#x27;struct&#x27; Name &#x27;{&#x27; FieldList &#x27;}&#x27;

...
</code></div></pre>
<p>처음 이 기법을 보며 감탄했던 기억이 납니다.</p>
<p>표현식을 나타내는 방식을 보고 갑자기 좀 서운해졌지만요.</p>
<p>표현식을 나타내는 직관적인 형태의 문법을 살펴보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">Expr ::=
    Expr &#x27;+&#x27; Expr
  | Expr &#x27;*&#x27; Expr
  | &#x27;(&#x27; Expr &#x27;)&#x27;
  | &#x27;number&#x27;
</code></div></pre>
<p>꽤 직관적이죠. 근데 사실 위 문법은 <strong>모호</strong>해서 자동 파서 생성기(위에서 언급된 1번 방식)에 사용되기 위해서는 고쳐서 작성되어야 합니다. 더 구체적으로 얘기하자면, 연산자의 우선순위와 결합방향을 잘 고려한 문법을 작성해야 하는데요, 아래와 같이 수정하면 앞서 언급된 문제들을 해결할 수 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">Expr ::=
    Factor
  | Expr &#x27;+&#x27; Factor

Factor ::=
    Atom
  | Factor &#x27;*&#x27; Atom

Atom ::=
    &#x27;number&#x27;
  | &#x27;(&#x27; Expr &#x27;)&#x27;
</code></div></pre>
<p>어떤가요? 솔직히 이 새로운 문법은 제가 처음 생각했던 표현식의 모양과는 전혀 달라 보입니다. 가장 먼저 나온 모호한 문법이 더 직관적이고, 더군다나 제가 스스로 문법을 이렇게 고칠 수 있을때까지 언어론에 대해 전공수업만 세네개 들었어야 했던 것 같습니다.</p>
<p>이것이 제가 프랫 파싱을 좋아하는 이유입니다. 문법을 부자연스럽게 고쳐야 하는 재귀하향식 파싱 기법에서 발전해서, 연산자와 결합방향을 자연스럽게 표현할 수 있기 때문입니다.</p>
<h2>재귀하향과 Left-Recursion</h2>
<p>재귀하향은 직접 파서를 짤 때 사용할 수 있는 가장 기본적인 기법입니다. 이 기법은 서로 재귀적인 함수들을 사용하여 파싱을 하는데, 예를 들어 위에 있는 문법은 재귀하향을 썼을 때 다음과 같이 코드로 표현할 수 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">item</span>(p: &amp;<span class="hljs-keyword">mut</span> Parser) {
    <span class="hljs-keyword">match</span> p.<span class="hljs-title hljs-function hljs-invoke">peek</span>() {
        STRUCT_KEYWORD =&gt; <span class="hljs-title hljs-function hljs-invoke">struct_item</span>(p),
        ENUM_KEYWORD   =&gt; <span class="hljs-title hljs-function hljs-invoke">enum_item</span>(p),
        ...
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">struct_item</span>(p: &amp;<span class="hljs-keyword">mut</span> Parser) {
    p.<span class="hljs-title hljs-function hljs-invoke">expect</span>(STRUCT_KEYWORD);
    <span class="hljs-title hljs-function hljs-invoke">name</span>(p);
    p.<span class="hljs-title hljs-function hljs-invoke">expect</span>(L_CURLY);
    <span class="hljs-title hljs-function hljs-invoke">field_list</span>(p);
    p.<span class="hljs-title hljs-function hljs-invoke">expect</span>(R_CURLY);
}
</code></div></pre>
<p>보통 교과서들은 Left Recursive 문법을 이 접근 방식의 단점이라고 지적하면서, 더 심화된 LR 파싱 기법으로 넘어가는 동기로 삼습니다. Left Recursion은 분명히 문제가 되는 시점들이 있는데, 아래 문법을 한 번 보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">Sum ::=
    Sum &#x27;+&#x27; Int
  | Int
</code></div></pre>
<p>재귀하향 방식으로 위 문법에 대한 파서를 작성해보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">sum</span>(p: &amp;<span class="hljs-keyword">mut</span> Parser) {
    <span class="hljs-comment">// Sum &#x27;+&#x27; Int가 되는지 먼저 시도해본다</span>
    <span class="hljs-title hljs-function hljs-invoke">sum</span>(p); <span class="hljs-comment">// ①</span>
    p.<span class="hljs-title hljs-function hljs-invoke">expect</span>(PLUS);
    <span class="hljs-title hljs-function hljs-invoke">int</span>(p);
    <span class="hljs-comment">// 위에서 실패했으면, 그 다음 후보지를 시도해본다.</span>
    ...
}
</code></div></pre>
<ol>
<li>이 코드를 실행하면 코드가 무한 재귀에 빠져버려서 스택 오버플로우가 발생해버립니다.</li>
</ol>
<p>이런 문제를 고치기 위한 이론적인 방법은 역시 문법을 수정해서, <strong>같은 언어를 표현하되 위와 같은 문제가 발생하지 않도록 Left Recursion을 없앤 문법</strong>을 작성하는 것입니다.</p>
<p>하지만 직접 작성하는 파서의 경우에는 실용적인 해결방법도 있는데, 그냥 재귀를 버리고 반복문을 사용하는 것입니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">sum</span>(p: &amp;<span class="hljs-keyword">mut</span> Parser) {
    <span class="hljs-title hljs-function hljs-invoke">int</span>(p);
    <span class="hljs-keyword">while</span> p.<span class="hljs-title hljs-function hljs-invoke">eat</span>(PLUS) {
        <span class="hljs-title hljs-function hljs-invoke">int</span>(p);
    }
}
</code></div></pre>
<h2>프랫 파싱의 뼈대</h2>
<p>위와 같이 반복문을 이용해서 Left Recursion을 실용적으로 대처하는 방법을 보았는데, 프랫 파싱은 반복문과 재귀를 동시에 사용합니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">parse_expr</span>() {
    ...
    <span class="hljs-keyword">loop</span> {
        ...
        <span class="hljs-title hljs-function hljs-invoke">parse_expr</span>()
        ...
    }
}
</code></div></pre>
<p>위에 있는 코드는 연산자 우선순위와 결합방향을 잘 처리해줍니다. 머리가 띵해지긴 하지만요.</p>
<h2>우선순위에서 결합 세기로</h2>
<p>솔직히 말하면 저는 &quot;높은 우선순위&quot;와 &quot;낮은 우선순위&quot;라는 용어를 보며 항상 헷갈리는 것 같습니다. <code class="css-v5nfi0">a + b * c</code> 라는 표현식 안에서 덧셈은 우선순위가 <strong>낮은데</strong>, 파싱 트리에서는 <strong>맨 위에</strong> 있습니다.</p>
<p>그래서 저는 <strong>결합 세기</strong>라는 표현이 더 직관적이라고 생각합니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">expr:   A       +       B       *       C
power:      3       3       5       5
</code></div></pre>
<p><code class="css-v5nfi0">*</code>이 더 세니까 B와 C를 끌어당기는 힘이 더 세고, 위 표현식은 <code class="css-v5nfi0">A + (B * C)</code>와 같이 파싱이 되는 것입니다.</p>
<p>결합 방향은 어떻게 표현할 수 있을까요? <code class="css-v5nfi0">A + B + C</code>를 보면 모든 연산자들이 같은 세기를 가지고 있어서 어떻게 파싱이 되어야 할지 불명확합니다. 하지만 이것도 아래와 같이 결합 세기로 표현할 수가 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">expr:      A       +       B       +       C
power:  0      3      3.1      3      3.1     0
</code></div></pre>
<p>오른쪽 피연산자를 당기는 힘이 더 강해지도록 <code class="css-v5nfi0">+</code>의 오른쪽 결합 세기를 조금 올린 것을 볼 수 있습니다. 양옆 끝에 <code class="css-v5nfi0">0</code>이 있는 것도 볼 수 있는데, 이건 맨 끝에서는 당기는 힘이 없다는 것을 표현한 것입니다. B의 입장에서 봤을 때, 왼쪽에서 더 강하게 결합하려고 하기 때문에 우선 첫 단계로는 아래와 같이 파싱이 될 것입니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">expr:     (A + B)     +     C
power:  0          3    3.1    0
</code></div></pre>
<p>그 다음 단계를 거치면 결국 <code class="css-v5nfi0">(A + B) + C</code> 가 됩니다.</p>
<p>프랫 파싱이 하는 일은 스트링을 왼쪽에서 오른쪽으로 읽으며 우리가 위에서 본 과정을 전부 처리하는 것입니다.</p>
<p>오른쪽으로 결합하는 연산자는 어떻게 처리하면 좋을까요? 예시로, 하스켈에 있는 함수 합성 연산자 <code class="css-v5nfi0">.</code>는 다음과 같이 모델링할 수 있습니다</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">  f     .    g     .    h
0   8.5    8   8.5    8   0
</code></div></pre>
<p>그러면 위 표현식은 <code class="css-v5nfi0">f . (g . h)</code> 와 같이 파싱이 되는 것입니다.</p>
<h2>미니멀한 프랫 파서</h2>
<p>이제부터 프랫 파서를 이용해서 캐릭터 하나짜리 숫자와 변수(묶어서 아톰), 그리고 특수문자를 사용한 연산자가 있는 표현식을 파싱해보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title hljs-class">Token</span> {
    <span class="hljs-title hljs-function hljs-invoke">Atom</span>(<span class="hljs-type">char</span>),
    <span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-type">char</span>),
    Eof,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title hljs-class">Lexer</span> {
    tokens: <span class="hljs-type">Vec</span>&lt;Token&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title hljs-class">Lexer</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">new</span>(input: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Lexer {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tokens</span> = input
            .<span class="hljs-title hljs-function hljs-invoke">chars</span>()
            .<span class="hljs-title hljs-function hljs-invoke">filter</span>(|it| !it.<span class="hljs-title hljs-function hljs-invoke">is_ascii_whitespace</span>())
            .<span class="hljs-title hljs-function hljs-invoke">map</span>(|c| <span class="hljs-keyword">match</span> c {
                <span class="hljs-string">&#x27;0&#x27;</span>..=<span class="hljs-string">&#x27;9&#x27;</span> |
                <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span> | <span class="hljs-string">&#x27;A&#x27;</span>..=<span class="hljs-string">&#x27;Z&#x27;</span> =&gt; Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(c),
                _ =&gt; Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(c),
            })
            .collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();
        tokens.<span class="hljs-title hljs-function hljs-invoke">reverse</span>();
        Lexer { tokens }
    }

    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Token {
        <span class="hljs-keyword">self</span>.tokens.<span class="hljs-title hljs-function hljs-invoke">pop</span>().<span class="hljs-title hljs-function hljs-invoke">unwrap_or</span>(Token::Eof)
    }

    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">peek</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Token {
        <span class="hljs-keyword">self</span>.tokens.<span class="hljs-title hljs-function hljs-invoke">last</span>().<span class="hljs-title hljs-function hljs-invoke">copied</span>().<span class="hljs-title hljs-function hljs-invoke">unwrap_or</span>(Token::Eof)
    }
}
</code></div></pre>
<p>결합 세기가 잘 반영되어 파싱됐는지 확인해보기 위해, 파싱된 표현식을 중위표현식에서 널리 사용되는 표현 방식으로 변환해보겠습니다. 이 방식은 (아마도 폴란드에서는 별로 인기가 없겠지만) 바로 S-표현식입니다. Lisp 계열 언어에서 지겹도록 볼 수있는 표현 방식이죠.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">1 + 2 * 3 == (+ 1 (* 2 3))
</code></div></pre>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::fmt;

<span class="hljs-keyword">enum</span> <span class="hljs-title hljs-class">S</span> {
    <span class="hljs-title hljs-function hljs-invoke">Atom</span>(<span class="hljs-type">char</span>),
    <span class="hljs-title hljs-function hljs-invoke">Cons</span>(<span class="hljs-type">char</span>, <span class="hljs-type">Vec</span>&lt;S&gt;),
}

<span class="hljs-keyword">impl</span> <span class="hljs-title hljs-class">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title hljs-class">S</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
            S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(i) =&gt; <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;{}&quot;</span>, i),
            S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(head, rest) =&gt; {
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;({}&quot;</span>, head)?;
                <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> rest {
                    <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot; {}&quot;</span>, s)?
                }
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;)&quot;</span>)
            }
        }
    }
}
</code></div></pre>
<p>단순하게 시작하죠. 먼저 아톰과 <code class="css-v5nfi0">+</code>, <code class="css-v5nfi0">*</code> 연산자만으로 이루어진 표현식을 파싱해봅시다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr</span>(input: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lexer</span> = Lexer::<span class="hljs-title hljs-function hljs-invoke">new</span>(input);
    <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(&amp;<span class="hljs-keyword">mut</span> lexer)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer) <span class="hljs-punctuation">-&gt;</span> S {
    todo!()
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">tests</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;1 + 2 * 3&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(+ 1 (* 2 3))&quot;</span>)
}
</code></div></pre>
<p>위에서 본 left recursion에 대한 <strong>실용적인 대처방식</strong>과 유사하게 접근해보겠습니다. 먼저 숫자를 파싱하고, 반복문을 돌고, 연산자를 파싱하고 나서는, 음.. 아직은 모르겠네요.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">op</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
            Token::Eof =&gt; <span class="hljs-keyword">break</span>,
            Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; op,
            t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
        };
        todo!()
    }
    lhs
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">tests</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;1&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;1&quot;</span>);
}
</code></div></pre>
<p>그래도 첫 번째 테스트는 벌써 통과합니다!</p>
<p>앞서 언급한 <strong>결합 세기</strong>의 개념을 코드에 도입해봅시다. 각 연산자마다 양옆을 당기는 힘을 <code class="css-v5nfi0">u8</code>로 각각 나타내고, 결합 방향을 표현하기 위해 한쪽의 결합 세기가 <code class="css-v5nfi0">1</code> 더 크도록 설정하겠습니다. <code class="css-v5nfi0">0</code>을 입력의 마지막 부분을 나타내는 결합 세기로 나타내고, 연산자 중 가장 낮은 결합 세기를 <code class="css-v5nfi0">1</code>이라고 미리 약속해두겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">op</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">peek</span>() {
            Token::Eof =&gt; <span class="hljs-keyword">break</span>,
            Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; op,
            t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
        };
        <span class="hljs-keyword">let</span> (l_bp, r_bp) = <span class="hljs-title hljs-function hljs-invoke">infix_binding_power</span>(op);
        todo!()
    }
    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">infix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        <span class="hljs-string">&#x27;*&#x27;</span> | <span class="hljs-string">&#x27;/&#x27;</span> =&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>)
    }
}
</code></div></pre>
<p>이제부터 조금 복잡해질텐데, 재귀호출을 사용해보겠습니다. 아래 예시를 보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">a   +   b   *   c   *   d   +   e
  1   2   3   4   3   4   1   2
</code></div></pre>
<p>파싱은 토큰을 왼쪽에서 오른쪽으로 스캔하며 진행이 될텐데, 현재 토큰을 가리키는 커서가 있다고 생각해보죠.</p>
<p>커서가 처음 <code class="css-v5nfi0">+</code>를 만나게 되면, <code class="css-v5nfi0">l_bp</code>는 <code class="css-v5nfi0">1</code>, <code class="css-v5nfi0">r_bp</code>는 <code class="css-v5nfi0">2</code>일 것이고, <code class="css-v5nfi0">lhs</code>는 <code class="css-v5nfi0">a</code>를 담고 있을 것입니다. 다음에 보이는 연산자인 <code class="css-v5nfi0">*</code>는 <code class="css-v5nfi0">+</code>보다 우선순위가 높으니, <code class="css-v5nfi0">a</code>와 <code class="css-v5nfi0">b</code>는 더하면 안되겠죠? 하지만 우리는 왼쪽에서 오른쪽으로 커서를 움직이고 있으니, <code class="css-v5nfi0">+</code>를 바라보고 있는 시점에는 <code class="css-v5nfi0">*</code>의 존재 유무를 모를 것입니다. lookahead(전방탐색)를 추가하면 해결할 수 있을까요? 안될건 없지만 그 범위가 얼마나 될지 가늠이 안됩니다. 지금 예시만 봐도 <code class="css-v5nfi0">b</code>, <code class="css-v5nfi0">c</code>, <code class="css-v5nfi0">d</code> 토큰을 전부 스캔해야만 우선순위 처리를 제대로 할 수 있을 테니까요.</p>
<p>첫 번째 <code class="css-v5nfi0">+</code>이후에 나오는 표현식 <code class="css-v5nfi0">b * c * d</code>까지는 높은 우선순위로 파싱을 해야 합니다. 이는 꽤 직관적으로 판단할 수 있죠. 근데 <code class="css-v5nfi0">d</code>까지만 파싱해야 하는 이유는 무엇일까요? 그 다음에 나오는 <code class="css-v5nfi0">+</code>의 우선순위가 처음에 본 <code class="css-v5nfi0">+</code>의 우선순위보다 높지 않기 때문입니다. 그 전까지 본 연산자들(<code class="css-v5nfi0">*</code>)은 모두 <code class="css-v5nfi0">+</code>보다 우선순위가 높았다는 것을 볼 수 있습니다.</p>
<p>이를 처리하기 위해 재귀를 사용하겠습니다. <code class="css-v5nfi0">b</code>에서 다시 <code class="css-v5nfi0">expr_bp</code>를 호출하면서, <code class="css-v5nfi0">+</code>보다 우선순위가 낮아지는 즉시, 즉 <code class="css-v5nfi0">bp</code>가 <code class="css-v5nfi0">2</code>보다 낮아지는 순간에 파싱을 멈추는 것입니다.</p>
<p>자, 아래에 미니멀한 프랫 파서가 완성되었습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr</span>(input: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lexer</span> = Lexer::<span class="hljs-title hljs-function hljs-invoke">new</span>(input);
    <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(&amp;<span class="hljs-keyword">mut</span> lexer, <span class="hljs-number">0</span>) <span class="hljs-comment">// 5</span>
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer, min_bp: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> S { <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">op</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">peek</span>() {
            Token::Eof =&gt; <span class="hljs-keyword">break</span>,
            Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; op,
            t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
        };

        <span class="hljs-keyword">let</span> (l_bp, r_bp) = <span class="hljs-title hljs-function hljs-invoke">infix_binding_power</span>(op);
        <span class="hljs-keyword">if</span> l_bp &lt; min_bp { <span class="hljs-comment">// 2</span>
            <span class="hljs-keyword">break</span>;
        }

        lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>(); <span class="hljs-comment">// 3</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
        lhs = S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, rhs]); <span class="hljs-comment">// 4</span>
    }

    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">infix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        <span class="hljs-string">&#x27;*&#x27;</span> | <span class="hljs-string">&#x27;/&#x27;</span> =&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>),
    }
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">tests</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;1&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;1&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;1 + 2 * 3&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(+ 1 (* 2 3))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;a + b * c * d + e&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(+ (+ a (* (* b c) d)) e)&quot;</span>);
}
</code></div></pre>
<ol>
<li><code class="css-v5nfi0">min_bp</code> 인자는 아주 중요한 변경사항입니다. <code class="css-v5nfi0">expr_bp</code>는 이제 특정 결합 세기 이상의 표현식만 파싱할 수도 있습니다. <code class="css-v5nfi0">min_bp</code>보다 결합 강도가 낮은 연산자를 만났을 경우, 즉시 파싱을 중단합니다.</li>
<li>이곳이 바로 파싱을 중단하는 시점입니다.</li>
<li><code class="css-v5nfi0">next</code> 호출로 인해 연산자 위에 있던 커서를 한 칸 움직이고, 재귀호출을 합니다. <code class="css-v5nfi0">min_bp</code>를 연산자의 <code class="css-v5nfi0">l_bp</code>와 비교하는 모습을 확인할 수 있습니다. 어떻게 보면 <code class="css-v5nfi0">min_bp</code>는 현재 파싱하고 있는 커다란 표현식의 왼쪽에 위치한 연산자의 결합 세기라고 생각할 수 있습니다.</li>
<li><code class="css-v5nfi0">rhs</code>를 잘 파싱하고 난 이후에는, 이미 파싱한 <code class="css-v5nfi0">lhs</code>와 결합하여 새로운 <code class="css-v5nfi0">lhs</code>를 만들어냅니다.</li>
<li>재귀호출의 시작 인자는 <code class="css-v5nfi0">0</code>입니다. 표현식의 양끝은 연산자가 없으므로 결합 세기가 <code class="css-v5nfi0">0</code>이라고 위에서 언급한 바 있습니다.</li>
</ol>
<p>위에 있는 약 40줄의 코드가 프랫 파싱 알고리즘이라고 할 수 있겠습니다. 조금 까다롭긴 하지만, 열심히 이해하고 나면, 이후에 추가하는 기능들은 꽤 단순합니다.</p>
<h2>연산자 추가해보기</h2>
<p>기본적인 뼈대는 완성되었으니, 이 알고리즘의 진가를 보여드리기 위해 다양한 표현식을 추가해보겠습니다.</p>
<p>먼저, 높은 우선순위를 가지고, 오른쪽으로 결합하는 함수 합성 연산자인 <code class="css-v5nfi0">.</code>을 추가해보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">infix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        <span class="hljs-string">&#x27;*&#x27;</span> | <span class="hljs-string">&#x27;/&#x27;</span> =&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
        <span class="hljs-string">&#x27;.&#x27;</span> =&gt; (<span class="hljs-number">6</span>, <span class="hljs-number">5</span>), <span class="hljs-comment">// NEW</span>
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>),
    }
}
</code></div></pre>
<p>맞습니다. 위와 같이 한 줄만 추가하면 충분합니다. 기존에 추가된 다른 연산자들과는 다르게 왼쪽 결합 세기가 더 강한 것을 확인할 수 있습니다. 결합 방향이 오른쪽이기를 원하기 때문이죠.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;f . g . h&quot;</span>);
<span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(. f (. g h))&quot;</span>);

<span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot; 1 + 2 + f . g . h * 3 * 4&quot;</span>);
<span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))&quot;</span>);
</code></div></pre>
<h3>전위 단항연산자 <code class="css-v5nfi0">-</code></h3>
<p>이제 단항연산자 <code class="css-v5nfi0">-</code>를 추가해보겠습니다. 이 연산자는 이항 산술연산자들보다는 더 강하게 결합하고, 함수 합성 연산자(<code class="css-v5nfi0">.</code>)보다는 약하게 결합합니다.</p>
<p>단항연산자가 추가되면 수정해야 하는 부분이 있습니다. 루프가 시작하는 시점에 첫 번째 토큰은 아톰만 가능하다고 가정했으나, <code class="css-v5nfi0">-5</code>와 같이 연산자로 시작하는 표현식이 생기기 때문에 이 또한 처리해주어야 합니다.</p>
<p><code class="css-v5nfi0">-</code>는 전위 단항연산자이므로 오른쪽 결합 세기만 있습니다. 이를 타입을 통해 나타내보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">prefix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> ((), <span class="hljs-type">u8</span>) { <span class="hljs-comment">// 1</span>
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; ((), <span class="hljs-number">5</span>),
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>, op),
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">infix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        <span class="hljs-string">&#x27;*&#x27;</span> | <span class="hljs-string">&#x27;/&#x27;</span> =&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
        <span class="hljs-string">&#x27;.&#x27;</span> =&gt; (<span class="hljs-number">8</span>, <span class="hljs-number">7</span>), <span class="hljs-comment">// 2</span>
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>),
    }
}
</code></div></pre>
<ol>
<li>전위 연산자임을 명확하게 하기 위해 타입을 이와 같이 지정하겠습니다. 이 연산자들은 오른쪽에 있는 표현식들과만 결합할 수 있습니다.</li>
<li>단항연산자 <code class="css-v5nfi0">-</code>가 <code class="css-v5nfi0">.</code>보다는 약하게, 이항 <code class="css-v5nfi0">-</code>, <code class="css-v5nfi0">+</code> 보다는 강하게 결합하는 이전에 연산자임을 언급하였습니다. 이를 반영하기 위해 우선순위 값들의 조정이 필요합니다. 일반적으로는 홀수를 기본 결합세기로 맞춰놓은 다음, 결합 방향을 반영하기 위해 한쪽의 세기를 <code class="css-v5nfi0">1</code> 늘려주는 접근 방식을 사용합니다. 단항 <code class="css-v5nfi0">-</code>는 <code class="css-v5nfi0">5</code>, <code class="css-v5nfi0">6</code> 둘 다 상관없지만 일관성을 위해 홀수로 지정하였습니다.</li>
</ol>
<p><code class="css-v5nfi0">expr_bp</code>에 이를 반영해보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer, min_bp: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; {
            <span class="hljs-keyword">let</span> ((), r_bp) = <span class="hljs-title hljs-function hljs-invoke">prefix_binding_power</span>(op);
            todo!()
        }
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };
    ...
}
</code></div></pre>
<p>이제 반복문 안에 있는 <code class="css-v5nfi0">r_bp</code> 관련 로직들을 가져와 <code class="css-v5nfi0">todo!()</code>를 채워봅시다. 일부 코드는 <code class="css-v5nfi0">l_bp</code>와 관련있으니 제외하고 가져올 수 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer, min_bp: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; {
            <span class="hljs-keyword">let</span> ((), r_bp) = <span class="hljs-title hljs-function hljs-invoke">prefix_binding_power</span>(op);
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
            S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[rhs])
        }
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">op</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">peek</span>() {
            Token::Eof =&gt; <span class="hljs-keyword">break</span>,
            Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; op,
            t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
        };

        <span class="hljs-keyword">let</span> (l_bp, r_bp) = <span class="hljs-title hljs-function hljs-invoke">infix_binding_power</span>(op);
        <span class="hljs-keyword">if</span> l_bp &lt; min_bp {
            <span class="hljs-keyword">break</span>;
        }

        lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);

        lhs = S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, rhs]);
    }
    lhs
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">tests</span>() {
    ...

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;--1 * 2&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(* (- (- 1)) 2)&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;--f . g&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(- (- (. f g)))&quot;</span>);
}
</code></div></pre>
<p>이미 적어둔 로직을 거의 기계적으로 가져와 사용해봤는데, 꽤 잘 작동하는 것을 볼 수 있습니다. 먼저 단항연산자를 파싱하고 (있는 경우에), 그 연산자보다 강하게 결합하는 피연산자를 재귀호출을 통해 파싱하는 것입니다.</p>
<h3>후위연산자도 처리할 수 있을까?</h3>
<p>전위연산자 처리 로직을 넣어보았습니다. 이를 위해 <code class="css-v5nfi0">((), u8)</code> 타입을 사용했는데, 그럼 <code class="css-v5nfi0">(u8, ())</code>을 사용하면 후위연산자를 처리할 수 있을까요? 한번 해봅시다. 팩토리얼(<code class="css-v5nfi0">!</code>) 연산자가 적합한 것 같네요. <code class="css-v5nfi0">-</code>보다는 더 강하게 결합해야 할 것 같습니다. <code class="css-v5nfi0">-(92!)</code>가 <code class="css-v5nfi0">(-92)!</code>보다는 더 유용할 테니까요. 전위연산자를 추가할 때와 동일한 방법으로 진행해보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">let</span> (l_bp, ()) = <span class="hljs-title hljs-function hljs-invoke">postfix_binding_power</span>(op);
<span class="hljs-keyword">if</span> l_bp &lt; min_bp {
    <span class="hljs-keyword">break</span>;
}

<span class="hljs-keyword">let</span> (l_bp, r_bp) = <span class="hljs-title hljs-function hljs-invoke">infix_binding_power</span>(op);
<span class="hljs-keyword">if</span> l_bp &lt; min_bp {
    <span class="hljs-keyword">break</span>;
}
</code></div></pre>
<p>근데 뭔가 이상합니다. 전위 표현식을 파싱한 이후에는, 중위 연산자 <strong>혹은</strong> 후위 연산자를 만날 수 있습니다. 하지만 우리는 이미 등록되어있지 않은 연산자에 대해서는 그냥 <code class="css-v5nfi0">panic!</code>을 해버립니다. 후위연산자가 없는 경우에는 중위연산자를 찾아보도록 코드를 바꿔봅시다. 그러기 위해 <code class="css-v5nfi0">postfix_binding_power</code>이 option 타입을 돌려주도록 하겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer, min_bp: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; {
            <span class="hljs-keyword">let</span> ((), r_bp) = <span class="hljs-title hljs-function hljs-invoke">prefix_binding_power</span>(op);
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
            S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[rhs])
        }
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">op</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">peek</span>() {
            Token::Eof =&gt; <span class="hljs-keyword">break</span>,
            Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; op,
            t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
        };

        <span class="hljs-comment">// CHANGE START</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>((l_bp, ())) = <span class="hljs-title hljs-function hljs-invoke">postfix_binding_power</span>(op) {
            <span class="hljs-keyword">if</span> l_bp &lt; min_bp {
                <span class="hljs-keyword">break</span>;
            }

            lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>();
            lhs = S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs]);

            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-comment">// CHANGE END</span>

        <span class="hljs-keyword">let</span> (l_bp, r_bp) = <span class="hljs-title hljs-function hljs-invoke">infix_binding_power</span>(op);
        <span class="hljs-keyword">if</span> l_bp &lt; min_bp {
            <span class="hljs-keyword">break</span>;
        }

        lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);

        lhs = S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, rhs]);
    }

    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">prefix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> ((), <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; ((), <span class="hljs-number">5</span>),
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>, op),
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">postfix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u8</span>, ())&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;!&#x27;</span> =&gt; (<span class="hljs-number">7</span>, ()),
        _ =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,
    };
    <span class="hljs-title hljs-function hljs-invoke">Some</span>(res)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">infix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> (<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        <span class="hljs-string">&#x27;*&#x27;</span> | <span class="hljs-string">&#x27;/&#x27;</span> =&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
        <span class="hljs-string">&#x27;.&#x27;</span> =&gt; (<span class="hljs-number">10</span>, <span class="hljs-number">9</span>),
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>),
    }
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">tests</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;-9!&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(- (! 9))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;f . g !&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(! (. f g))&quot;</span>);
}
</code></div></pre>
<p>신기하게도 기존 테스트와 신규 테스트 모두 통과합니다.</p>
<h3>괄호 표현식</h3>
<p>새로운 표현식을 처리해봅시다. 바로 괄호 표현식인데요, 생각보다 어렵지 않습니다. 괄호 표현식은 꽤 기초적인 표현식으로 아톰과 비슷한 방식으로 처리할 수 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
    Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
    Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;(&#x27;</span>) =&gt; {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">lhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">assert_eq!</span>(lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>(), Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;)&#x27;</span>));
        lhs
    }
    Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; {
        <span class="hljs-keyword">let</span> ((), r_bp) = <span class="hljs-title hljs-function hljs-invoke">prefix_binding_power</span>(op);
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
        S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[rhs])
    }
    t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
};
</code></div></pre>
<p>하지만 이 테스트는 아직 통과하지 않습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;(((0)))&quot;</span>);
<span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;0&quot;</span>);
</code></div></pre>
<p>에러는 <code class="css-v5nfi0">loop</code> 블록에서 발생합니다. 현재 코드에서, 반복문에서 빠져나오는 유일한 조건은 <code class="css-v5nfi0">Eof</code>를 만났을 때입니다. 근데 이 지점에서 <code class="css-v5nfi0">)</code>를 만나면서, 이 <code class="css-v5nfi0">)</code> &quot;연산자&quot;가 밑에 있는 <code class="css-v5nfi0">infix_binding_power</code>에 넘겨지며 <code class="css-v5nfi0">panic!</code>을 하는 것이지요. 이를 해결하기 위한 가장 쉬운 방법은 <code class="css-v5nfi0">infix_binding_power</code>도 <code class="css-v5nfi0">postfix_binding_power</code>와 마찬가지로 식별하지 못한 연산자에 대해서는 option을 돌려주게 하는 것입니다.</p>
<p>이제는 테스트가 잘 통과하네요!</p>
<h3>배열 접근 연산자 <code class="css-v5nfi0">[]</code></h3>
<p>이제 배열 접근 연산자인 <code class="css-v5nfi0">a[i]</code>를 구현해봅시다. 지금까지 본 연산자들은 전위, 중위, 후위와 같이 분류할 수가 있었습니다. 이건 뭘까요? 그냥 <code class="css-v5nfi0">a[]</code>와 같이 생겼었다면 후위연산자였을 것이고, <code class="css-v5nfi0">[i]</code>였다면 괄호 표현식과 동일하게 동작했을 것입니다. 하지만 괄호 표현식과 비슷한 점이 있다면 괄호 안에 있는 표현식은 우선순위에 얽매이지 않는다는 겁니다. 한번 코드를 보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer, min_bp: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;(&#x27;</span>) =&gt; {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">lhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, <span class="hljs-number">0</span>);
            <span class="hljs-built_in">assert_eq!</span>(lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>(), Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;)&#x27;</span>));
            lhs
        }
        Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; {
            <span class="hljs-keyword">let</span> ((), r_bp) = <span class="hljs-title hljs-function hljs-invoke">prefix_binding_power</span>(op);
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
            S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[rhs])
        }
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">op</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">peek</span>() {
            Token::Eof =&gt; <span class="hljs-keyword">break</span>,
            Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; op,
            t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
        };

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>((l_bp, ())) = <span class="hljs-title hljs-function hljs-invoke">postfix_binding_power</span>(op) {
            <span class="hljs-keyword">if</span> l_bp &lt; min_bp {
                <span class="hljs-keyword">break</span>;
            }
            lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>();

			<span class="hljs-comment">// CHANGE START</span>
            lhs = <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;[&#x27;</span> {
                <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, <span class="hljs-number">0</span>);
                <span class="hljs-built_in">assert_eq!</span>(lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>(), Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;]&#x27;</span>));
                S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, rhs])
            } <span class="hljs-keyword">else</span> {
                S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs])
            };
			<span class="hljs-comment">// CHANGE END</span>
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>((l_bp, r_bp)) = <span class="hljs-title hljs-function hljs-invoke">infix_binding_power</span>(op) {
            <span class="hljs-keyword">if</span> l_bp &lt; min_bp {
                <span class="hljs-keyword">break</span>;
            }

            lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>();
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);

            lhs = S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, rhs]);
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">break</span>;
    }

    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">prefix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> ((), <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; ((), <span class="hljs-number">5</span>),
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>, op),
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">postfix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u8</span>, ())&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;!&#x27;</span> | <span class="hljs-string">&#x27;[&#x27;</span> =&gt; (<span class="hljs-number">7</span>, ()), <span class="hljs-comment">// 1</span>
        _ =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,
    };
    <span class="hljs-title hljs-function hljs-invoke">Some</span>(res)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">infix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>)&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>),
        <span class="hljs-string">&#x27;*&#x27;</span> | <span class="hljs-string">&#x27;/&#x27;</span> =&gt; (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>),
        <span class="hljs-string">&#x27;.&#x27;</span> =&gt; (<span class="hljs-number">10</span>, <span class="hljs-number">9</span>),
        _ =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,
    };
    <span class="hljs-title hljs-function hljs-invoke">Some</span>(res)
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">tests</span>() {
    ...
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;x[0][1]&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;([ ([ x 0) 1)&quot;</span>);
}
</code></div></pre>
<ol>
<li><code class="css-v5nfi0">!</code>과 <code class="css-v5nfi0">[</code>에 동일한 우선순위를 부여한 것이 보이나요? 일반적으로는 이 알고리즘의 correctness를 위해서 우선순위가 겹치지 않게 하는 것이 꽤 중요합니다. 하지만 우리가 결합 세기를 비교하는 경우에는, <strong>오른쪽 결합 세기</strong>와 <strong>왼쪽 결합 세기</strong>만 비교하기 때문에, 두 후위연산자의 결합 세기가 겹쳐도 문제가 생기지 않습니다.</li>
</ol>
<h3>삼항연산자 <code class="css-v5nfi0">? :</code></h3>
<p>최종 보스를 만나보겠습니다. 바로 삼항연산자입니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">c ? e1 : e2
</code></div></pre>
<p>이건 어떻게 분류해야 할까요?? 한번 기호만 살짝 바꿔보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">c [ e1 ] e2
</code></div></pre>
<p>감이 잡히나요? 앞부분에서 <code class="css-v5nfi0">a[i]</code>는 후위연산자 + 괄호표현식인 것을 보았습니다. 그러니 어떻게 보면 삼항연산자는 <code class="css-v5nfi0">a[i]</code>의 변형된 형태라고 생각할 수 있습니다. 이제 결합 세기와 방향을 생각해보겠습니다. 이런 경우에는 결합 방향이 어떻게 될까요?</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">a ? b : c ? d : e
</code></div></pre>
<p>더 단순하게 보기 위해 좀 생략된 표현을 보겠습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">a ?: c ?: e
</code></div></pre>
<p>위 표현식은 이렇게 파싱하거나:</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">(a ?: c) ?: e
</code></div></pre>
<p>이렇게 파싱할 수도 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">a ?: (c ?: e)
</code></div></pre>
<p>무엇이 더 유용할까요? 이렇게 연속으로 사용하는 경우에는:</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">a ? b :
c ? d :
e
</code></div></pre>
<p>오른쪽으로 결합하는 쪽이 더 유용할 것 같네요. 결합 세기의 경우에는, 꽤 낮은 우선순위를 가지고 있습니다. <a class="css-1bas2qp">C언어에서는</a> <code class="css-v5nfi0">=</code>와 <code class="css-v5nfi0">,</code>만이 더 낮은 우선순위를 가지고 있습니다.</p>
<p>아래 코드를 통해 저희의 완성된 프랫 파서를 볼 수 있습니다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-rust"><span class="hljs-keyword">use</span> std::{fmt, io::BufRead};

<span class="hljs-keyword">enum</span> <span class="hljs-title hljs-class">S</span> {
    <span class="hljs-title hljs-function hljs-invoke">Atom</span>(<span class="hljs-type">char</span>),
    <span class="hljs-title hljs-function hljs-invoke">Cons</span>(<span class="hljs-type">char</span>, <span class="hljs-type">Vec</span>&lt;S&gt;),
}

<span class="hljs-keyword">impl</span> <span class="hljs-title hljs-class">fmt</span>::Display <span class="hljs-keyword">for</span> <span class="hljs-title hljs-class">S</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">fmt</span>(&amp;<span class="hljs-keyword">self</span>, f: &amp;<span class="hljs-keyword">mut</span> fmt::Formatter&lt;<span class="hljs-symbol">&#x27;_</span>&gt;) <span class="hljs-punctuation">-&gt;</span> fmt::<span class="hljs-type">Result</span> {
        <span class="hljs-keyword">match</span> <span class="hljs-keyword">self</span> {
            S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(i) =&gt; <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;{}&quot;</span>, i),
            S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(head, rest) =&gt; {
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;({}&quot;</span>, head)?;
                <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> rest {
                    <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot; {}&quot;</span>, s)?
                }
                <span class="hljs-built_in">write!</span>(f, <span class="hljs-string">&quot;)&quot;</span>)
            }
        }
    }
}

<span class="hljs-meta">#[derive(Debug, Clone, Copy, PartialEq, Eq)]</span>
<span class="hljs-keyword">enum</span> <span class="hljs-title hljs-class">Token</span> {
    <span class="hljs-title hljs-function hljs-invoke">Atom</span>(<span class="hljs-type">char</span>),
    <span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-type">char</span>),
    Eof,
}

<span class="hljs-keyword">struct</span> <span class="hljs-title hljs-class">Lexer</span> {
    tokens: <span class="hljs-type">Vec</span>&lt;Token&gt;,
}

<span class="hljs-keyword">impl</span> <span class="hljs-title hljs-class">Lexer</span> {
    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">new</span>(input: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Lexer {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">tokens</span> = input
            .<span class="hljs-title hljs-function hljs-invoke">chars</span>()
            .<span class="hljs-title hljs-function hljs-invoke">filter</span>(|it| !it.<span class="hljs-title hljs-function hljs-invoke">is_ascii_whitespace</span>())
            .<span class="hljs-title hljs-function hljs-invoke">map</span>(|c| <span class="hljs-keyword">match</span> c {
                <span class="hljs-string">&#x27;0&#x27;</span>..=<span class="hljs-string">&#x27;9&#x27;</span>
                | <span class="hljs-string">&#x27;a&#x27;</span>..=<span class="hljs-string">&#x27;z&#x27;</span> | <span class="hljs-string">&#x27;A&#x27;</span>..=<span class="hljs-string">&#x27;Z&#x27;</span> =&gt; Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(c),
                _ =&gt; Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(c),
            })
            .collect::&lt;<span class="hljs-type">Vec</span>&lt;_&gt;&gt;();
        tokens.<span class="hljs-title hljs-function hljs-invoke">reverse</span>();
        Lexer { tokens }
    }

    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Token {
        <span class="hljs-keyword">self</span>.tokens.<span class="hljs-title hljs-function hljs-invoke">pop</span>().<span class="hljs-title hljs-function hljs-invoke">unwrap_or</span>(Token::Eof)
    }

    <span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">peek</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Token {
        <span class="hljs-keyword">self</span>.tokens.<span class="hljs-title hljs-function hljs-invoke">last</span>().<span class="hljs-title hljs-function hljs-invoke">copied</span>().<span class="hljs-title hljs-function hljs-invoke">unwrap_or</span>(Token::Eof)
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr</span>(input: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lexer</span> = Lexer::<span class="hljs-title hljs-function hljs-invoke">new</span>(input);
    <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(&amp;<span class="hljs-keyword">mut</span> lexer, <span class="hljs-number">0</span>)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">expr_bp</span>(lexer: &amp;<span class="hljs-keyword">mut</span> Lexer, min_bp: <span class="hljs-type">u8</span>) <span class="hljs-punctuation">-&gt;</span> S {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">lhs</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>() {
        Token::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it) =&gt; S::<span class="hljs-title hljs-function hljs-invoke">Atom</span>(it),
        Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;(&#x27;</span>) =&gt; {
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">lhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, <span class="hljs-number">0</span>);
            <span class="hljs-built_in">assert_eq!</span>(lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>(), Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;)&#x27;</span>));
            lhs
        }
        Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; {
            <span class="hljs-keyword">let</span> ((), r_bp) = <span class="hljs-title hljs-function hljs-invoke">prefix_binding_power</span>(op);
            <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
            S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[rhs])
        }
        t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
    };

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">op</span> = <span class="hljs-keyword">match</span> lexer.<span class="hljs-title hljs-function hljs-invoke">peek</span>() {
            Token::Eof =&gt; <span class="hljs-keyword">break</span>,
            Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(op) =&gt; op,
            t =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad token: {:?}&quot;</span>, t),
        };

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>((l_bp, ())) = <span class="hljs-title hljs-function hljs-invoke">postfix_binding_power</span>(op) {
            <span class="hljs-keyword">if</span> l_bp &lt; min_bp {
                <span class="hljs-keyword">break</span>;
            }
            lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>();

            lhs = <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;[&#x27;</span> {
                <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, <span class="hljs-number">0</span>);
                <span class="hljs-built_in">assert_eq!</span>(lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>(), Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;]&#x27;</span>));
                S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, rhs])
            } <span class="hljs-keyword">else</span> {
                S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs])
            };
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">Some</span>((l_bp, r_bp)) = <span class="hljs-title hljs-function hljs-invoke">infix_binding_power</span>(op) {
            <span class="hljs-keyword">if</span> l_bp &lt; min_bp {
                <span class="hljs-keyword">break</span>;
            }
            lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>();

            lhs = <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;?&#x27;</span> {
                <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">mhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, <span class="hljs-number">0</span>);
                <span class="hljs-built_in">assert_eq!</span>(lexer.<span class="hljs-title hljs-function hljs-invoke">next</span>(), Token::<span class="hljs-title hljs-function hljs-invoke">Op</span>(<span class="hljs-string">&#x27;:&#x27;</span>));
                <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
                S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, mhs, rhs])
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">rhs</span> = <span class="hljs-title hljs-function hljs-invoke">expr_bp</span>(lexer, r_bp);
                S::<span class="hljs-title hljs-function hljs-invoke">Cons</span>(op, <span class="hljs-built_in">vec!</span>[lhs, rhs])
            };
            <span class="hljs-keyword">continue</span>;
        }

        <span class="hljs-keyword">break</span>;
    }

    lhs
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">prefix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> ((), <span class="hljs-type">u8</span>) {
    <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; ((), <span class="hljs-number">9</span>),
        _ =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">&quot;bad op: {:?}&quot;</span>, op),
    }
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">postfix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u8</span>, ())&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;!&#x27;</span> =&gt; (<span class="hljs-number">11</span>, ()),
        <span class="hljs-string">&#x27;[&#x27;</span> =&gt; (<span class="hljs-number">11</span>, ()),
        _ =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,
    };
    <span class="hljs-title hljs-function hljs-invoke">Some</span>(res)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">infix_binding_power</span>(op: <span class="hljs-type">char</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;(<span class="hljs-type">u8</span>, <span class="hljs-type">u8</span>)&gt; {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">res</span> = <span class="hljs-keyword">match</span> op {
        <span class="hljs-string">&#x27;=&#x27;</span> =&gt; (<span class="hljs-number">2</span>, <span class="hljs-number">1</span>),
        <span class="hljs-string">&#x27;?&#x27;</span> =&gt; (<span class="hljs-number">4</span>, <span class="hljs-number">3</span>),
        <span class="hljs-string">&#x27;+&#x27;</span> | <span class="hljs-string">&#x27;-&#x27;</span> =&gt; (<span class="hljs-number">5</span>, <span class="hljs-number">6</span>),
        <span class="hljs-string">&#x27;*&#x27;</span> | <span class="hljs-string">&#x27;/&#x27;</span> =&gt; (<span class="hljs-number">7</span>, <span class="hljs-number">8</span>),
        <span class="hljs-string">&#x27;.&#x27;</span> =&gt; (<span class="hljs-number">14</span>, <span class="hljs-number">13</span>),
        _ =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>,
    };
    <span class="hljs-title hljs-function hljs-invoke">Some</span>(res)
}

<span class="hljs-meta">#[test]</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">tests</span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;1&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;1&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;1 + 2 * 3&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(+ 1 (* 2 3))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;a + b * c * d + e&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(+ (+ a (* (* b c) d)) e)&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;f . g . h&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(. f (. g h))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot; 1 + 2 + f . g . h * 3 * 4&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(
        s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(),
        <span class="hljs-string">&quot;(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))&quot;</span>,
    );

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;--1 * 2&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(* (- (- 1)) 2)&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;--f . g&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(- (- (. f g)))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;-9!&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(- (! 9))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;f . g !&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(! (. f g))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;(((0)))&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;0&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;x[0][1]&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;([ ([ x 0) 1)&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(
        <span class="hljs-string">&quot;a ? b :
         c ? d
         : e&quot;</span>,
    );
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(? a b (? c d e))&quot;</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(<span class="hljs-string">&quot;a = 0 ? b : c = d&quot;</span>);
    <span class="hljs-built_in">assert_eq!</span>(s.<span class="hljs-title hljs-function hljs-invoke">to_string</span>(), <span class="hljs-string">&quot;(= a (= (? 0 b c) d))&quot;</span>)
}

<span class="hljs-keyword">fn</span> <span class="hljs-title hljs-function">main</span>() {
    <span class="hljs-keyword">for</span> <span class="hljs-variable">line</span> <span class="hljs-keyword">in</span> std::io::<span class="hljs-title hljs-function hljs-invoke">stdin</span>().<span class="hljs-title hljs-function hljs-invoke">lock</span>().<span class="hljs-title hljs-function hljs-invoke">lines</span>() {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">line</span> = line.<span class="hljs-title hljs-function hljs-invoke">unwrap</span>();
        <span class="hljs-keyword">let</span> <span class="hljs-keyword"></span><span class="hljs-variable">s</span> = <span class="hljs-title hljs-function hljs-invoke">expr</span>(&amp;line);
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;{}&quot;</span>, s)
    }
}
</code></div></pre>
<p>코드는 <a class="css-1bas2qp">이 레포</a>에서도 확인해볼 수 있습니다. Eof.</p></div></div></div><div id="utterances-comments" class="css-18bh6q1"></div></div></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"20230430-simple-but-powerful-pratt-parsing","content":"\n아래 글은 [matklad](https://github.com/matklad)의 [Simple but Powerful Pratt Parsing](https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html)의 번역 포스팅입니다. 제 스스로의 이해를 돕기 위함이 목적이지만, 유익한 글인 것 같아 블로그에 소개하고도 싶었습니다.\n\n## Simple but Powerful Pratt Parsing\n\n프랫 파싱 글에 온 것을 환영합니다! 프랫 파싱은 구문 분석계의 모나드 튜토리얼과 같다고도 할 수 있습니다. 이 주제에 관한 소개글은 너무 많아서 [이런 튜토리얼 모음](https://www.oilshell.org/blog/2017/03/31.html)까지 있을 정도입니다.\n\n이 글의 목표는 아래와 같습니다.\n\n- 이른바 left-recursion 문제가 과장되었음을 제기하기 위해\n- BNF 표기법이 중위표현식을 표현하기에 부적합함을 지적하기 위해\n- 프랫 파싱 알고리즘의 구현을 과한 추상화 없이, 있는 그대로 보여주기 위해\n- 이 알고리즘을 제가 제대로 이해하기 위해 (제가 실사용 용도로 프랫 파서를 [구현](https://github.com/rust-lang/rust-analyzer/blob/c388130f5ffbcbe7d3131213a24d12d02f769b87/crates/ra_parser/src/grammar/expressions.rs#L280-L281)한 적이 있는데, 이제는 코드를 봐도 바로 이해되지가 않더라고요)\n\n## Introduction\n\n파싱이라는 것은, 일련의 토큰들이 컴파일러에 의해 트리 구조로 변환되는 과정을 이야기합니다.\n\n```plaintext\n                            Add\n                 Parser     / \\\n \"1 + 2 * 3\"    -------\u003e   1  Mul\n                              / \\\n                             2   3\n```\n\n파싱을 접근하는 방식은 다양한데, 크게 두 부류로 나눠볼 수 있습니다.\n\n- 파싱하려는 언어의 문법을 DSL을 사용하여 표현하고, 그 문법을 이용하여 파서를 생성해내는 방법\n- 직접 손으로 파서를 작성하는 방법\n\n두 번째 방식 안에서 가장 널리 사용되는 기법이 바로 프랫 파싱입니다.\n\n## BNF\n\n문맥 자유(Context-Free) 문법 표기법(주로 BNF concrete syntax를 사용)은 구문분석 이론에 중요한 발견이었습니다. BNF를 사용하면 다음과 같이 본래 선형적인 문장 구조를 트리 형태로 나타낼 수 있습니다.\n\n```plaintext\nItem ::=\n    StructItem\n  | EnumItem\n  | ...\n\nStructItem ::=\n    'struct' Name '{' FieldList '}'\n\n...\n```\n\n처음 이 기법을 보며 감탄했던 기억이 납니다.\n\n표현식을 나타내는 방식을 보고 갑자기 좀 서운해졌지만요.\n\n표현식을 나타내는 직관적인 형태의 문법을 살펴보겠습니다.\n\n```plaintext\nExpr ::=\n    Expr '+' Expr\n  | Expr '*' Expr\n  | '(' Expr ')'\n  | 'number'\n```\n\n꽤 직관적이죠. 근데 사실 위 문법은 **모호**해서 자동 파서 생성기(위에서 언급된 1번 방식)에 사용되기 위해서는 고쳐서 작성되어야 합니다. 더 구체적으로 얘기하자면, 연산자의 우선순위와 결합방향을 잘 고려한 문법을 작성해야 하는데요, 아래와 같이 수정하면 앞서 언급된 문제들을 해결할 수 있습니다.\n\n```plaintext\nExpr ::=\n    Factor\n  | Expr '+' Factor\n\nFactor ::=\n    Atom\n  | Factor '*' Atom\n\nAtom ::=\n    'number'\n  | '(' Expr ')'\n```\n\n어떤가요? 솔직히 이 새로운 문법은 제가 처음 생각했던 표현식의 모양과는 전혀 달라 보입니다. 가장 먼저 나온 모호한 문법이 더 직관적이고, 더군다나 제가 스스로 문법을 이렇게 고칠 수 있을때까지 언어론에 대해 전공수업만 세네개 들었어야 했던 것 같습니다.\n\n이것이 제가 프랫 파싱을 좋아하는 이유입니다. 문법을 부자연스럽게 고쳐야 하는 재귀하향식 파싱 기법에서 발전해서, 연산자와 결합방향을 자연스럽게 표현할 수 있기 때문입니다.\n\n## 재귀하향과 Left-Recursion\n\n재귀하향은 직접 파서를 짤 때 사용할 수 있는 가장 기본적인 기법입니다. 이 기법은 서로 재귀적인 함수들을 사용하여 파싱을 하는데, 예를 들어 위에 있는 문법은 재귀하향을 썼을 때 다음과 같이 코드로 표현할 수 있습니다.\n\n```rust\nfn item(p: \u0026mut Parser) {\n    match p.peek() {\n        STRUCT_KEYWORD =\u003e struct_item(p),\n        ENUM_KEYWORD   =\u003e enum_item(p),\n        ...\n    }\n}\n\nfn struct_item(p: \u0026mut Parser) {\n    p.expect(STRUCT_KEYWORD);\n    name(p);\n    p.expect(L_CURLY);\n    field_list(p);\n    p.expect(R_CURLY);\n}\n```\n\n보통 교과서들은 Left Recursive 문법을 이 접근 방식의 단점이라고 지적하면서, 더 심화된 LR 파싱 기법으로 넘어가는 동기로 삼습니다. Left Recursion은 분명히 문제가 되는 시점들이 있는데, 아래 문법을 한 번 보겠습니다.\n\n```plaintext\nSum ::=\n    Sum '+' Int\n  | Int\n```\n\n재귀하향 방식으로 위 문법에 대한 파서를 작성해보겠습니다.\n\n```rust\nfn sum(p: \u0026mut Parser) {\n    // Sum '+' Int가 되는지 먼저 시도해본다\n    sum(p); // ①\n    p.expect(PLUS);\n    int(p);\n    // 위에서 실패했으면, 그 다음 후보지를 시도해본다.\n    ...\n}\n```\n\n1. 이 코드를 실행하면 코드가 무한 재귀에 빠져버려서 스택 오버플로우가 발생해버립니다.\n\n이런 문제를 고치기 위한 이론적인 방법은 역시 문법을 수정해서, **같은 언어를 표현하되 위와 같은 문제가 발생하지 않도록 Left Recursion을 없앤 문법**을 작성하는 것입니다.\n\n하지만 직접 작성하는 파서의 경우에는 실용적인 해결방법도 있는데, 그냥 재귀를 버리고 반복문을 사용하는 것입니다.\n\n```rust\nfn sum(p: \u0026mut Parser) {\n    int(p);\n    while p.eat(PLUS) {\n        int(p);\n    }\n}\n```\n\n## 프랫 파싱의 뼈대\n\n위와 같이 반복문을 이용해서 Left Recursion을 실용적으로 대처하는 방법을 보았는데, 프랫 파싱은 반복문과 재귀를 동시에 사용합니다.\n\n```rust\nfn parse_expr() {\n    ...\n    loop {\n        ...\n        parse_expr()\n        ...\n    }\n}\n```\n\n위에 있는 코드는 연산자 우선순위와 결합방향을 잘 처리해줍니다. 머리가 띵해지긴 하지만요.\n\n## 우선순위에서 결합 세기로\n\n솔직히 말하면 저는 \"높은 우선순위\"와 \"낮은 우선순위\"라는 용어를 보며 항상 헷갈리는 것 같습니다. `a + b * c` 라는 표현식 안에서 덧셈은 우선순위가 **낮은데**, 파싱 트리에서는 **맨 위에** 있습니다.\n\n그래서 저는 **결합 세기**라는 표현이 더 직관적이라고 생각합니다.\n\n```plaintext\nexpr:   A       +       B       *       C\npower:      3       3       5       5\n```\n\n`*`이 더 세니까 B와 C를 끌어당기는 힘이 더 세고, 위 표현식은 `A + (B * C)`와 같이 파싱이 되는 것입니다.\n\n결합 방향은 어떻게 표현할 수 있을까요? `A + B + C`를 보면 모든 연산자들이 같은 세기를 가지고 있어서 어떻게 파싱이 되어야 할지 불명확합니다. 하지만 이것도 아래와 같이 결합 세기로 표현할 수가 있습니다.\n\n```plaintext\nexpr:      A       +       B       +       C\npower:  0      3      3.1      3      3.1     0\n```\n\n오른쪽 피연산자를 당기는 힘이 더 강해지도록 `+`의 오른쪽 결합 세기를 조금 올린 것을 볼 수 있습니다. 양옆 끝에 `0`이 있는 것도 볼 수 있는데, 이건 맨 끝에서는 당기는 힘이 없다는 것을 표현한 것입니다. B의 입장에서 봤을 때, 왼쪽에서 더 강하게 결합하려고 하기 때문에 우선 첫 단계로는 아래와 같이 파싱이 될 것입니다.\n\n```plaintext\nexpr:     (A + B)     +     C\npower:  0          3    3.1    0\n```\n\n그 다음 단계를 거치면 결국 `(A + B) + C` 가 됩니다.\n\n프랫 파싱이 하는 일은 스트링을 왼쪽에서 오른쪽으로 읽으며 우리가 위에서 본 과정을 전부 처리하는 것입니다.\n\n오른쪽으로 결합하는 연산자는 어떻게 처리하면 좋을까요? 예시로, 하스켈에 있는 함수 합성 연산자 `.`는 다음과 같이 모델링할 수 있습니다\n\n```plaintext\n  f     .    g     .    h\n0   8.5    8   8.5    8   0\n```\n\n그러면 위 표현식은 `f . (g . h)` 와 같이 파싱이 되는 것입니다.\n\n## 미니멀한 프랫 파서\n\n이제부터 프랫 파서를 이용해서 캐릭터 하나짜리 숫자와 변수(묶어서 아톰), 그리고 특수문자를 사용한 연산자가 있는 표현식을 파싱해보겠습니다.\n\n```rust\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Token {\n    Atom(char),\n    Op(char),\n    Eof,\n}\n\nstruct Lexer {\n    tokens: Vec\u003cToken\u003e,\n}\n\nimpl Lexer {\n    fn new(input: \u0026str) -\u003e Lexer {\n        let mut tokens = input\n            .chars()\n            .filter(|it| !it.is_ascii_whitespace())\n            .map(|c| match c {\n                '0'..='9' |\n                'a'..='z' | 'A'..='Z' =\u003e Token::Atom(c),\n                _ =\u003e Token::Op(c),\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        tokens.reverse();\n        Lexer { tokens }\n    }\n\n    fn next(\u0026mut self) -\u003e Token {\n        self.tokens.pop().unwrap_or(Token::Eof)\n    }\n\n    fn peek(\u0026mut self) -\u003e Token {\n        self.tokens.last().copied().unwrap_or(Token::Eof)\n    }\n}\n```\n\n결합 세기가 잘 반영되어 파싱됐는지 확인해보기 위해, 파싱된 표현식을 중위표현식에서 널리 사용되는 표현 방식으로 변환해보겠습니다. 이 방식은 (아마도 폴란드에서는 별로 인기가 없겠지만) 바로 S-표현식입니다. Lisp 계열 언어에서 지겹도록 볼 수있는 표현 방식이죠.\n\n```plaintext\n1 + 2 * 3 == (+ 1 (* 2 3))\n```\n\n```rust\nuse std::fmt;\n\nenum S {\n    Atom(char),\n    Cons(char, Vec\u003cS\u003e),\n}\n\nimpl fmt::Display for S {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            S::Atom(i) =\u003e write!(f, \"{}\", i),\n            S::Cons(head, rest) =\u003e {\n                write!(f, \"({}\", head)?;\n                for s in rest {\n                    write!(f, \" {}\", s)?\n                }\n                write!(f, \")\")\n            }\n        }\n    }\n}\n```\n\n단순하게 시작하죠. 먼저 아톰과 `+`, `*` 연산자만으로 이루어진 표현식을 파싱해봅시다.\n\n```rust\nfn expr(input: \u0026str) -\u003e S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(\u0026mut lexer)\n}\n\nfn expr_bp(lexer: \u0026mut Lexer) -\u003e S {\n    todo!()\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\")\n}\n```\n\n위에서 본 left recursion에 대한 **실용적인 대처방식**과 유사하게 접근해보겠습니다. 먼저 숫자를 파싱하고, 반복문을 돌고, 연산자를 파싱하고 나서는, 음.. 아직은 모르겠네요.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer) -\u003e S {\n    let lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.next() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n        todo!()\n    }\n    lhs\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n}\n```\n\n그래도 첫 번째 테스트는 벌써 통과합니다!\n\n앞서 언급한 **결합 세기**의 개념을 코드에 도입해봅시다. 각 연산자마다 양옆을 당기는 힘을 `u8`로 각각 나타내고, 결합 방향을 표현하기 위해 한쪽의 결합 세기가 `1` 더 크도록 설정하겠습니다. `0`을 입력의 마지막 부분을 나타내는 결합 세기로 나타내고, 연산자 중 가장 낮은 결합 세기를 `1`이라고 미리 약속해두겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer) -\u003e S {\n    let lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n        let (l_bp, r_bp) = infix_binding_power(op);\n        todo!()\n    }\n    lhs\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        _ =\u003e panic!(\"bad op: {:?}\")\n    }\n}\n```\n\n이제부터 조금 복잡해질텐데, 재귀호출을 사용해보겠습니다. 아래 예시를 보겠습니다.\n\n```plaintext\na   +   b   *   c   *   d   +   e\n  1   2   3   4   3   4   1   2\n```\n\n파싱은 토큰을 왼쪽에서 오른쪽으로 스캔하며 진행이 될텐데, 현재 토큰을 가리키는 커서가 있다고 생각해보죠.\n\n커서가 처음 `+`를 만나게 되면, `l_bp`는 `1`, `r_bp`는 `2`일 것이고, `lhs`는 `a`를 담고 있을 것입니다. 다음에 보이는 연산자인 `*`는 `+`보다 우선순위가 높으니, `a`와 `b`는 더하면 안되겠죠? 하지만 우리는 왼쪽에서 오른쪽으로 커서를 움직이고 있으니, `+`를 바라보고 있는 시점에는 `*`의 존재 유무를 모를 것입니다. lookahead(전방탐색)를 추가하면 해결할 수 있을까요? 안될건 없지만 그 범위가 얼마나 될지 가늠이 안됩니다. 지금 예시만 봐도 `b`, `c`, `d` 토큰을 전부 스캔해야만 우선순위 처리를 제대로 할 수 있을 테니까요.\n\n첫 번째 `+`이후에 나오는 표현식 `b * c * d`까지는 높은 우선순위로 파싱을 해야 합니다. 이는 꽤 직관적으로 판단할 수 있죠. 근데 `d`까지만 파싱해야 하는 이유는 무엇일까요? 그 다음에 나오는 `+`의 우선순위가 처음에 본 `+`의 우선순위보다 높지 않기 때문입니다. 그 전까지 본 연산자들(`*`)은 모두 `+`보다 우선순위가 높았다는 것을 볼 수 있습니다.\n\n이를 처리하기 위해 재귀를 사용하겠습니다. `b`에서 다시 `expr_bp`를 호출하면서, `+`보다 우선순위가 낮아지는 즉시, 즉 `bp`가 `2`보다 낮아지는 순간에 파싱을 멈추는 것입니다.\n\n자, 아래에 미니멀한 프랫 파서가 완성되었습니다.\n\n```rust\nfn expr(input: \u0026str) -\u003e S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(\u0026mut lexer, 0) // 5\n}\n\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S { // 1\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp \u003c min_bp { // 2\n            break;\n        }\n\n        lexer.next(); // 3\n        let rhs = expr_bp(lexer, r_bp);\n        lhs = S::Cons(op, vec![lhs, rhs]); // 4\n    }\n\n    lhs\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\");\n\n    let s = expr(\"a + b * c * d + e\");\n    assert_eq!(s.to_string(), \"(+ (+ a (* (* b c) d)) e)\");\n}\n```\n\n1. `min_bp` 인자는 아주 중요한 변경사항입니다. `expr_bp`는 이제 특정 결합 세기 이상의 표현식만 파싱할 수도 있습니다. `min_bp`보다 결합 강도가 낮은 연산자를 만났을 경우, 즉시 파싱을 중단합니다.\n2. 이곳이 바로 파싱을 중단하는 시점입니다.\n3. `next` 호출로 인해 연산자 위에 있던 커서를 한 칸 움직이고, 재귀호출을 합니다. `min_bp`를 연산자의 `l_bp`와 비교하는 모습을 확인할 수 있습니다. 어떻게 보면 `min_bp`는 현재 파싱하고 있는 커다란 표현식의 왼쪽에 위치한 연산자의 결합 세기라고 생각할 수 있습니다.\n4. `rhs`를 잘 파싱하고 난 이후에는, 이미 파싱한 `lhs`와 결합하여 새로운 `lhs`를 만들어냅니다.\n5. 재귀호출의 시작 인자는 `0`입니다. 표현식의 양끝은 연산자가 없으므로 결합 세기가 `0`이라고 위에서 언급한 바 있습니다.\n\n위에 있는 약 40줄의 코드가 프랫 파싱 알고리즘이라고 할 수 있겠습니다. 조금 까다롭긴 하지만, 열심히 이해하고 나면, 이후에 추가하는 기능들은 꽤 단순합니다.\n\n## 연산자 추가해보기\n\n기본적인 뼈대는 완성되었으니, 이 알고리즘의 진가를 보여드리기 위해 다양한 표현식을 추가해보겠습니다.\n\n먼저, 높은 우선순위를 가지고, 오른쪽으로 결합하는 함수 합성 연산자인 `.`을 추가해보겠습니다.\n\n```rust\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (6, 5), // NEW\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n```\n\n맞습니다. 위와 같이 한 줄만 추가하면 충분합니다. 기존에 추가된 다른 연산자들과는 다르게 왼쪽 결합 세기가 더 강한 것을 확인할 수 있습니다. 결합 방향이 오른쪽이기를 원하기 때문이죠.\n\n```rust\nlet s = expr(\"f . g . h\");\nassert_eq!(s.to_string(), \"(. f (. g h))\");\n\nlet s = expr(\" 1 + 2 + f . g . h * 3 * 4\");\nassert_eq!(s.to_string(), \"(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))\");\n```\n\n### 전위 단항연산자 `-`\n\n이제 단항연산자 `-`를 추가해보겠습니다. 이 연산자는 이항 산술연산자들보다는 더 강하게 결합하고, 함수 합성 연산자(`.`)보다는 약하게 결합합니다.\n\n단항연산자가 추가되면 수정해야 하는 부분이 있습니다. 루프가 시작하는 시점에 첫 번째 토큰은 아톰만 가능하다고 가정했으나, `-5`와 같이 연산자로 시작하는 표현식이 생기기 때문에 이 또한 처리해주어야 합니다.\n\n`-`는 전위 단항연산자이므로 오른쪽 결합 세기만 있습니다. 이를 타입을 통해 나타내보겠습니다.\n\n```rust\nfn prefix_binding_power(op: char) -\u003e ((), u8) { // 1\n    match op {\n        '+' | '-' =\u003e ((), 5),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (8, 7), // 2\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n```\n\n1. 전위 연산자임을 명확하게 하기 위해 타입을 이와 같이 지정하겠습니다. 이 연산자들은 오른쪽에 있는 표현식들과만 결합할 수 있습니다.\n2. 단항연산자 `-`가 `.`보다는 약하게, 이항 `-`, `+` 보다는 강하게 결합하는 이전에 연산자임을 언급하였습니다. 이를 반영하기 위해 우선순위 값들의 조정이 필요합니다. 일반적으로는 홀수를 기본 결합세기로 맞춰놓은 다음, 결합 방향을 반영하기 위해 한쪽의 세기를 `1` 늘려주는 접근 방식을 사용합니다. 단항 `-`는 `5`, `6` 둘 다 상관없지만 일관성을 위해 홀수로 지정하였습니다.\n\n`expr_bp`에 이를 반영해보겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            todo!()\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n    ...\n}\n```\n\n이제 반복문 안에 있는 `r_bp` 관련 로직들을 가져와 `todo!()`를 채워봅시다. 일부 코드는 `l_bp`와 관련있으니 제외하고 가져올 수 있습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp \u003c min_bp {\n            break;\n        }\n\n        lexer.next();\n        let rhs = expr_bp(lexer, r_bp);\n\n        lhs = S::Cons(op, vec![lhs, rhs]);\n    }\n    lhs\n}\n\n#[test]\nfn tests() {\n    ...\n\n    let s = expr(\"--1 * 2\");\n    assert_eq!(s.to_string(), \"(* (- (- 1)) 2)\");\n\n    let s = expr(\"--f . g\");\n    assert_eq!(s.to_string(), \"(- (- (. f g)))\");\n}\n```\n\n이미 적어둔 로직을 거의 기계적으로 가져와 사용해봤는데, 꽤 잘 작동하는 것을 볼 수 있습니다. 먼저 단항연산자를 파싱하고 (있는 경우에), 그 연산자보다 강하게 결합하는 피연산자를 재귀호출을 통해 파싱하는 것입니다.\n\n### 후위연산자도 처리할 수 있을까?\n\n전위연산자 처리 로직을 넣어보았습니다. 이를 위해 `((), u8)` 타입을 사용했는데, 그럼 `(u8, ())`을 사용하면 후위연산자를 처리할 수 있을까요? 한번 해봅시다. 팩토리얼(`!`) 연산자가 적합한 것 같네요. `-`보다는 더 강하게 결합해야 할 것 같습니다. `-(92!)`가 `(-92)!`보다는 더 유용할 테니까요. 전위연산자를 추가할 때와 동일한 방법으로 진행해보겠습니다.\n\n```rust\nlet (l_bp, ()) = postfix_binding_power(op);\nif l_bp \u003c min_bp {\n    break;\n}\n\nlet (l_bp, r_bp) = infix_binding_power(op);\nif l_bp \u003c min_bp {\n    break;\n}\n```\n\n근데 뭔가 이상합니다. 전위 표현식을 파싱한 이후에는, 중위 연산자 **혹은** 후위 연산자를 만날 수 있습니다. 하지만 우리는 이미 등록되어있지 않은 연산자에 대해서는 그냥 `panic!`을 해버립니다. 후위연산자가 없는 경우에는 중위연산자를 찾아보도록 코드를 바꿔봅시다. 그러기 위해 `postfix_binding_power`이 option 타입을 돌려주도록 하겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        // CHANGE START\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n\n            lexer.next();\n            lhs = S::Cons(op, vec![lhs]);\n\n            continue;\n        }\n        // CHANGE END\n\n        let (l_bp, r_bp) = infix_binding_power(op);\n        if l_bp \u003c min_bp {\n            break;\n        }\n\n        lexer.next();\n        let rhs = expr_bp(lexer, r_bp);\n\n        lhs = S::Cons(op, vec![lhs, rhs]);\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -\u003e ((), u8) {\n    match op {\n        '+' | '-' =\u003e ((), 5),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -\u003e Option\u003c(u8, ())\u003e {\n    let res = match op {\n        '!' =\u003e (7, ()),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -\u003e (u8, u8) {\n    match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (10, 9),\n        _ =\u003e panic!(\"bad op: {:?}\"),\n    }\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"-9!\");\n    assert_eq!(s.to_string(), \"(- (! 9))\");\n\n    let s = expr(\"f . g !\");\n    assert_eq!(s.to_string(), \"(! (. f g))\");\n}\n```\n\n신기하게도 기존 테스트와 신규 테스트 모두 통과합니다.\n\n### 괄호 표현식\n\n새로운 표현식을 처리해봅시다. 바로 괄호 표현식인데요, 생각보다 어렵지 않습니다. 괄호 표현식은 꽤 기초적인 표현식으로 아톰과 비슷한 방식으로 처리할 수 있습니다.\n\n```rust\nlet mut lhs = match lexer.next() {\n    Token::Atom(it) =\u003e S::Atom(it),\n    Token::Op('(') =\u003e {\n        let lhs = expr_bp(lexer, 0);\n        assert_eq!(lexer.next(), Token::Op(')'));\n        lhs\n    }\n    Token::Op(op) =\u003e {\n        let ((), r_bp) = prefix_binding_power(op);\n        let rhs = expr_bp(lexer, r_bp);\n        S::Cons(op, vec![rhs])\n    }\n    t =\u003e panic!(\"bad token: {:?}\", t),\n};\n```\n\n하지만 이 테스트는 아직 통과하지 않습니다.\n\n```rust\nlet s = expr(\"(((0)))\");\nassert_eq!(s.to_string(), \"0\");\n```\n\n에러는 `loop` 블록에서 발생합니다. 현재 코드에서, 반복문에서 빠져나오는 유일한 조건은 `Eof`를 만났을 때입니다. 근데 이 지점에서 `)`를 만나면서, 이 `)` \"연산자\"가 밑에 있는 `infix_binding_power`에 넘겨지며 `panic!`을 하는 것이지요. 이를 해결하기 위한 가장 쉬운 방법은 `infix_binding_power`도 `postfix_binding_power`와 마찬가지로 식별하지 못한 연산자에 대해서는 option을 돌려주게 하는 것입니다.\n\n이제는 테스트가 잘 통과하네요!\n\n### 배열 접근 연산자 `[]`\n\n이제 배열 접근 연산자인 `a[i]`를 구현해봅시다. 지금까지 본 연산자들은 전위, 중위, 후위와 같이 분류할 수가 있었습니다. 이건 뭘까요? 그냥 `a[]`와 같이 생겼었다면 후위연산자였을 것이고, `[i]`였다면 괄호 표현식과 동일하게 동작했을 것입니다. 하지만 괄호 표현식과 비슷한 점이 있다면 괄호 안에 있는 표현식은 우선순위에 얽매이지 않는다는 겁니다. 한번 코드를 보겠습니다.\n\n```rust\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op('(') =\u003e {\n            let lhs = expr_bp(lexer, 0);\n            assert_eq!(lexer.next(), Token::Op(')'));\n            lhs\n        }\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n            lexer.next();\n\n\t\t\t// CHANGE START\n            lhs = if op == '[' {\n                let rhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(']'));\n                S::Cons(op, vec![lhs, rhs])\n            } else {\n                S::Cons(op, vec![lhs])\n            };\n\t\t\t// CHANGE END\n            continue;\n        }\n\n        if let Some((l_bp, r_bp)) = infix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n\n            lexer.next();\n            let rhs = expr_bp(lexer, r_bp);\n\n            lhs = S::Cons(op, vec![lhs, rhs]);\n            continue;\n        }\n\n        break;\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -\u003e ((), u8) {\n    match op {\n        '+' | '-' =\u003e ((), 5),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -\u003e Option\u003c(u8, ())\u003e {\n    let res = match op {\n        '!' | '[' =\u003e (7, ()), // 1\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -\u003e Option\u003c(u8, u8)\u003e {\n    let res = match op {\n        '+' | '-' =\u003e (1, 2),\n        '*' | '/' =\u003e (3, 4),\n        '.' =\u003e (10, 9),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\n#[test]\nfn tests() {\n    ...\n    let s = expr(\"x[0][1]\");\n    assert_eq!(s.to_string(), \"([ ([ x 0) 1)\");\n}\n```\n\n1. `!`과 `[`에 동일한 우선순위를 부여한 것이 보이나요? 일반적으로는 이 알고리즘의 correctness를 위해서 우선순위가 겹치지 않게 하는 것이 꽤 중요합니다. 하지만 우리가 결합 세기를 비교하는 경우에는, **오른쪽 결합 세기**와 **왼쪽 결합 세기**만 비교하기 때문에, 두 후위연산자의 결합 세기가 겹쳐도 문제가 생기지 않습니다.\n\n### 삼항연산자 `? :`\n\n최종 보스를 만나보겠습니다. 바로 삼항연산자입니다.\n\n```plaintext\nc ? e1 : e2\n```\n\n이건 어떻게 분류해야 할까요?? 한번 기호만 살짝 바꿔보겠습니다.\n\n```plaintext\nc [ e1 ] e2\n```\n\n감이 잡히나요? 앞부분에서 `a[i]`는 후위연산자 + 괄호표현식인 것을 보았습니다. 그러니 어떻게 보면 삼항연산자는 `a[i]`의 변형된 형태라고 생각할 수 있습니다. 이제 결합 세기와 방향을 생각해보겠습니다. 이런 경우에는 결합 방향이 어떻게 될까요?\n\n```plaintext\na ? b : c ? d : e\n```\n\n더 단순하게 보기 위해 좀 생략된 표현을 보겠습니다.\n\n```plaintext\na ?: c ?: e\n```\n\n위 표현식은 이렇게 파싱하거나:\n\n```plaintext\n(a ?: c) ?: e\n```\n\n이렇게 파싱할 수도 있습니다.\n\n```plaintext\na ?: (c ?: e)\n```\n\n무엇이 더 유용할까요? 이렇게 연속으로 사용하는 경우에는:\n\n```plaintext\na ? b :\nc ? d :\ne\n```\n\n오른쪽으로 결합하는 쪽이 더 유용할 것 같네요. 결합 세기의 경우에는, 꽤 낮은 우선순위를 가지고 있습니다. [C언어에서는](https://en.cppreference.com/w/c/language/operator_precedence) `=`와 `,`만이 더 낮은 우선순위를 가지고 있습니다.\n\n아래 코드를 통해 저희의 완성된 프랫 파서를 볼 수 있습니다.\n\n```rust\nuse std::{fmt, io::BufRead};\n\nenum S {\n    Atom(char),\n    Cons(char, Vec\u003cS\u003e),\n}\n\nimpl fmt::Display for S {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            S::Atom(i) =\u003e write!(f, \"{}\", i),\n            S::Cons(head, rest) =\u003e {\n                write!(f, \"({}\", head)?;\n                for s in rest {\n                    write!(f, \" {}\", s)?\n                }\n                write!(f, \")\")\n            }\n        }\n    }\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\nenum Token {\n    Atom(char),\n    Op(char),\n    Eof,\n}\n\nstruct Lexer {\n    tokens: Vec\u003cToken\u003e,\n}\n\nimpl Lexer {\n    fn new(input: \u0026str) -\u003e Lexer {\n        let mut tokens = input\n            .chars()\n            .filter(|it| !it.is_ascii_whitespace())\n            .map(|c| match c {\n                '0'..='9'\n                | 'a'..='z' | 'A'..='Z' =\u003e Token::Atom(c),\n                _ =\u003e Token::Op(c),\n            })\n            .collect::\u003cVec\u003c_\u003e\u003e();\n        tokens.reverse();\n        Lexer { tokens }\n    }\n\n    fn next(\u0026mut self) -\u003e Token {\n        self.tokens.pop().unwrap_or(Token::Eof)\n    }\n\n    fn peek(\u0026mut self) -\u003e Token {\n        self.tokens.last().copied().unwrap_or(Token::Eof)\n    }\n}\n\nfn expr(input: \u0026str) -\u003e S {\n    let mut lexer = Lexer::new(input);\n    expr_bp(\u0026mut lexer, 0)\n}\n\nfn expr_bp(lexer: \u0026mut Lexer, min_bp: u8) -\u003e S {\n    let mut lhs = match lexer.next() {\n        Token::Atom(it) =\u003e S::Atom(it),\n        Token::Op('(') =\u003e {\n            let lhs = expr_bp(lexer, 0);\n            assert_eq!(lexer.next(), Token::Op(')'));\n            lhs\n        }\n        Token::Op(op) =\u003e {\n            let ((), r_bp) = prefix_binding_power(op);\n            let rhs = expr_bp(lexer, r_bp);\n            S::Cons(op, vec![rhs])\n        }\n        t =\u003e panic!(\"bad token: {:?}\", t),\n    };\n\n    loop {\n        let op = match lexer.peek() {\n            Token::Eof =\u003e break,\n            Token::Op(op) =\u003e op,\n            t =\u003e panic!(\"bad token: {:?}\", t),\n        };\n\n        if let Some((l_bp, ())) = postfix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n            lexer.next();\n\n            lhs = if op == '[' {\n                let rhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(']'));\n                S::Cons(op, vec![lhs, rhs])\n            } else {\n                S::Cons(op, vec![lhs])\n            };\n            continue;\n        }\n\n        if let Some((l_bp, r_bp)) = infix_binding_power(op) {\n            if l_bp \u003c min_bp {\n                break;\n            }\n            lexer.next();\n\n            lhs = if op == '?' {\n                let mhs = expr_bp(lexer, 0);\n                assert_eq!(lexer.next(), Token::Op(':'));\n                let rhs = expr_bp(lexer, r_bp);\n                S::Cons(op, vec![lhs, mhs, rhs])\n            } else {\n                let rhs = expr_bp(lexer, r_bp);\n                S::Cons(op, vec![lhs, rhs])\n            };\n            continue;\n        }\n\n        break;\n    }\n\n    lhs\n}\n\nfn prefix_binding_power(op: char) -\u003e ((), u8) {\n    match op {\n        '+' | '-' =\u003e ((), 9),\n        _ =\u003e panic!(\"bad op: {:?}\", op),\n    }\n}\n\nfn postfix_binding_power(op: char) -\u003e Option\u003c(u8, ())\u003e {\n    let res = match op {\n        '!' =\u003e (11, ()),\n        '[' =\u003e (11, ()),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\nfn infix_binding_power(op: char) -\u003e Option\u003c(u8, u8)\u003e {\n    let res = match op {\n        '=' =\u003e (2, 1),\n        '?' =\u003e (4, 3),\n        '+' | '-' =\u003e (5, 6),\n        '*' | '/' =\u003e (7, 8),\n        '.' =\u003e (14, 13),\n        _ =\u003e return None,\n    };\n    Some(res)\n}\n\n#[test]\nfn tests() {\n    let s = expr(\"1\");\n    assert_eq!(s.to_string(), \"1\");\n\n    let s = expr(\"1 + 2 * 3\");\n    assert_eq!(s.to_string(), \"(+ 1 (* 2 3))\");\n\n    let s = expr(\"a + b * c * d + e\");\n    assert_eq!(s.to_string(), \"(+ (+ a (* (* b c) d)) e)\");\n\n    let s = expr(\"f . g . h\");\n    assert_eq!(s.to_string(), \"(. f (. g h))\");\n\n    let s = expr(\" 1 + 2 + f . g . h * 3 * 4\");\n    assert_eq!(\n        s.to_string(),\n        \"(+ (+ 1 2) (* (* (. f (. g h)) 3) 4))\",\n    );\n\n    let s = expr(\"--1 * 2\");\n    assert_eq!(s.to_string(), \"(* (- (- 1)) 2)\");\n\n    let s = expr(\"--f . g\");\n    assert_eq!(s.to_string(), \"(- (- (. f g)))\");\n\n    let s = expr(\"-9!\");\n    assert_eq!(s.to_string(), \"(- (! 9))\");\n\n    let s = expr(\"f . g !\");\n    assert_eq!(s.to_string(), \"(! (. f g))\");\n\n    let s = expr(\"(((0)))\");\n    assert_eq!(s.to_string(), \"0\");\n\n    let s = expr(\"x[0][1]\");\n    assert_eq!(s.to_string(), \"([ ([ x 0) 1)\");\n\n    let s = expr(\n        \"a ? b :\n         c ? d\n         : e\",\n    );\n    assert_eq!(s.to_string(), \"(? a b (? c d e))\");\n\n    let s = expr(\"a = 0 ? b : c = d\");\n    assert_eq!(s.to_string(), \"(= a (= (? 0 b c) d))\")\n}\n\nfn main() {\n    for line in std::io::stdin().lock().lines() {\n        let line = line.unwrap();\n        let s = expr(\u0026line);\n        println!(\"{}\", s)\n    }\n}\n```\n\n코드는 [이 레포](https://github.com/matklad/minipratt)에서도 확인해볼 수 있습니다. Eof.\n","title":"Simple but Powerful Pratt Parsing","tags":["parsing","ko"],"date":"2023-04-30"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"20230430-simple-but-powerful-pratt-parsing"},"buildId":"Km9EJmKojR2FE2I-vVgCt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>