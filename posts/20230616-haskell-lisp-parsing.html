<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><title>하스켈로 간단한 Lisp 만들기 - 파싱</title><meta property="og:title" content="하스켈로 간단한 Lisp 만들기 - 파싱"/><meta property="og:site_name" content="Paco Kwon&#x27;s Blog"/><meta name="next-head-count" content="5"/><link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark.min.css"/><link id="hljs-light" rel="alternative stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css" disabled=""/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/689295c571d1513e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/689295c571d1513e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-97515393dccb2e54.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-d1728c3a778f1232.js" defer=""></script><script src="/_next/static/chunks/pages/_app-570540608ca7ace4.js" defer=""></script><script src="/_next/static/chunks/392-079b0eace61ca2f5.js" defer=""></script><script src="/_next/static/chunks/839-cea740531d2b3154.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-2df54bee87117d70.js" defer=""></script><script src="/_next/static/5F4ehOhh1ByFPYA8fHCS2/_buildManifest.js" defer=""></script><script src="/_next/static/5F4ehOhh1ByFPYA8fHCS2/_ssgManifest.js" defer=""></script><style data-emotion="css-global 12ldfex">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:#fff;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;background-color:#121212;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#121212;}*{padding:0;margin:0;}html{overflow-x:hidden;}body{overflow-x:hidden;position:relative;line-height:1.6;}:root{--fs-800:3rem;--fs-700:2rem;--fs-600:1.5rem;--fs-500:1.25rem;--fs-400:1.125rem;--fs-300:1rem;--fs-200:0.8rem;}</style><style data-emotion="css 670439 1lgdpai dy3din zjuml4 1ps3nxk vubbuv 6ipc24 mfiwgy 16as864 3iet4t 1qyknr9 bkna8o 1m2hk6l 400xyc 186wd1t 18ldivb 1pjtbja 1bas2qp v5nfi0 1jop5q6 18bh6q1">.css-670439{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;}.css-670439::-moz-focus-inner{border-style:none;}.css-670439.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-670439{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-670439:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-670439:hover{background-color:transparent;}}.css-670439.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-1lgdpai{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;box-shadow:0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);background-image:linear-gradient(rgba(255, 255, 255, 0.09), rgba(255, 255, 255, 0.09));display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:static;}.css-1lgdpai.MuiAppBar-root{background-image:unset;}.css-1lgdpai.MuiAppBar-colorPrimary{box-shadow:none;background-color:#121212;color:#fff;}.css-dy3din{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:56px;}@media (min-width:0px){@media (orientation: landscape){.css-dy3din{min-height:48px;}}}@media (min-width:600px){.css-dy3din{min-height:64px;}}.css-dy3din.MuiToolbar-root{padding:0px 32px;}@media (max-width:599.95px){.css-dy3din.MuiToolbar-root{padding:0px 16px;}}@media (min-width:0px){.css-zjuml4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}@media (min-width:600px){.css-zjuml4{display:none;}}.css-1ps3nxk{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;padding:12px;font-size:1.75rem;}.css-1ps3nxk::-moz-focus-inner{border-style:none;}.css-1ps3nxk.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1ps3nxk{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1ps3nxk:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-1ps3nxk:hover{background-color:transparent;}}.css-1ps3nxk.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}.css-6ipc24{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1.25rem;line-height:1.334;color:#90caf9;-webkit-text-decoration:none;text-decoration:none;}@media (min-width:600px){.css-6ipc24{font-size:1.3118rem;}}@media (min-width:960px){.css-6ipc24{font-size:1.4993rem;}}@media (min-width:1280px){.css-6ipc24{font-size:1.4993rem;}}.css-6ipc24:hover{-webkit-text-decoration:underline;text-decoration:underline;}@media (min-width:0px){.css-6ipc24{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;margin-left:16px;}}@media (min-width:600px){.css-6ipc24{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;margin-right:32px;}}.css-6ipc24.MuiLink-root,.css-6ipc24.MuiLink-underlineHover{color:#4db6ac;font-weight:700;}.css-mfiwgy{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}@media (min-width:0px){.css-mfiwgy{display:none;}}@media (min-width:600px){.css-mfiwgy{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}.css-16as864{margin:0;font-family:inherit;font-weight:inherit;font-size:inherit;line-height:inherit;letter-spacing:inherit;color:#90caf9;-webkit-text-decoration:underline;text-decoration:underline;text-decoration-color:rgba(144, 202, 249, 0.4);margin-right:16px;-webkit-text-decoration:none;text-decoration:none;color:#fff;}.css-16as864:hover{text-decoration-color:inherit;}.css-16as864:hover{-webkit-text-decoration:underline;text-decoration:underline;}.css-3iet4t{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;}.css-1qyknr9{width:100%;margin-left:auto;box-sizing:border-box;margin-right:auto;display:block;padding-left:16px;padding-right:16px;}@media (min-width:600px){.css-1qyknr9{padding-left:24px;padding-right:24px;}}@media (min-width:960px){.css-1qyknr9{max-width:960px;}}@media (max-width:599.95px){.css-1qyknr9.MuiContainer-root{padding:0px;}}.css-bkna8o{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:none;background-image:linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0));padding:16px 40px 32px;}@media (max-width:599.95px){.css-bkna8o{padding:8px 16px 32px;}}.css-1m2hk6l h1,.css-1m2hk6l h2,.css-1m2hk6l h3{margin-top:32px;margin-bottom:8px;}.css-1m2hk6l p{margin-bottom:12px;font-size:var(--fs-300);}.css-1m2hk6l li{list-style-position:inside;}.css-1m2hk6l ul{padding-left:16px;}.css-1m2hk6l blockquote{border-left-width:1px;border-left-style:solid;border-left-color:#26a69a;padding-left:16px;font-style:italic;}.css-400xyc{font-weight:bold;margin-bottom:16px;}.css-186wd1t{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:8px;margin-bottom:16px;}.css-18ldivb{max-width:100%;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:rgba(0, 0, 0, 0.87);background-color:#90caf9;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;}.css-18ldivb.Mui-disabled{opacity:0.38;pointer-events:none;}.css-18ldivb .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#e0e0e0;font-size:0.75rem;}.css-18ldivb .MuiChip-avatarColorPrimary{color:rgba(0, 0, 0, 0.87);background-color:#42a5f5;}.css-18ldivb .MuiChip-avatarColorSecondary{color:rgba(0, 0, 0, 0.87);background-color:#ab47bc;}.css-18ldivb .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-18ldivb .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-18ldivb .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-18ldivb .MuiChip-deleteIcon:hover{color:rgba(255, 255, 255, 0.4);}.css-18ldivb .MuiChip-deleteIcon:hover,.css-18ldivb .MuiChip-deleteIcon:active{color:rgba(0, 0, 0, 0.87);}.css-18ldivb.MuiChip-colorPrimary{color:white;background:#009688;font-weight:500;}.css-1pjtbja{overflow:hidden;text-overflow:ellipsis;padding-left:8px;padding-right:8px;white-space:nowrap;}.css-1bas2qp{color:#4db6ac;-webkit-text-decoration:unset;text-decoration:unset;}.css-1bas2qp:hover{cursor:pointer;color:#80cbc4;font-weight:500;}.css-v5nfi0{color:#26a69a;background:#212121;border-radius:4px;font-weight:bold;}.css-1jop5q6{border-radius:8px;font-weight:400;margin-bottom:12px;border:1px solid #212121;position:relative;}.css-1jop5q6 button{position:absolute;top:5px;right:5px;}.css-1jop5q6 code.hljs{background:var(--background-color);}.css-18bh6q1{padding:24px 40px;}@media (max-width:599.95px){.css-18bh6q1{padding:24px 16px;}}.css-18bh6q1 .utterances{position:relative;box-sizing:border-box;width:100%;max-width:unset;margin:0;}</style><style data-href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1lgdpai"><div class="MuiToolbar-root MuiToolbar-regular css-dy3din"><div class="MuiBox-root css-zjuml4"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1ps3nxk" tabindex="0" type="button" aria-label="account of current user" aria-controls="menu-appbar" aria-haspopup="true"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button></div><a class="MuiTypography-root MuiTypography-h5 MuiLink-root MuiLink-underlineHover css-6ipc24" href="/">Paco Kwon</a><div class="MuiBox-root css-mfiwgy"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/bio"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Bio</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/posts"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Posts</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/links"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Links</p></a></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeMedium css-670439" tabindex="0" type="button"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="Brightness7Icon"><path d="M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></svg></button></div></header><main><div class="MuiContainer-root MuiContainer-maxWidthMd css-1qyknr9"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 css-bkna8o"><div class="css-1m2hk6l"><h1>하스켈로 간단한 Lisp 만들기 - 파싱</h1><div class="css-400xyc">2023-06-16</div><div class="css-186wd1t"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">haskell</span></div></div><div><p>이번 포스트와 다음 포스트에서는 간단한 Lisp 인터프리터를 만들어보겠다. 재미와 학습을 위한 것이니 간단하게 하겠다.</p>
<h2 id="목차">목차</h2>
<ul>
<li><a href="#lisp%EC%99%80-%EB%AA%A9%ED%91%9C" class="css-1bas2qp">Lisp와 목표</a></li>
<li><a href="#%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EA%B5%AC%EC%A1%B0" class="css-1bas2qp">인터프리터 구조</a></li>
<li><a href="#%ED%8C%8C%EC%8B%B1" class="css-1bas2qp">파싱</a>
<ul>
<li><a href="#ast-%EC%A0%95%EC%9D%98" class="css-1bas2qp">AST 정의</a></li>
<li><a href="#parser-combinator" class="css-1bas2qp">Parser Combinator</a></li>
<li><a href="#%EC%88%AB%EC%9E%90-%ED%8C%8C%EC%8B%B1" class="css-1bas2qp">숫자 파싱</a></li>
<li><a href="#%EC%8B%9D%EB%B3%84%EC%9E%90-%ED%8C%8C%EC%8B%B1" class="css-1bas2qp">식별자 파싱</a></li>
</ul>
</li>
</ul>
<p>나머지 부분들은 2부에서 다루겠다!</p>
<h2 id="lisp와-목표">Lisp와 목표</h2>
<p>Lisp는 단순한 문법과 확장성으로 인해 매니아층이 있는 언어이다. 문법은 S-Expression이라는 표현을 사용하는데, 괄호가 많은 것으로 악명이 높다. 요새 Lisp는 그 자체로 언어라기보다 언어의 family를 나타내는 말로 쓰이는 것 같다. Racket, Common Lisp, Clojure 등등이 이 family에 속한다고 볼 수 있고, 심지어는 이맥스에서도 Emacs Lisp라는 언어를 이용해 내부 configuration을 구성할 수 있게 되어 있다. 언어들마다 제공하는 primitive가 각각 다른데, 이번에는 아래 기능들을 구현해보도록 하겠다.</p>
<ul>
<li>표현식 평가</li>
<li>변수 선언 (local, global)</li>
<li>함수 선언 및 호출</li>
</ul>
<p>사용할 언어는 하스켈이다. 이럴 때라도 써보도록 하겠다!</p>
<p>우선 프로젝트를 생성하자. 프로젝트 이름은 <code class="css-v5nfi0">whisper</code>이다. 여기서 사용하는 툴은 <a href="https://docs.haskellstack.org/en/stable/" class="css-1bas2qp">stack</a>이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-bash">$ stack new whisper new-template
</code></div></pre>
<p>다음과 같이 파일이 있을 것이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">app           LICENSE       README.md  src         stack.yaml.lock  whisper.cabal
CHANGELOG.md  package.yaml  Setup.hs   stack.yaml  test
</code></div></pre>
<p>실제 프로젝트의 코드는 <code class="css-v5nfi0">app</code>, <code class="css-v5nfi0">src</code> 디렉토리에 있으며, <code class="css-v5nfi0">src</code>는 코어한 라이브러리 함수들이 있고, <code class="css-v5nfi0">app</code>에는 라이브러리 함수를 잘 조합하여 하나의 실행 파일로 동작하도록 하는 파일이 있다.</p>
<p>이 프로젝트에서는 <code class="css-v5nfi0">ghc 9.2.7</code>을 사용하겠다. <code class="css-v5nfi0">stack.yaml</code>에 이를 다음과 같이 명시해준다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-yaml"><span class="hljs-comment">#...</span>
<span class="hljs-attr">resolver:</span> <span class="hljs-string">lts-20.24</span>
<span class="hljs-comment">#...</span>
</code></div></pre>
<h2 id="인터프리터-구조">인터프리터 구조</h2>
<p>우리의 인터프리터는 읽기 - 파싱 - 평가 - 출력의 단계로 동작하게 할 것이다. 이 중 코어한 부분이 파싱과 평가인데, 이 두 단계를 차례로 부딪혀 보도록 하자.</p>
<h2 id="파싱">파싱</h2>
<p>코드를 작성하기 전에 필요한 패키지를 설치해야 한다. 이 프로젝트에서 사용할 패키지는 <a href="https://hackage.haskell.org/package/megaparsec" class="css-1bas2qp"><code class="css-v5nfi0">megaparsec</code></a>이라는 parser combinator 라이브러리와, 효율적인 텍스트 처리를 위한 <a href="https://hackage.haskell.org/package/text" class="css-1bas2qp"><code class="css-v5nfi0">text</code></a> 패키지이다.</p>
<p><code class="css-v5nfi0">stack.yaml</code>에 이를 명시해준다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-yaml"><span class="hljs-attr">extra-deps:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">megaparsec-9.4.0</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">text-2.0.2</span>
</code></div></pre>
<p>또 <code class="css-v5nfi0">package.yaml</code>의 <code class="css-v5nfi0">dependencies</code> 부분에 다음과 같이 추가한다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-yaml"><span class="hljs-attr">dependencies:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">base</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">4.7</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">5</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">megaparsec</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">9.4</span> <span class="hljs-comment"># NEW</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">text</span> <span class="hljs-string">&gt;=</span> <span class="hljs-number">2.0</span> <span class="hljs-comment"># NEW</span>
</code></div></pre>
<p>이제 <code class="css-v5nfi0">src/Parser.hs</code>에 파싱 코드를 작성해보자.</p>
<p>NOTE: <code class="css-v5nfi0">megaparsec</code>과 같은 parser combinator 라이브러리를 처음 써봐서 <a href="https://markkarpov.com/tutorial/megaparsec.html" class="css-1bas2qp">이 공식 문서</a>를 많이 참고했다.</p>
<p>먼저 우리의 <code class="css-v5nfi0">Parser</code> 타입을 만들어야 한다. 앞으로 만들게 되는 파서들은 이 타입을 가지게 될 것이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- src/Parser.hs</span>
<span class="hljs-keyword">module</span> Parser <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Data.Void (<span class="hljs-type">Void</span>)
<span class="hljs-keyword">import</span> Text.Megaparsec (<span class="hljs-type">Parsec</span>)
<span class="hljs-keyword">import</span> Data.Text (<span class="hljs-type">Text</span>)

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> = <span class="hljs-type">Parsec</span> <span class="hljs-type">Void</span> <span class="hljs-type">Text</span></span>
</code></div></pre>
<p>여기서 <code class="css-v5nfi0">Void</code>는 파싱 에러의 타입을 뜻하고, <code class="css-v5nfi0">Text</code>는 입력 소스의 타입을 의미한다. 개발 과정을 단순화하기 위해 에러 타입은 <code class="css-v5nfi0">Void</code>로 두었다.</p>
<h3 id="ast-정의">AST 정의</h3>
<p>가장 먼저 Syntax 트리를 정의하겠다. Syntax 트리는 코드를 파싱한 결과물을 나타내는데, 우선 하나의 S-Expression을 나타내는 타입을 다음과 같이 정의해볼 수 있다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- src/Parser.hs</span>
<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Sexpr</span> = <span class="hljs-type">Paren</span> [<span class="hljs-type">Sexpr</span>]</span>
           | <span class="hljs-type">Number</span> <span class="hljs-type">Int</span>
           | <span class="hljs-type">Ident</span> <span class="hljs-type">String</span>
	    <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span>
</code></div></pre>
<p>Syntax 트리의 노드를 3가지로 간단하게 나타내 보았다. <code class="css-v5nfi0">Number Int</code>는 <code class="css-v5nfi0">3</code>과 같이 정수를 표현하고, <code class="css-v5nfi0">Ident String</code>은 <code class="css-v5nfi0">a</code>, <code class="css-v5nfi0">foo</code>와 같이 변수를 표현하며, 마지막으로 <code class="css-v5nfi0">Paren [Sexpr]</code>는 <code class="css-v5nfi0">(* a (+ 1 3))</code>와 같이 여러 개의 S-Expression을 괄호 사이에 담고 있는 형태를 나타낸다.</p>
<p>맨 밑줄에 있는 <code class="css-v5nfi0">deriving Show</code>는 자바로 치면 <code class="css-v5nfi0">toString</code> 메서드를 자동으로 만들어주는 것과 같다. 다음과 같이 <code class="css-v5nfi0">Sexpr</code> 타입의 variant를 직관적으로 출력하는 데 도움을 준다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    print $ <span class="hljs-type">Number</span> <span class="hljs-number">3</span> <span class="hljs-comment">-- Output: Number 3</span>
    print $ <span class="hljs-type">Ident</span> <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-comment">-- Output: Ident &quot;foo&quot;</span>
    print $ <span class="hljs-type">Paren</span> [<span class="hljs-type">Ident</span> <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-type">Number</span> <span class="hljs-number">1</span>, <span class="hljs-type">Number</span> <span class="hljs-number">4</span>] <span class="hljs-comment">-- Output: Paren [Ident &quot;+&quot;,Number 1,Number 4]</span>
</code></div></pre>
<h3 id="parser-combinator">Parser Combinator</h3>
<p><a href="https://en.wikipedia.org/wiki/Parser_combinator" class="css-1bas2qp">파서 콤비네이터</a>는 모나드를 응용하여 재귀하향 파서를 작성하는 방법의 일종이다. 이름이 나타내듯이, 작은 파서를 조합하여 하나의 커다란 파서를 만들기 용이하다.</p>
<p>예를 들어 <code class="css-v5nfi0">megaparsec</code>에서는 <code class="css-v5nfi0">char</code>이라는 기본 파서가 있는데 이는 인자로 제공된 문자를 파싱한다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- Main.hs</span>
<span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="hljs-keyword">import</span> Text.Megaparsec
<span class="hljs-keyword">import</span> Text.Megaparsec.Char
<span class="hljs-keyword">import</span> Data.Void (<span class="hljs-type">Void</span>)
<span class="hljs-keyword">import</span> Data.Text (<span class="hljs-type">Text</span>)

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> = <span class="hljs-type">Parsec</span> <span class="hljs-type">Void</span> <span class="hljs-type">Text</span></span>

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    parseTest (char &#x27;a&#x27; :: <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>) <span class="hljs-string">&quot;a&quot;</span> <span class="hljs-comment">-- &#x27;a&#x27;</span>
    parseTest (char &#x27;a&#x27; :: <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>) <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-comment">-- ERROR: unexpected &#x27;b&#x27;, expecting &#x27;a&#x27;</span>
</code></div></pre>
<p><code class="css-v5nfi0">string</code>이라는 파서도 있다. 이는 인자로 제공된 문자열을 파싱한다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- Main.hs</span>
<span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="hljs-keyword">import</span> Text.Megaparsec
<span class="hljs-keyword">import</span> Text.Megaparsec.Char
<span class="hljs-keyword">import</span> Data.Void (<span class="hljs-type">Void</span>)
<span class="hljs-keyword">import</span> Data.Text (<span class="hljs-type">Text</span>)

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> = <span class="hljs-type">Parsec</span> <span class="hljs-type">Void</span> <span class="hljs-type">Text</span></span>

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    parseTest (string <span class="hljs-string">&quot;foo&quot;</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Text</span>) <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-comment">-- &quot;foo&quot;</span>
</code></div></pre>
<p>위 두 예시는 정규표현식으로도 표현이 가능한데, 균형 잡힌 괄호 문제와 같이 regex는 표현하지 못하는 것들도 파싱할 수 있다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">ParenExpr</span> = <span class="hljs-type">Empty</span> | <span class="hljs-type">Concat</span> <span class="hljs-type">ParenExpr</span> <span class="hljs-type">ParenExpr</span> <span class="hljs-keyword">deriving</span> <span class="hljs-type">Show</span></span>

<span class="hljs-title">parenExprParser</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">ParenExpr</span>
<span class="hljs-title">parenExprParser</span> = between (char &#x27;(&#x27;) (char &#x27;)&#x27;) innerExpr &lt;|&gt; emptyExpr
  <span class="hljs-keyword">where</span>
    innerExpr = <span class="hljs-keyword">do</span>
      left &lt;- parenExprParser
      right &lt;- parenExprParser
      return $ <span class="hljs-type">Concat</span> left right
    emptyExpr = return <span class="hljs-type">Empty</span>

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    parseTest parenExprParser <span class="hljs-string">&quot;(())()&quot;</span> <span class="hljs-comment">-- Concat (Concat Empty Empty) Empty &quot;foo&quot;</span>
</code></div></pre>
<h3 id="숫자-파싱">숫자 파싱</h3>
<p>그럼 이제 <code class="css-v5nfi0">megaparsec</code>에서 제공해주는 기본 파서를 이용해 AST의 정수 부분을 파싱해보자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- Main.hs</span>
<span class="hljs-meta">{-# LANGUAGE OverloadedStrings #-}</span>

<span class="hljs-keyword">import</span> Text.Megaparsec
<span class="hljs-keyword">import</span> Data.Void (<span class="hljs-type">Void</span>)
<span class="hljs-keyword">import</span> Data.Text (<span class="hljs-type">Text</span>)
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Text.Megaparsec.Char.Lexer <span class="hljs-keyword">as</span> L

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> = <span class="hljs-type">Parsec</span> <span class="hljs-type">Void</span> <span class="hljs-type">Text</span></span>

<span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = parseTest (<span class="hljs-type">L</span>.decimal :: <span class="hljs-type">Parser</span> <span class="hljs-type">Int</span>) <span class="hljs-string">&quot;345&quot;</span> <span class="hljs-comment">-- 345</span>
</code></div></pre>
<p>보이는 것과 같이 <code class="css-v5nfi0">Text.Megaparsec.Char.Lexer</code>의 <code class="css-v5nfi0">decimal</code> 함수는 10진수 숫자를 파싱해준다. 이때 파싱한 결과는 <code class="css-v5nfi0">Parser Int</code> 타입인데, 우리가 원하는 것은 <code class="css-v5nfi0">Parser Sexpr</code> 이다.</p>
<p>어떻게 바꿀 수 있을까?</p>
<p><code class="css-v5nfi0">Parser</code> 타입이 모나드라는 사실은 이럴 때 도움이 된다. 이미 모나드에 대해 알고 있는 것을 그대로 적용할 수 있기 때문이다. 모나드가 Functor라는 사실을 알고 있다면, <code class="css-v5nfi0">fmap</code> 함수를 이용해 내부의 타입을 다음과 같이 변환할 수 있다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">parseTest</span> (<span class="hljs-type">Number</span> &lt;$&gt; <span class="hljs-type">L</span>.decimal :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>) <span class="hljs-string">&quot;345&quot;</span>
</code></div></pre>
<p>따라서 우리의 <code class="css-v5nfi0">number</code> 함수는 다음과 같이 정의할 수 있다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- src/Parser.hs</span>

<span class="hljs-comment">-- ...</span>
<span class="hljs-title">number</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">number</span> = <span class="hljs-type">Number</span> &lt;$&gt; <span class="hljs-type">L</span>.decimal
</code></div></pre>
<h3 id="식별자-파싱">식별자 파싱</h3>
<p>이제 조금 더 어려운 식별자를 파싱해보기 전에 식별자가 어떻게 생겼으면 좋겠는지 정의할 필요가 있다. PHP나 JS는 변수명이 <code class="css-v5nfi0">$</code>로 시작하는 것을 허용하지만, 파이썬은 허용하지 않는 것을 보았을 때, 식별자의 생김새는 정하기 나름이다.</p>
<p>Lisp 계열 언어는 식별자 명명에 꽤 관대한 편이다. 따라서 이렇게 규칙을 정하겠다.</p>
<ol>
<li>식별자는 알파벳, 숫자, 그리고 특정 특수기호로 이루어져 있다</li>
<li>식별자의 길이는 1 이상이다.</li>
<li>식별자는 숫자로 시작할 수 없다.</li>
</ol>
<p>1번의 &quot;특정 특수기호&quot;는 ASCII 테이블 안의 특수기호 중 <code class="css-v5nfi0">!&quot;#$%&amp;&#x27;*+,-./:&lt;=&gt;?@^_~</code> 를 의미한다.</p>
<p>여기서 전략은 두 개의 작은 파서를 만드는 것이다. 파서 A는 첫번째 글자만을 위한 파서이다. 즉 알파벳과 기호를 인식하는 파서이다. 파서 B는 나머지 글자들을 위한 파서이다. 즉 알파벳, 기호, 숫자까지 인식할 수 있다. 그 뒤 파서 A와 B를 합치면 식별자 파서가 되는 것이다.</p>
<p>파서 A는 다음과 같이 만들 수 있다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-keyword">import</span> Text.Megaparsec ((&lt;|&gt;))
<span class="hljs-keyword">import</span> Text.Megaparsec.Char (<span class="hljs-title">letterChar</span>)

<span class="hljs-title">first</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>
<span class="hljs-title">first</span> = letterChar &lt;|&gt; symbolChar
</code></div></pre>
<p><code class="css-v5nfi0">&lt;|&gt;</code> 연산자의 사용을 볼 수 있는데, 이는 연산자 앞에 있는 파서가 실패하면 뒤에 있는 파서를 시도해보라는 뜻이다. 즉 <code class="css-v5nfi0">letterChar</code>이 인식하지 못하면, <code class="css-v5nfi0">symbolChar</code>이 시도를 해보는 것이다. 만약 <code class="css-v5nfi0">symbolChar</code> 까지 인식하지 못한다면 에러가 발생할 것이다.</p>
<p><code class="css-v5nfi0">letterChar</code>은 <code class="css-v5nfi0">megaparsec</code>에서 가져왔으나, <code class="css-v5nfi0">symbolChar</code>은 없는 것을 볼 수 있는데, 이는 <code class="css-v5nfi0">megaparsec</code>에 있는 <code class="css-v5nfi0">symbolChar</code>이 위에서 정의한 기호들과 일치하지 않기 때문이다. 직접 <code class="css-v5nfi0">symbolChar</code>를 정의해보자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-keyword">import</span> Text.Megaparsec (<span class="hljs-title">satisfy</span>)
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Set <span class="hljs-keyword">as</span> Set

<span class="hljs-title">symbols</span> :: <span class="hljs-type">Set</span>.<span class="hljs-type">Set</span> <span class="hljs-type">Char</span>
<span class="hljs-title">symbols</span> = <span class="hljs-type">Set</span>.fromList <span class="hljs-string">&quot;!\&quot;#$%&amp;&#x27;*+,-./:&lt;=&gt;?@^_~&quot;</span>

<span class="hljs-title">symbolChar</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>
<span class="hljs-title">symbolChar</span> = satisfy (`<span class="hljs-type">Set</span>.member` symbols)
</code></div></pre>
<p>위에선 <code class="css-v5nfi0">satisfy</code>라는 <code class="css-v5nfi0">megaparsec</code>의 함수를 사용했는데, 주어진 predicate 함수를 만족하는 문자만 인식하게 하는 것이다. 우리는 predicate로 연산자 집합에 있는 문자만 인식하는 함수를 건넸다.</p>
<p>이제 두 개의 작은 파서가 완성되었다. 이를 조합해 식별자 파서를 완성시켜보자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- src/Parser.hs</span>
<span class="hljs-keyword">import</span> Text.Megaparsec ((&lt;|&gt;), many, satisfy)
<span class="hljs-keyword">import</span> Text.Megaparsec.Char (<span class="hljs-title">letterChar</span>, <span class="hljs-title">alphaNumChar</span>)

<span class="hljs-title">symbols</span> :: <span class="hljs-type">Set</span>.<span class="hljs-type">Set</span> <span class="hljs-type">Char</span>
<span class="hljs-title">symbols</span> = <span class="hljs-type">Set</span>.fromList <span class="hljs-string">&quot;!\&quot;#$%&amp;&#x27;*+,-./:&lt;=&gt;?@^_~&quot;</span>

<span class="hljs-title">symbolChar</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>
<span class="hljs-title">symbolChar</span> = satisfy (`<span class="hljs-type">Set</span>.member` symbols)

<span class="hljs-title">ident</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">ident</span> = <span class="hljs-type">Ident</span> &lt;$&gt; p
    <span class="hljs-keyword">where</span>
        first = letterChar &lt;|&gt; symbolChar
        rest = many (alphaNumChar &lt;|&gt; symbolChar)
        p = (:) &lt;$&gt; first &lt;*&gt; rest
</code></div></pre>
<p>위 코드에서 눈여겨볼 점들은:</p>
<ol>
<li><code class="css-v5nfi0">many</code> 함수를 이용하여 &quot;하나의 문자를 인식하는 파서&quot;를 &quot;0개 이상의 문자를 인식하는 파서&quot;로 만들었다.</li>
<li><code class="css-v5nfi0">(:)</code> 리스트 cons 연산자를 이용하기 위해 <code class="css-v5nfi0">fmap(&lt;$&gt;)</code>과 <code class="css-v5nfi0">&lt;*&gt;</code>를 사용했다. <code class="css-v5nfi0">fmap</code>은 모나드가 functor이기 때문에 가능하고, <code class="css-v5nfi0">&lt;*&gt;</code>은 모나드가 applicative이기도 하기 때문에 가능하다.</li>
</ol>
<h3 id="리스트-파싱">리스트 파싱</h3>
<p>이제 마지막 variant인 <code class="css-v5nfi0">Paren</code>을 파싱해보자. 안에 여러 개의 S-Expression을 담고 있기 때문에 리스트라고 부르겠다. 리스트를 파싱하기 위해 그것의 특성을 먼저 살펴보자.</p>
<ol>
<li><code class="css-v5nfi0">(</code>으로 시작한다.</li>
<li><code class="css-v5nfi0">)</code>으로 끝난다.</li>
<li>사이에 1개 이상의 S-Expression이 공백으로 구분되어 있다</li>
</ol>
<p>가장 어려운 부분은 3번이다. 우선 리스트 안에는 또다른 S-Expression이 있기 때문에 재귀호출이 필요해 보이고, 또 공백을 어떻게든 처리해야 한다. 방법은 다양하겠지만, <strong>파싱이 끝난 이후에 발생하는 공백을 consume하고 무시하도록</strong> 파서를 수정하도록 하자.</p>
<p>이를 돕도록 유틸리티 함수를 하나 만들겠다. 파서를 입력으로 받아, 해당 파서가 하는 일 + 뒤에 있는 공백을 무시하는 파서를 만들자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-keyword">import</span> Text.Megaparsec.Char (<span class="hljs-title">space</span>)

<span class="hljs-title">lexeme</span> :: <span class="hljs-type">Parser</span> a -&gt; <span class="hljs-type">Parser</span> a
<span class="hljs-title">lexeme</span> p = p &lt;* space
</code></div></pre>
<p>이를 이용하여 기존 파서들을 수정하자. 위 함수를 사용하면 꽤 간단하다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">number</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">number</span> = <span class="hljs-type">Number</span> &lt;$&gt; lexeme <span class="hljs-type">L</span>.decimal

<span class="hljs-comment">-- ...</span>
<span class="hljs-title">ident</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">ident</span> = <span class="hljs-type">Ident</span> &lt;$&gt; lexeme p
    <span class="hljs-keyword">where</span>
        first = letterChar &lt;|&gt; symbolChar
        rest = many (alphaNumChar &lt;|&gt; symbolChar)
        p = (:) &lt;$&gt; first &lt;*&gt; rest
</code></div></pre>
<p>이로써 이 파서들은 뒤에 있는 공백까지 무시하는 기능까지 추가되었다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    parseTest (liftA2 (,) number ident) <span class="hljs-string">&quot;345 foobar&quot;</span> <span class="hljs-comment">-- (Number 345,Ident &quot;foobar&quot;)</span>
</code></div></pre>
<p>두 파서를 연속으로 실행시켜도 공백을 무시하고 잘 파싱해준다.</p>
<p>이제 유용한 함수를 하나 더 소개하겠다. 바로 <code class="css-v5nfi0">many</code>와 <code class="css-v5nfi0">some</code>인데, <code class="css-v5nfi0">many p</code>는 파서 <code class="css-v5nfi0">p</code>를 0번 이상 실행시켜 그 결과를 돌려주고, <code class="css-v5nfi0">some p</code>는 파서 <code class="css-v5nfi0">p</code>를 1번 이상 실행시켜 그 결과를 돌려준다.</p>
<p>즉, <code class="css-v5nfi0">many number</code>는 공백으로 구분된 0개 이상의 연속된 숫자를 파싱할 수 있고, <code class="css-v5nfi0">some ident</code>는 공백으로 구분된 1개 이상의 연속된 식별자를 파싱할 수 있다.</p>
<p>리스트 안에는 1개 이상의 S-Expression이 필요하기 때문에 <code class="css-v5nfi0">some</code>을 쓰면 된다. 근데 어떤 파서를 1번 이상 실행하면 될까? 우선은 그것을 <code class="css-v5nfi0">sexpr</code>라 부르기로 하고 조금 이따 돌아와보자.</p>
<p>종합해 보아 <code class="css-v5nfi0">paren</code> 파서를 만들어 보자. <code class="css-v5nfi0">(</code>로 시작하고, <code class="css-v5nfi0">p</code>를 1번 이상 실행한 뒤, <code class="css-v5nfi0">)</code>로 끝나는 것이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-keyword">import</span> Text.Megaparsec (<span class="hljs-title">some</span>)
<span class="hljs-keyword">import</span> Text.Megaparsec.Char (<span class="hljs-title">char</span>)

<span class="hljs-title">paren</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">paren</span> =
  lexeme
    ( <span class="hljs-keyword">do</span>
        _ &lt;- char &#x27;(&#x27;
        ss &lt;- some sexpr <span class="hljs-comment">-- ERROR: Variable not in scope: sexpr</span>
        _ &lt;- char &#x27;)&#x27;
        return $ <span class="hljs-type">Paren</span> ss
    )
</code></div></pre>
<p>에러가 날 것이지만 우선은 S-Expression을 종합적으로 파싱해주는 <code class="css-v5nfi0">sexpr</code>를 완성해보자. 이미 S-Expression의 variant는 모두 파싱할 수 있으니, 이를 조합만 하면 된다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">sexpr</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">sexpr</span> = paren &lt;|&gt; number &lt;|&gt; ident
</code></div></pre>
<p>잘 되는지 확인해보자!</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = <span class="hljs-keyword">do</span>
    parseTest sexpr <span class="hljs-string">&quot;(+ 1 2 3)&quot;</span> <span class="hljs-comment">-- Paren [Ident &quot;+&quot;,Number 1,Number 2,Number 3]</span>
    parseTest sexpr <span class="hljs-string">&quot;(+ 1 (* foo spam) 4)&quot;</span> <span class="hljs-comment">-- Paren [Ident &quot;+&quot;,Number 1,Paren [Ident &quot;*&quot;,Ident &quot;foo&quot;,Ident &quot;spam&quot;],Number 4]</span>
    parseTest sexpr <span class="hljs-string">&quot;5&quot;</span> <span class="hljs-comment">-- Number 5</span>
    parseTest sexpr <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-comment">-- Ident &quot;foo&quot;</span>
</code></div></pre>
<p>문제없이 잘 파싱이 된다면 지금까지 잘 따라온 것이다🎉🎉</p>
<p>NOTE: <code class="css-v5nfi0">paren</code>은 다음과 같이 간결하게 나타낼 수도 있다!</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">paren</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">paren</span> = <span class="hljs-type">Paren</span> &lt;$&gt; lexeme (char &#x27;(&#x27; *&gt; some sexpr &lt;* char &#x27;)&#x27;)
</code></div></pre>
<p>아래는 지금까지 작성한 파서 코드이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- src/Parser.hs</span>
<span class="hljs-keyword">module</span> Parser (<span class="hljs-type">Sexpr</span> (..), number, ident, paren, sexpr) <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Data.List.NonEmpty (<span class="hljs-type">NonEmpty</span> (..))
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Data.Set <span class="hljs-keyword">as</span> Set
<span class="hljs-keyword">import</span> Data.Text (<span class="hljs-type">Text</span>)
<span class="hljs-keyword">import</span> Data.Void (<span class="hljs-type">Void</span>)
<span class="hljs-keyword">import</span> Text.Megaparsec (<span class="hljs-type">ErrorItem</span> (..), MonadParsec (<span class="hljs-title">token</span>), Parsec, Stream (<span class="hljs-type">Token</span>), many, satisfy, some, (&lt;|&gt;))
<span class="hljs-keyword">import</span> Text.Megaparsec.Char (<span class="hljs-title">alphaNumChar</span>, <span class="hljs-title">char</span>, <span class="hljs-title">letterChar</span>, <span class="hljs-title">space</span>)
<span class="hljs-keyword">import</span> <span class="hljs-keyword">qualified</span> Text.Megaparsec.Char.Lexer <span class="hljs-keyword">as</span> L

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-type">Parser</span> = <span class="hljs-type">Parsec</span> <span class="hljs-type">Void</span> <span class="hljs-type">Text</span></span>

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Sexpr</span></span>
  = <span class="hljs-type">Paren</span> [<span class="hljs-type">Sexpr</span>]
  | <span class="hljs-type">Number</span> <span class="hljs-type">Int</span>
  | <span class="hljs-type">Ident</span> <span class="hljs-type">String</span>
  <span class="hljs-keyword">deriving</span> (<span class="hljs-type">Show</span>)

<span class="hljs-title">lexeme</span> :: <span class="hljs-type">Parser</span> a -&gt; <span class="hljs-type">Parser</span> a
<span class="hljs-title">lexeme</span> p = p &lt;* space

<span class="hljs-title">number</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">number</span> = <span class="hljs-type">Number</span> &lt;$&gt; lexeme <span class="hljs-type">L</span>.decimal

<span class="hljs-title">symbols</span> :: <span class="hljs-type">Set</span>.<span class="hljs-type">Set</span> <span class="hljs-type">Char</span>
<span class="hljs-title">symbols</span> = <span class="hljs-type">Set</span>.fromList <span class="hljs-string">&quot;!\&quot;#$%&amp;&#x27;*+,-./:&lt;=&gt;?@^_~&quot;</span>

<span class="hljs-title">symbolChar</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Char</span>
<span class="hljs-title">symbolChar</span> = satisfy (`<span class="hljs-type">Set</span>.member` symbols)

<span class="hljs-title">ident</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">ident</span> = <span class="hljs-type">Ident</span> &lt;$&gt; lexeme p
  <span class="hljs-keyword">where</span>
    first = letterChar &lt;|&gt; symbolChar
    rest = many (alphaNumChar &lt;|&gt; symbolChar)
    p = (:) &lt;$&gt; first &lt;*&gt; rest

<span class="hljs-title">paren</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">paren</span> = <span class="hljs-type">Paren</span> &lt;$&gt; lexeme (char &#x27;(&#x27; *&gt; some sexpr &lt;* char &#x27;)&#x27;)

<span class="hljs-title">sexpr</span> :: <span class="hljs-type">Parser</span> <span class="hljs-type">Sexpr</span>
<span class="hljs-title">sexpr</span> = paren &lt;|&gt; number &lt;|&gt; ident
</code></div></pre>
<p>여기까지가 파싱이다. 다음 포스트에서는 평가 부분을 다루도록 하겠다.</p></div></div></div><div id="utterances-comments" class="css-18bh6q1"></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"20230616-haskell-lisp-parsing","content":"\n이번 포스트와 다음 포스트에서는 간단한 Lisp 인터프리터를 만들어보겠다. 재미와 학습을 위한 것이니 간단하게 하겠다.\n\n## 목차\n\n- [Lisp와 목표](#lisp와-목표)\n- [인터프리터 구조](#인터프리터-구조)\n- [파싱](#파싱)\n  - [AST 정의](#ast-정의)\n  - [Parser Combinator](#parser-combinator)\n  - [숫자 파싱](#숫자-파싱)\n  - [식별자 파싱](#식별자-파싱)\n\n나머지 부분들은 2부에서 다루겠다!\n\n## Lisp와 목표\n\nLisp는 단순한 문법과 확장성으로 인해 매니아층이 있는 언어이다. 문법은 S-Expression이라는 표현을 사용하는데, 괄호가 많은 것으로 악명이 높다. 요새 Lisp는 그 자체로 언어라기보다 언어의 family를 나타내는 말로 쓰이는 것 같다. Racket, Common Lisp, Clojure 등등이 이 family에 속한다고 볼 수 있고, 심지어는 이맥스에서도 Emacs Lisp라는 언어를 이용해 내부 configuration을 구성할 수 있게 되어 있다. 언어들마다 제공하는 primitive가 각각 다른데, 이번에는 아래 기능들을 구현해보도록 하겠다.\n\n- 표현식 평가\n- 변수 선언 (local, global)\n- 함수 선언 및 호출\n\n사용할 언어는 하스켈이다. 이럴 때라도 써보도록 하겠다!\n\n우선 프로젝트를 생성하자. 프로젝트 이름은 `whisper`이다. 여기서 사용하는 툴은 [stack](https://docs.haskellstack.org/en/stable/)이다.\n\n```bash\n$ stack new whisper new-template\n```\n\n다음과 같이 파일이 있을 것이다.\n\n```plaintext\napp           LICENSE       README.md  src         stack.yaml.lock  whisper.cabal\nCHANGELOG.md  package.yaml  Setup.hs   stack.yaml  test\n```\n\n실제 프로젝트의 코드는 `app`, `src` 디렉토리에 있으며, `src`는 코어한 라이브러리 함수들이 있고, `app`에는 라이브러리 함수를 잘 조합하여 하나의 실행 파일로 동작하도록 하는 파일이 있다.\n\n이 프로젝트에서는 `ghc 9.2.7`을 사용하겠다. `stack.yaml`에 이를 다음과 같이 명시해준다.\n\n```yaml\n#...\nresolver: lts-20.24\n#...\n```\n\n## 인터프리터 구조\n\n우리의 인터프리터는 읽기 - 파싱 - 평가 - 출력의 단계로 동작하게 할 것이다. 이 중 코어한 부분이 파싱과 평가인데, 이 두 단계를 차례로 부딪혀 보도록 하자.\n\n## 파싱\n\n코드를 작성하기 전에 필요한 패키지를 설치해야 한다. 이 프로젝트에서 사용할 패키지는 [`megaparsec`](https://hackage.haskell.org/package/megaparsec)이라는 parser combinator 라이브러리와, 효율적인 텍스트 처리를 위한 [`text`](https://hackage.haskell.org/package/text) 패키지이다.\n\n`stack.yaml`에 이를 명시해준다.\n\n```yaml\nextra-deps:\n  - megaparsec-9.4.0\n  - text-2.0.2\n```\n\n또 `package.yaml`의 `dependencies` 부분에 다음과 같이 추가한다.\n\n```yaml\ndependencies:\n  - base \u003e= 4.7 \u0026\u0026 \u003c 5\n  - megaparsec \u003e= 9.4 # NEW\n  - text \u003e= 2.0 # NEW\n```\n\n이제 `src/Parser.hs`에 파싱 코드를 작성해보자.\n\nNOTE: `megaparsec`과 같은 parser combinator 라이브러리를 처음 써봐서 [이 공식 문서](https://markkarpov.com/tutorial/megaparsec.html)를 많이 참고했다.\n\n먼저 우리의 `Parser` 타입을 만들어야 한다. 앞으로 만들게 되는 파서들은 이 타입을 가지게 될 것이다.\n\n```haskell\n-- src/Parser.hs\nmodule Parser where\n\nimport Data.Void (Void)\nimport Text.Megaparsec (Parsec)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n```\n\n여기서 `Void`는 파싱 에러의 타입을 뜻하고, `Text`는 입력 소스의 타입을 의미한다. 개발 과정을 단순화하기 위해 에러 타입은 `Void`로 두었다.\n\n### AST 정의\n\n가장 먼저 Syntax 트리를 정의하겠다. Syntax 트리는 코드를 파싱한 결과물을 나타내는데, 우선 하나의 S-Expression을 나타내는 타입을 다음과 같이 정의해볼 수 있다.\n\n```haskell\n-- src/Parser.hs\ndata Sexpr = Paren [Sexpr]\n           | Number Int\n           | Ident String\n\t    deriving Show\n```\n\nSyntax 트리의 노드를 3가지로 간단하게 나타내 보았다. `Number Int`는 `3`과 같이 정수를 표현하고, `Ident String`은 `a`, `foo`와 같이 변수를 표현하며, 마지막으로 `Paren [Sexpr]`는 `(* a (+ 1 3))`와 같이 여러 개의 S-Expression을 괄호 사이에 담고 있는 형태를 나타낸다.\n\n맨 밑줄에 있는 `deriving Show`는 자바로 치면 `toString` 메서드를 자동으로 만들어주는 것과 같다. 다음과 같이 `Sexpr` 타입의 variant를 직관적으로 출력하는 데 도움을 준다.\n\n```haskell\nmain :: IO ()\nmain = do\n    print $ Number 3 -- Output: Number 3\n    print $ Ident \"foo\" -- Output: Ident \"foo\"\n    print $ Paren [Ident \"+\", Number 1, Number 4] -- Output: Paren [Ident \"+\",Number 1,Number 4]\n```\n\n### Parser Combinator\n\n[파서 콤비네이터](https://en.wikipedia.org/wiki/Parser_combinator)는 모나드를 응용하여 재귀하향 파서를 작성하는 방법의 일종이다. 이름이 나타내듯이, 작은 파서를 조합하여 하나의 커다란 파서를 만들기 용이하다.\n\n예를 들어 `megaparsec`에서는 `char`이라는 기본 파서가 있는데 이는 인자로 제공된 문자를 파싱한다.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Text.Megaparsec.Char\nimport Data.Void (Void)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = do\n    parseTest (char 'a' :: Parser Char) \"a\" -- 'a'\n    parseTest (char 'a' :: Parser Char) \"b\" -- ERROR: unexpected 'b', expecting 'a'\n```\n\n`string`이라는 파서도 있다. 이는 인자로 제공된 문자열을 파싱한다.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Text.Megaparsec.Char\nimport Data.Void (Void)\nimport Data.Text (Text)\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = do\n    parseTest (string \"foo\" :: Parser Text) \"foo\" -- \"foo\"\n```\n\n위 두 예시는 정규표현식으로도 표현이 가능한데, 균형 잡힌 괄호 문제와 같이 regex는 표현하지 못하는 것들도 파싱할 수 있다.\n\n```haskell\ndata ParenExpr = Empty | Concat ParenExpr ParenExpr deriving Show\n\nparenExprParser :: Parser ParenExpr\nparenExprParser = between (char '(') (char ')') innerExpr \u003c|\u003e emptyExpr\n  where\n    innerExpr = do\n      left \u003c- parenExprParser\n      right \u003c- parenExprParser\n      return $ Concat left right\n    emptyExpr = return Empty\n\nmain :: IO ()\nmain = do\n    parseTest parenExprParser \"(())()\" -- Concat (Concat Empty Empty) Empty \"foo\"\n```\n\n### 숫자 파싱\n\n그럼 이제 `megaparsec`에서 제공해주는 기본 파서를 이용해 AST의 정수 부분을 파싱해보자.\n\n```haskell\n-- Main.hs\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Text.Megaparsec\nimport Data.Void (Void)\nimport Data.Text (Text)\nimport qualified Text.Megaparsec.Char.Lexer as L\n\ntype Parser = Parsec Void Text\n\nmain :: IO ()\nmain = parseTest (L.decimal :: Parser Int) \"345\" -- 345\n```\n\n보이는 것과 같이 `Text.Megaparsec.Char.Lexer`의 `decimal` 함수는 10진수 숫자를 파싱해준다. 이때 파싱한 결과는 `Parser Int` 타입인데, 우리가 원하는 것은 `Parser Sexpr` 이다.\n\n어떻게 바꿀 수 있을까?\n\n`Parser` 타입이 모나드라는 사실은 이럴 때 도움이 된다. 이미 모나드에 대해 알고 있는 것을 그대로 적용할 수 있기 때문이다. 모나드가 Functor라는 사실을 알고 있다면, `fmap` 함수를 이용해 내부의 타입을 다음과 같이 변환할 수 있다.\n\n```haskell\nparseTest (Number \u003c$\u003e L.decimal :: Parser Sexpr) \"345\"\n```\n\n따라서 우리의 `number` 함수는 다음과 같이 정의할 수 있다.\n\n```haskell\n-- src/Parser.hs\n\n-- ...\nnumber :: Parser Sexpr\nnumber = Number \u003c$\u003e L.decimal\n```\n\n### 식별자 파싱\n\n이제 조금 더 어려운 식별자를 파싱해보기 전에 식별자가 어떻게 생겼으면 좋겠는지 정의할 필요가 있다. PHP나 JS는 변수명이 `$`로 시작하는 것을 허용하지만, 파이썬은 허용하지 않는 것을 보았을 때, 식별자의 생김새는 정하기 나름이다.\n\nLisp 계열 언어는 식별자 명명에 꽤 관대한 편이다. 따라서 이렇게 규칙을 정하겠다.\n\n1. 식별자는 알파벳, 숫자, 그리고 특정 특수기호로 이루어져 있다\n2. 식별자의 길이는 1 이상이다.\n3. 식별자는 숫자로 시작할 수 없다.\n\n1번의 \"특정 특수기호\"는 ASCII 테이블 안의 특수기호 중 `!\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~` 를 의미한다.\n\n여기서 전략은 두 개의 작은 파서를 만드는 것이다. 파서 A는 첫번째 글자만을 위한 파서이다. 즉 알파벳과 기호를 인식하는 파서이다. 파서 B는 나머지 글자들을 위한 파서이다. 즉 알파벳, 기호, 숫자까지 인식할 수 있다. 그 뒤 파서 A와 B를 합치면 식별자 파서가 되는 것이다.\n\n파서 A는 다음과 같이 만들 수 있다.\n\n```haskell\nimport Text.Megaparsec ((\u003c|\u003e))\nimport Text.Megaparsec.Char (letterChar)\n\nfirst :: Parser Char\nfirst = letterChar \u003c|\u003e symbolChar\n```\n\n`\u003c|\u003e` 연산자의 사용을 볼 수 있는데, 이는 연산자 앞에 있는 파서가 실패하면 뒤에 있는 파서를 시도해보라는 뜻이다. 즉 `letterChar`이 인식하지 못하면, `symbolChar`이 시도를 해보는 것이다. 만약 `symbolChar` 까지 인식하지 못한다면 에러가 발생할 것이다.\n\n`letterChar`은 `megaparsec`에서 가져왔으나, `symbolChar`은 없는 것을 볼 수 있는데, 이는 `megaparsec`에 있는 `symbolChar`이 위에서 정의한 기호들과 일치하지 않기 때문이다. 직접 `symbolChar`를 정의해보자.\n\n```haskell\nimport Text.Megaparsec (satisfy)\nimport qualified Data.Set as Set\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n```\n\n위에선 `satisfy`라는 `megaparsec`의 함수를 사용했는데, 주어진 predicate 함수를 만족하는 문자만 인식하게 하는 것이다. 우리는 predicate로 연산자 집합에 있는 문자만 인식하는 함수를 건넸다.\n\n이제 두 개의 작은 파서가 완성되었다. 이를 조합해 식별자 파서를 완성시켜보자.\n\n```haskell\n-- src/Parser.hs\nimport Text.Megaparsec ((\u003c|\u003e), many, satisfy)\nimport Text.Megaparsec.Char (letterChar, alphaNumChar)\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n\nident :: Parser Sexpr\nident = Ident \u003c$\u003e p\n    where\n        first = letterChar \u003c|\u003e symbolChar\n        rest = many (alphaNumChar \u003c|\u003e symbolChar)\n        p = (:) \u003c$\u003e first \u003c*\u003e rest\n```\n\n위 코드에서 눈여겨볼 점들은:\n\n1. `many` 함수를 이용하여 \"하나의 문자를 인식하는 파서\"를 \"0개 이상의 문자를 인식하는 파서\"로 만들었다.\n2. `(:)` 리스트 cons 연산자를 이용하기 위해 `fmap(\u003c$\u003e)`과 `\u003c*\u003e`를 사용했다. `fmap`은 모나드가 functor이기 때문에 가능하고, `\u003c*\u003e`은 모나드가 applicative이기도 하기 때문에 가능하다.\n\n### 리스트 파싱\n\n이제 마지막 variant인 `Paren`을 파싱해보자. 안에 여러 개의 S-Expression을 담고 있기 때문에 리스트라고 부르겠다. 리스트를 파싱하기 위해 그것의 특성을 먼저 살펴보자.\n\n1. `(`으로 시작한다.\n2. `)`으로 끝난다.\n3. 사이에 1개 이상의 S-Expression이 공백으로 구분되어 있다\n\n가장 어려운 부분은 3번이다. 우선 리스트 안에는 또다른 S-Expression이 있기 때문에 재귀호출이 필요해 보이고, 또 공백을 어떻게든 처리해야 한다. 방법은 다양하겠지만, **파싱이 끝난 이후에 발생하는 공백을 consume하고 무시하도록** 파서를 수정하도록 하자.\n\n이를 돕도록 유틸리티 함수를 하나 만들겠다. 파서를 입력으로 받아, 해당 파서가 하는 일 + 뒤에 있는 공백을 무시하는 파서를 만들자.\n\n```haskell\nimport Text.Megaparsec.Char (space)\n\nlexeme :: Parser a -\u003e Parser a\nlexeme p = p \u003c* space\n```\n\n이를 이용하여 기존 파서들을 수정하자. 위 함수를 사용하면 꽤 간단하다.\n\n```haskell\nnumber :: Parser Sexpr\nnumber = Number \u003c$\u003e lexeme L.decimal\n\n-- ...\nident :: Parser Sexpr\nident = Ident \u003c$\u003e lexeme p\n    where\n        first = letterChar \u003c|\u003e symbolChar\n        rest = many (alphaNumChar \u003c|\u003e symbolChar)\n        p = (:) \u003c$\u003e first \u003c*\u003e rest\n```\n\n이로써 이 파서들은 뒤에 있는 공백까지 무시하는 기능까지 추가되었다.\n\n```haskell\nmain :: IO ()\nmain = do\n    parseTest (liftA2 (,) number ident) \"345 foobar\" -- (Number 345,Ident \"foobar\")\n```\n\n두 파서를 연속으로 실행시켜도 공백을 무시하고 잘 파싱해준다.\n\n이제 유용한 함수를 하나 더 소개하겠다. 바로 `many`와 `some`인데, `many p`는 파서 `p`를 0번 이상 실행시켜 그 결과를 돌려주고, `some p`는 파서 `p`를 1번 이상 실행시켜 그 결과를 돌려준다.\n\n즉, `many number`는 공백으로 구분된 0개 이상의 연속된 숫자를 파싱할 수 있고, `some ident`는 공백으로 구분된 1개 이상의 연속된 식별자를 파싱할 수 있다.\n\n리스트 안에는 1개 이상의 S-Expression이 필요하기 때문에 `some`을 쓰면 된다. 근데 어떤 파서를 1번 이상 실행하면 될까? 우선은 그것을 `sexpr`라 부르기로 하고 조금 이따 돌아와보자.\n\n종합해 보아 `paren` 파서를 만들어 보자. `(`로 시작하고, `p`를 1번 이상 실행한 뒤, `)`로 끝나는 것이다.\n\n```haskell\nimport Text.Megaparsec (some)\nimport Text.Megaparsec.Char (char)\n\nparen :: Parser Sexpr\nparen =\n  lexeme\n    ( do\n        _ \u003c- char '('\n        ss \u003c- some sexpr -- ERROR: Variable not in scope: sexpr\n        _ \u003c- char ')'\n        return $ Paren ss\n    )\n```\n\n에러가 날 것이지만 우선은 S-Expression을 종합적으로 파싱해주는 `sexpr`를 완성해보자. 이미 S-Expression의 variant는 모두 파싱할 수 있으니, 이를 조합만 하면 된다.\n\n```haskell\nsexpr :: Parser Sexpr\nsexpr = paren \u003c|\u003e number \u003c|\u003e ident\n```\n\n잘 되는지 확인해보자!\n\n```haskell\nmain :: IO ()\nmain = do\n    parseTest sexpr \"(+ 1 2 3)\" -- Paren [Ident \"+\",Number 1,Number 2,Number 3]\n    parseTest sexpr \"(+ 1 (* foo spam) 4)\" -- Paren [Ident \"+\",Number 1,Paren [Ident \"*\",Ident \"foo\",Ident \"spam\"],Number 4]\n    parseTest sexpr \"5\" -- Number 5\n    parseTest sexpr \"foo\" -- Ident \"foo\"\n```\n\n문제없이 잘 파싱이 된다면 지금까지 잘 따라온 것이다🎉🎉\n\nNOTE: `paren`은 다음과 같이 간결하게 나타낼 수도 있다!\n\n```haskell\nparen :: Parser Sexpr\nparen = Paren \u003c$\u003e lexeme (char '(' *\u003e some sexpr \u003c* char ')')\n```\n\n아래는 지금까지 작성한 파서 코드이다.\n\n```haskell\n-- src/Parser.hs\nmodule Parser (Sexpr (..), number, ident, paren, sexpr) where\n\nimport Data.List.NonEmpty (NonEmpty (..))\nimport qualified Data.Set as Set\nimport Data.Text (Text)\nimport Data.Void (Void)\nimport Text.Megaparsec (ErrorItem (..), MonadParsec (token), Parsec, Stream (Token), many, satisfy, some, (\u003c|\u003e))\nimport Text.Megaparsec.Char (alphaNumChar, char, letterChar, space)\nimport qualified Text.Megaparsec.Char.Lexer as L\n\ntype Parser = Parsec Void Text\n\ndata Sexpr\n  = Paren [Sexpr]\n  | Number Int\n  | Ident String\n  deriving (Show)\n\nlexeme :: Parser a -\u003e Parser a\nlexeme p = p \u003c* space\n\nnumber :: Parser Sexpr\nnumber = Number \u003c$\u003e lexeme L.decimal\n\nsymbols :: Set.Set Char\nsymbols = Set.fromList \"!\\\"#$%\u0026'*+,-./:\u003c=\u003e?@^_~\"\n\nsymbolChar :: Parser Char\nsymbolChar = satisfy (`Set.member` symbols)\n\nident :: Parser Sexpr\nident = Ident \u003c$\u003e lexeme p\n  where\n    first = letterChar \u003c|\u003e symbolChar\n    rest = many (alphaNumChar \u003c|\u003e symbolChar)\n    p = (:) \u003c$\u003e first \u003c*\u003e rest\n\nparen :: Parser Sexpr\nparen = Paren \u003c$\u003e lexeme (char '(' *\u003e some sexpr \u003c* char ')')\n\nsexpr :: Parser Sexpr\nsexpr = paren \u003c|\u003e number \u003c|\u003e ident\n```\n\n여기까지가 파싱이다. 다음 포스트에서는 평가 부분을 다루도록 하겠다.\n","title":"하스켈로 간단한 Lisp 만들기 - 파싱","tags":["ko","haskell"],"date":"2023-06-16"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"20230616-haskell-lisp-parsing"},"buildId":"5F4ehOhh1ByFPYA8fHCS2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>