<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width"/><title>하스켈로 간단한 Lisp 만들기 - 평가</title><meta property="og:title" content="하스켈로 간단한 Lisp 만들기 - 평가"/><meta property="og:site_name" content="Paco Kwon&#x27;s Blog"/><meta name="next-head-count" content="5"/><link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/atom-one-dark.min.css"/><link id="hljs-light" rel="alternative stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css" disabled=""/><link rel="shortcut icon" href="static/favicon-16x16.png"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/689295c571d1513e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/689295c571d1513e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-97515393dccb2e54.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-d1728c3a778f1232.js" defer=""></script><script src="/_next/static/chunks/pages/_app-570540608ca7ace4.js" defer=""></script><script src="/_next/static/chunks/392-079b0eace61ca2f5.js" defer=""></script><script src="/_next/static/chunks/839-cea740531d2b3154.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-2df54bee87117d70.js" defer=""></script><script src="/_next/static/ScjPqQVmosJHdyaFeeBfu/_buildManifest.js" defer=""></script><script src="/_next/static/ScjPqQVmosJHdyaFeeBfu/_ssgManifest.js" defer=""></script><style data-emotion="css-global 12ldfex">html{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;box-sizing:border-box;-webkit-text-size-adjust:100%;}*,*::before,*::after{box-sizing:inherit;}strong,b{font-weight:700;}body{margin:0;color:#fff;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;background-color:#121212;}@media print{body{background-color:#fff;}}body::backdrop{background-color:#121212;}*{padding:0;margin:0;}html{overflow-x:hidden;}body{overflow-x:hidden;position:relative;line-height:1.6;}:root{--fs-800:3rem;--fs-700:2rem;--fs-600:1.5rem;--fs-500:1.25rem;--fs-400:1.125rem;--fs-300:1rem;--fs-200:0.8rem;}</style><style data-emotion="css 670439 1lgdpai dy3din zjuml4 1ps3nxk vubbuv 6ipc24 mfiwgy 16as864 3iet4t 1qyknr9 bkna8o 1m2hk6l 400xyc 186wd1t 18ldivb 1pjtbja 1bas2qp v5nfi0 1jop5q6 18bh6q1">.css-670439{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;}.css-670439::-moz-focus-inner{border-style:none;}.css-670439.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-670439{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-670439:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-670439:hover{background-color:transparent;}}.css-670439.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-1lgdpai{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;box-shadow:0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12);background-image:linear-gradient(rgba(255, 255, 255, 0.09), rgba(255, 255, 255, 0.09));display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;width:100%;box-sizing:border-box;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;position:static;}.css-1lgdpai.MuiAppBar-root{background-image:unset;}.css-1lgdpai.MuiAppBar-colorPrimary{box-shadow:none;background-color:#121212;color:#fff;}.css-dy3din{position:relative;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;min-height:56px;}@media (min-width:0px){@media (orientation: landscape){.css-dy3din{min-height:48px;}}}@media (min-width:600px){.css-dy3din{min-height:64px;}}.css-dy3din.MuiToolbar-root{padding:0px 32px;}@media (max-width:599.95px){.css-dy3din.MuiToolbar-root{padding:0px 16px;}}@media (min-width:0px){.css-zjuml4{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}@media (min-width:600px){.css-zjuml4{display:none;}}.css-1ps3nxk{display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;background-color:transparent;outline:0;border:0;margin:0;border-radius:0;padding:0;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;vertical-align:middle;-moz-appearance:none;-webkit-appearance:none;-webkit-text-decoration:none;text-decoration:none;color:inherit;text-align:center;-webkit-flex:0 0 auto;-ms-flex:0 0 auto;flex:0 0 auto;font-size:1.5rem;padding:8px;border-radius:50%;overflow:visible;color:#fff;-webkit-transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;color:inherit;padding:12px;font-size:1.75rem;}.css-1ps3nxk::-moz-focus-inner{border-style:none;}.css-1ps3nxk.Mui-disabled{pointer-events:none;cursor:default;}@media print{.css-1ps3nxk{-webkit-print-color-adjust:exact;color-adjust:exact;}}.css-1ps3nxk:hover{background-color:rgba(255, 255, 255, 0.08);}@media (hover: none){.css-1ps3nxk:hover{background-color:transparent;}}.css-1ps3nxk.Mui-disabled{background-color:transparent;color:rgba(255, 255, 255, 0.3);}.css-vubbuv{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;width:1em;height:1em;display:inline-block;fill:currentColor;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;font-size:1.5rem;}.css-6ipc24{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1.25rem;line-height:1.334;color:#90caf9;-webkit-text-decoration:none;text-decoration:none;}@media (min-width:600px){.css-6ipc24{font-size:1.3118rem;}}@media (min-width:960px){.css-6ipc24{font-size:1.4993rem;}}@media (min-width:1280px){.css-6ipc24{font-size:1.4993rem;}}.css-6ipc24:hover{-webkit-text-decoration:underline;text-decoration:underline;}@media (min-width:0px){.css-6ipc24{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;margin-left:16px;}}@media (min-width:600px){.css-6ipc24{-webkit-box-flex:0;-webkit-flex-grow:0;-ms-flex-positive:0;flex-grow:0;margin-right:32px;}}.css-6ipc24.MuiLink-root,.css-6ipc24.MuiLink-underlineHover{color:#4db6ac;font-weight:700;}.css-mfiwgy{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}@media (min-width:0px){.css-mfiwgy{display:none;}}@media (min-width:600px){.css-mfiwgy{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;}}.css-16as864{margin:0;font-family:inherit;font-weight:inherit;font-size:inherit;line-height:inherit;letter-spacing:inherit;color:#90caf9;-webkit-text-decoration:underline;text-decoration:underline;text-decoration-color:rgba(144, 202, 249, 0.4);margin-right:16px;-webkit-text-decoration:none;text-decoration:none;color:#fff;}.css-16as864:hover{text-decoration-color:inherit;}.css-16as864:hover{-webkit-text-decoration:underline;text-decoration:underline;}.css-3iet4t{margin:0;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-weight:400;font-size:1rem;line-height:1.5;}.css-1qyknr9{width:100%;margin-left:auto;box-sizing:border-box;margin-right:auto;display:block;padding-left:16px;padding-right:16px;}@media (min-width:600px){.css-1qyknr9{padding-left:24px;padding-right:24px;}}@media (min-width:960px){.css-1qyknr9{max-width:960px;}}@media (max-width:599.95px){.css-1qyknr9.MuiContainer-root{padding:0px;}}.css-bkna8o{background-color:#121212;color:#fff;-webkit-transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;border-radius:4px;box-shadow:none;background-image:linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0));padding:16px 40px 32px;}@media (max-width:599.95px){.css-bkna8o{padding:8px 16px 32px;}}.css-1m2hk6l h1,.css-1m2hk6l h2,.css-1m2hk6l h3{margin-top:32px;margin-bottom:8px;}.css-1m2hk6l p{margin-bottom:12px;font-size:var(--fs-300);}.css-1m2hk6l li{list-style-position:inside;}.css-1m2hk6l ul{padding-left:16px;}.css-1m2hk6l blockquote{border-left-width:1px;border-left-style:solid;border-left-color:#26a69a;padding-left:16px;font-style:italic;}.css-400xyc{font-weight:bold;margin-bottom:16px;}.css-186wd1t{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;gap:8px;margin-bottom:16px;}.css-18ldivb{max-width:100%;font-family:'__Noto_Sans_KR_0298e2','__Noto_Sans_KR_Fallback_0298e2',Roboto;font-size:0.8125rem;display:-webkit-inline-box;display:-webkit-inline-flex;display:-ms-inline-flexbox;display:inline-flex;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;height:24px;color:rgba(0, 0, 0, 0.87);background-color:#90caf9;border-radius:16px;white-space:nowrap;-webkit-transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;transition:background-color 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,box-shadow 300ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;cursor:default;outline:0;-webkit-text-decoration:none;text-decoration:none;border:0;padding:0;vertical-align:middle;box-sizing:border-box;}.css-18ldivb.Mui-disabled{opacity:0.38;pointer-events:none;}.css-18ldivb .MuiChip-avatar{margin-left:5px;margin-right:-6px;width:24px;height:24px;color:#e0e0e0;font-size:0.75rem;}.css-18ldivb .MuiChip-avatarColorPrimary{color:rgba(0, 0, 0, 0.87);background-color:#42a5f5;}.css-18ldivb .MuiChip-avatarColorSecondary{color:rgba(0, 0, 0, 0.87);background-color:#ab47bc;}.css-18ldivb .MuiChip-avatarSmall{margin-left:4px;margin-right:-4px;width:18px;height:18px;font-size:0.625rem;}.css-18ldivb .MuiChip-icon{margin-left:4px;margin-right:-4px;font-size:18px;color:inherit;}.css-18ldivb .MuiChip-deleteIcon{-webkit-tap-highlight-color:transparent;color:rgba(0, 0, 0, 0.7);font-size:16px;cursor:pointer;margin:0 5px 0 -6px;margin-right:4px;margin-left:-4px;}.css-18ldivb .MuiChip-deleteIcon:hover{color:rgba(255, 255, 255, 0.4);}.css-18ldivb .MuiChip-deleteIcon:hover,.css-18ldivb .MuiChip-deleteIcon:active{color:rgba(0, 0, 0, 0.87);}.css-18ldivb.MuiChip-colorPrimary{color:white;background:#009688;font-weight:500;}.css-1pjtbja{overflow:hidden;text-overflow:ellipsis;padding-left:8px;padding-right:8px;white-space:nowrap;}.css-1bas2qp{color:#4db6ac;-webkit-text-decoration:unset;text-decoration:unset;}.css-1bas2qp:hover{cursor:pointer;color:#80cbc4;font-weight:500;}.css-v5nfi0{color:#26a69a;background:#212121;border-radius:4px;font-weight:bold;}.css-1jop5q6{border-radius:8px;font-weight:400;margin-bottom:12px;border:1px solid #212121;position:relative;}.css-1jop5q6 button{position:absolute;top:5px;right:5px;}.css-1jop5q6 code.hljs{background:var(--background-color);}.css-18bh6q1{padding:24px 40px;}@media (max-width:599.95px){.css-18bh6q1{padding:24px 16px;}}.css-18bh6q1 .utterances{position:relative;box-sizing:border-box;width:100%;max-width:unset;margin:0;}</style><style data-href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap">@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc-.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:300;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmSU5fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:500;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmEU9fBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCRc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfABc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0301,U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCBc4AMP6lbBP.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfCxc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+0300-0301,U+0303-0304,U+0308-0309,U+0323,U+0329,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfChc4AMP6lbBP.woff2) format('woff2');unicode-range:U+0100-02AF,U+0304,U+0308,U+0329,U+1E00-1E9F,U+1EF2-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:700;font-display:swap;src:url(https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc4AMP6lQ.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+0304,U+0308,U+0329,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body><div id="__next"><div><header class="MuiPaper-root MuiPaper-elevation MuiPaper-elevation4 MuiAppBar-root MuiAppBar-colorPrimary MuiAppBar-positionStatic css-1lgdpai"><div class="MuiToolbar-root MuiToolbar-regular css-dy3din"><div class="MuiBox-root css-zjuml4"><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeLarge css-1ps3nxk" tabindex="0" type="button" aria-label="account of current user" aria-controls="menu-appbar" aria-haspopup="true"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="MenuIcon"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg></button></div><a class="MuiTypography-root MuiTypography-h5 MuiLink-root MuiLink-underlineHover css-6ipc24" href="/">Paco Kwon</a><div class="MuiBox-root css-mfiwgy"><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/bio"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Bio</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/posts"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Posts</p></a><a class="MuiTypography-root MuiTypography-inherit MuiLink-root MuiLink-underlineAlways css-16as864" href="/links"><p class="MuiTypography-root MuiTypography-body1 css-3iet4t">Links</p></a></div><button class="MuiButtonBase-root MuiIconButton-root MuiIconButton-colorInherit MuiIconButton-sizeMedium css-670439" tabindex="0" type="button"><svg class="MuiSvgIcon-root MuiSvgIcon-fontSizeMedium css-vubbuv" focusable="false" aria-hidden="true" viewBox="0 0 24 24" data-testid="Brightness7Icon"><path d="M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69zM12 18c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zm0-10c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path></svg></button></div></header><main><div class="MuiContainer-root MuiContainer-maxWidthMd css-1qyknr9"><div class="MuiPaper-root MuiPaper-elevation MuiPaper-rounded MuiPaper-elevation0 css-bkna8o"><div class="css-1m2hk6l"><h1>하스켈로 간단한 Lisp 만들기 - 평가</h1><div class="css-400xyc">2023-06-18</div><div class="css-186wd1t"><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">ko</span></div><div class="MuiChip-root MuiChip-filled MuiChip-sizeSmall MuiChip-colorPrimary MuiChip-filledPrimary css-18ldivb"><span class="MuiChip-label MuiChip-labelSmall css-1pjtbja">haskell</span></div></div><div><p><a href="./20230616-haskell-lisp-parsing" class="css-1bas2qp">1부</a>에서는 S-Expression을 파싱하는 법에 대해 간단하게 알아보았다. 이번 포스트에서는 파싱한 결과물을 실행시켜볼 것이다.</p>
<p>먼저 <code class="css-v5nfi0">src/Eval.hs</code> 파일을 만들자. 거의 모든 작업을 이 파일에서 진행할 것이다. 이 글에서 최종 목표는 아래 두 함수를 완성시키는 것이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">eval</span> :: <span class="hljs-type">Sexpr</span> -&gt; <span class="hljs-type">Value</span>
<span class="hljs-title">repl</span> :: <span class="hljs-type">IO</span> ()
</code></div></pre>
<p>위 <code class="css-v5nfi0">eval</code> 함수부터 구현해보자. <code class="css-v5nfi0">eval</code>은 S-Expression 트리를 입력으로 받고 결과값을 돌려준다.</p>
<p>먼저 결과값인 <code class="css-v5nfi0">Value</code> 타입을 정의해보자. 일단 숫자는 결과로 나올 것이 당연해 보이니, 우선 <code class="css-v5nfi0">Value</code>의 종류는 <code class="css-v5nfi0">Int</code>하나로 정의하고 구현을 하며 점진적으로 그 종류를 늘려가자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Value</span> = <span class="hljs-type">NumV</span> <span class="hljs-type">Int</span></span>
</code></div></pre>
<p>이제 가능한 S-Expression을 형태별로 평가해볼 것이다.</p>
<h3 id="숫자-평가">숫자 평가</h3>
<p>숫자 평가는 간단하다. 생성자에 들어있는 값을 꺼내기만 하면 된다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">eval</span> (<span class="hljs-type">Number</span> n) = n
</code></div></pre>
<h3 id="식별자-평가">식별자 평가</h3>
<p>식별자 평가는 애매하다. 아직 언어에 <em>변수가 없기 때문</em>이다. 때문에 현재 식별자가 이용될만한 곳은 리스트의 가장 앞쪽에 있는 경우, 즉 함수로 사용되는 경우이다. 아래와 같은 코드가 해당한다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-lisp">(<span class="hljs-name">+</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>) <span class="hljs-comment">; 3</span>

(<span class="hljs-name">max</span> <span class="hljs-number">30</span> <span class="hljs-number">42</span> <span class="hljs-number">7</span>) <span class="hljs-comment">; 42</span>
</code></div></pre>
<p>가장 앞에 있는 것이 식별자로 파싱이 된다.</p>
<p>근데 또 문제가 있다. 누가 <code class="css-v5nfi0">+</code>를 더하기 함수로, <code class="css-v5nfi0">max</code>를 최대값 함수로 정의하는 것일까? 저런 코드가 예상대로 작동하려면, 더하기를 수행하고 최대값을 구하는 로직을 누가 심어둬야 한다. 그것은 우리의 몫이다.</p>
<p>그러니 현재 우리가 할 수 있는 것은, 식별자를 봤을 때 기본 함수로 pre-defined된 식별자라면 함수를 돌려주고, 그렇지 않은 경우에는 에러를 발생시키는 것이다.</p>
<p>그러기 위해서는 우선 함수 값을 만들어야 한다. 아래와 같이 <code class="css-v5nfi0">Value</code>를 확장시켜보자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Value</span> = <span class="hljs-type">NumV</span> <span class="hljs-type">Int</span></span>
           | <span class="hljs-type">Func</span> ([<span class="hljs-type">Value</span>] -&gt; <span class="hljs-type">Value</span>)
</code></div></pre>
<p>Lisp는 꽤 다이나믹한 언어라 <code class="css-v5nfi0">+</code>와 같은 함수같은 경우에는 명시된 인자 개수가 없이 몇개가 들어와도 전부 더해서 돌려준다. 물론 인자의 개수가 고정되어야 하는 함수의 경우에는 개수가 맞지 않으면 에러를 발생시킨다. 이러한 use case를 모두 커버하기 위해 우리의 함수는 인자를 리스트로 받도록 만들었다.</p>
<p><code class="css-v5nfi0">+</code> 함수를 구현해보자. 아래와 같이 짜볼 수 있을 것이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> <span class="hljs-string">&quot;+&quot;</span>) = <span class="hljs-type">Func</span> func
    <span class="hljs-keyword">where</span>
        func = <span class="hljs-type">NumV</span> . sum . map mapping
        mapping (<span class="hljs-type">NumV</span> n) = n
        mapping _ = error <span class="hljs-string">&quot;\&quot;+\&quot; expects a number as argument&quot;</span>
</code></div></pre>
<p>하스켈의 <code class="css-v5nfi0">sum</code> 함수를 활용하니 꽤 간단하다!</p>
<p><code class="css-v5nfi0">max</code>도 구현해보자. 마찬가지로 꽤 간단하다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> <span class="hljs-string">&quot;max&quot;</span>) = <span class="hljs-type">Func</span> func
    <span class="hljs-keyword">where</span>
        func = <span class="hljs-type">NumV</span> . maximum . map mapping
        mapping (<span class="hljs-type">NumV</span> n) = n
        mapping _ = error <span class="hljs-string">&quot;\&quot;max\&quot; expects a number as argument&quot;</span>
</code></div></pre>
<p>다른 식별자를 마주쳤을 때는 에러를 발생시키자. 또 위에 중복되는 <code class="css-v5nfi0">mapping</code> 함수를 밖으로 뽑아내었다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">getNum</span> :: <span class="hljs-type">Value</span> -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">getNum</span> (<span class="hljs-type">NumV</span> n) = n
<span class="hljs-title">getNum</span> x = error (<span class="hljs-string">&quot;Value must be a NumV value. Got: &quot;</span> ++ show x)

<span class="hljs-title">eval</span> :: <span class="hljs-type">Sexpr</span> -&gt; <span class="hljs-type">Value</span>
<span class="hljs-title">eval</span> (<span class="hljs-type">Number</span> n) = <span class="hljs-type">NumV</span> n
<span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> <span class="hljs-string">&quot;+&quot;</span>) = <span class="hljs-type">Func</span> func
    <span class="hljs-keyword">where</span>
        func = <span class="hljs-type">NumV</span> . sum . map getNum
<span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> <span class="hljs-string">&quot;max&quot;</span>) = <span class="hljs-type">Func</span> func
    <span class="hljs-keyword">where</span>
        func = <span class="hljs-type">NumV</span> . maximum . map getNum
<span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> x) = error $ <span class="hljs-string">&quot;Unknown identifier &quot;</span> ++ x
</code></div></pre>
<h3 id="리스트-평가">리스트 평가</h3>
<p>우리는 리스트에서 첫 번째 요소가 &quot;함수&quot;이기를 기대하고 있다. <code class="css-v5nfi0">(+ 1 2 3)</code> 에서 <code class="css-v5nfi0">+</code>처럼 말이다. 그 다음은 나머지 요소들을 함수에 넘기기만 하면 되는데, 그 전에 평가를 하고 넘기는 것이 중요하다. 우리 함수는 <code class="css-v5nfi0">Sexpr</code>이 아닌 <code class="css-v5nfi0">Value</code> 타입의 인자를 받는다는 것을 기억하자.</p>
<p>다음은 리스트 평가 코드이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">eval</span> (<span class="hljs-type">Paren</span> (x:xs)) = getFunc (eval x) (map eval xs)
    <span class="hljs-keyword">where</span>
        getFunc (<span class="hljs-type">Func</span> f) = f
        getFunc v = error $ <span class="hljs-string">&quot;The first element in a list must be a function. Got: &quot;</span> ++ show v
<span class="hljs-title">eval</span> (<span class="hljs-type">Paren</span> []) = error <span class="hljs-string">&quot;List must not be empty!&quot;</span>
</code></div></pre>
<p>비어있는 리스트의 경우 에러를 발생시키고 있다.</p>
<h2 id="파서와-합치기">파서와 합치기</h2>
<p>이번 포스트에서는 간단한 평가 로직까지 작성해 보았다. 1부에서 만든 파서와 합쳐서, 임의의 S-Expression을 받아 평가해주는 REPL을 만들어 보자.</p>
<h3 id="repl">REPL</h3>
<p>우선 REPL 코드를 짜보자. 하스켈은 다른 언어와 다르게 IO 처리가 특이해서 먼저 틀을 잡고 가는 것이 편할 것 같다.</p>
<p>가장 먼저 에코 REPL을 만들어볼 것이다. 에코 REPL은 사용자가 입력한 것을 똑같이 출력해주는 REPL이다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-keyword">import</span> System.IO (<span class="hljs-title">hFlush</span>, <span class="hljs-title">stdout</span>)

<span class="hljs-title">repl</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">repl</span> = <span class="hljs-keyword">do</span>
    putStr <span class="hljs-string">&quot;&gt;&gt; &quot;</span>
    hFlush stdout
    input &lt;- getLine
    putStrLn $ <span class="hljs-string">&quot;You entered &quot;</span> ++ input
    repl
</code></div></pre>
<p>위 코드가 하는 일은 다음과 같다.</p>
<ol>
<li><code class="css-v5nfi0">&gt;&gt; </code>를 먼저 출력한다. 이는 사용자가 REPL에 들어와 있음을 잘 명시해준다.</li>
<li><code class="css-v5nfi0">hFlush</code> 함수를 이용하여 현재 버퍼에 있는 내용을 <code class="css-v5nfi0">stdout</code>으로 보내버린다. 많은 언어들의 표준 라이브러리가 buffered IO를 사용하기 때문에 <code class="css-v5nfi0">stdout</code>으로 출력을 하더라도 버퍼에 쌓이기만 하여 나중에 출력 순서가 섞이는 경우가 있다.</li>
<li><code class="css-v5nfi0">getLine</code>을 통해 사용자에게서 문자열 입력을 받는다.</li>
<li>입력으로 받은 문자열을 출력한다.</li>
<li><code class="css-v5nfi0">repl</code>을 다시 호출하여 <code class="css-v5nfi0">1</code>~<code class="css-v5nfi0">4</code>의 과정을 반복한다.</li>
</ol>
<p>이제 사용자가 <code class="css-v5nfi0">exit</code>을 입력하면 루프를 종료하는 기능을 추가해보자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-keyword">import</span> System.IO (<span class="hljs-title">hFlush</span>, <span class="hljs-title">stdout</span>)

<span class="hljs-title">repl</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">repl</span> = <span class="hljs-keyword">do</span>
    putStr <span class="hljs-string">&quot;&gt;&gt; &quot;</span>
    hFlush stdout
    input &lt;- getLine
    <span class="hljs-keyword">if</span> input == <span class="hljs-string">&quot;exit&quot;</span> <span class="hljs-keyword">then</span>
        putStrLn <span class="hljs-string">&quot;Bye!&quot;</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">do</span>
        putStrLn $ <span class="hljs-string">&quot;You entered &quot;</span> ++ input
        repl
</code></div></pre>
<p>위에서 하는 일은 간단하다. <code class="css-v5nfi0">input</code>이 <code class="css-v5nfi0">&quot;exit&quot;</code> 문자열인 경우에는 재귀호출을 하지 않으면 된다. 이렇게 REPL의 틀을 완성했다!</p>
<h3 id="합치기">합치기</h3>
<p>이제 진짜 합칠 때가 되었다.</p>
<p>사실 아직 안되었다. 유틸리티 함수를 하나만 더 만들겠다. 이건 1부에서 했어야 하는 일이었는데, 바로 사용하기 편리한 <code class="css-v5nfi0">parse</code> 함수를 만드는 것이다. 이전 포스트에서는 <code class="css-v5nfi0">parseTest</code>라는 <code class="css-v5nfi0">megaparsec</code>의 함수를 사용해서 우리의 파서를 편리하게 테스트할 수 있었다. 하지만 그것은 <code class="css-v5nfi0">stdout</code>에 출력을 가정하는, 말 그대로 테스트용 헬퍼 함수이기 때문에 실제로 결과값만 가져오고 싶은 경우에는 <code class="css-v5nfi0">runParser</code>를 사용해야 한다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">runParser</span> :: <span class="hljs-type">Parsec</span> e s a<span class="hljs-comment">-- Parser to run</span>
    -&gt; <span class="hljs-type">String</span> <span class="hljs-comment">-- Name of source file</span>
    -&gt; s <span class="hljs-comment">-- Input for parser</span>
    -&gt; <span class="hljs-type">Either</span> (<span class="hljs-type">ParseErrorBundle</span> s e) a <span class="hljs-comment">-- Parsed result</span>
</code></div></pre>
<p><code class="css-v5nfi0">runParser</code>의 시그니처는 위와 같은데, 그냥 사용하기 가장 불편한 이유는 에러 처리와 소스 파일명 인자가 있어서 그렇다. 우리가 어떤 파서를 실행시키고 싶은지(<code class="css-v5nfi0">sexpr</code>)는 꽤 명확하기도 하다. 이를 둘 다 처리해주는 유틸리티 함수를 <code class="css-v5nfi0">src/Parser.hs</code>에 아래와 같이 만들었다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">parse</span> :: <span class="hljs-type">Text</span> -&gt; <span class="hljs-type">Sexpr</span>
<span class="hljs-title">parse</span> input = <span class="hljs-keyword">case</span> runParser sexpr <span class="hljs-string">&quot;&quot;</span> input <span class="hljs-keyword">of</span>
  <span class="hljs-type">Right</span> s -&gt; s
  <span class="hljs-type">Left</span> e -&gt; error . show $ e
</code></div></pre>
<p>이제 모든 조각이 완성되었으니, REPL 안에 합쳐보자.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-title">repl</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">repl</span> = <span class="hljs-keyword">do</span>
    putStr <span class="hljs-string">&quot;&gt;&gt; &quot;</span>
    hFlush stdout
    input &lt;- getLine
    <span class="hljs-keyword">if</span> input == <span class="hljs-string">&quot;exit&quot;</span> <span class="hljs-keyword">then</span>
        putStrLn <span class="hljs-string">&quot;Bye!&quot;</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">do</span>
        print . eval . parse $ input
        repl
</code></div></pre>
<p>이제 실행시켜보자!</p>
<pre><div class="css-1jop5q6"><code class="hljs language-plaintext">$ stack exec whisper-exe
&gt;&gt; (+ 1 2)
3
&gt;&gt; (max 2 5 10)
10
&gt;&gt; (max 2 10 (+ 10 2))
12
&gt;&gt; (+ 5 (max 3 7 1))
12
&gt;&gt; exit
Bye!
</code></div></pre>
<p>이렇게 그럴듯한 REPL이 완성되었다! 아래는 이번 포스트에서 작업을 했던 <code class="css-v5nfi0">src/Eval.hs</code>의 전체 코드다.</p>
<pre><div class="css-1jop5q6"><code class="hljs language-haskell"><span class="hljs-comment">-- src/Eval.hs</span>
<span class="hljs-keyword">module</span> Eval (<span class="hljs-title">eval</span>) <span class="hljs-keyword">where</span>

<span class="hljs-keyword">import</span> Parser (<span class="hljs-type">Sexpr</span> (..))

<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">Value</span> = <span class="hljs-type">NumV</span> <span class="hljs-type">Int</span></span>
           | <span class="hljs-type">Func</span> ([<span class="hljs-type">Value</span>] -&gt; <span class="hljs-type">Value</span>)
<span class="hljs-class">
<span class="hljs-keyword">instance</span> <span class="hljs-type">Show</span> <span class="hljs-type">Value</span> <span class="hljs-keyword">where</span></span>
    show (<span class="hljs-type">NumV</span> n) = show n
    show (<span class="hljs-type">Func</span> _) = <span class="hljs-string">&quot;&lt;function&gt;&quot;</span>

<span class="hljs-title">getNum</span> :: <span class="hljs-type">Value</span> -&gt; <span class="hljs-type">Int</span>
<span class="hljs-title">getNum</span> (<span class="hljs-type">NumV</span> n) = n
<span class="hljs-title">getNum</span> x = error $ <span class="hljs-string">&quot;Value must be a NumV value. Got: &quot;</span> ++ show x

<span class="hljs-title">eval</span> :: <span class="hljs-type">Sexpr</span> -&gt; <span class="hljs-type">Value</span>
<span class="hljs-title">eval</span> (<span class="hljs-type">Number</span> n) = <span class="hljs-type">NumV</span> n
<span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> <span class="hljs-string">&quot;+&quot;</span>) = <span class="hljs-type">Func</span> func
    <span class="hljs-keyword">where</span>
        func = <span class="hljs-type">NumV</span> . sum . map getNum
<span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> <span class="hljs-string">&quot;max&quot;</span>) = <span class="hljs-type">Func</span> func
    <span class="hljs-keyword">where</span>
        func = <span class="hljs-type">NumV</span> . maximum . map getNum
<span class="hljs-title">eval</span> (<span class="hljs-type">Ident</span> x) = error $ <span class="hljs-string">&quot;Unknown identifier &quot;</span> ++ x
<span class="hljs-title">eval</span> (<span class="hljs-type">Paren</span> (x:xs)) = getFunc (eval x) (map eval xs)
    <span class="hljs-keyword">where</span>
        getFunc (<span class="hljs-type">Func</span> f) = f
        getFunc v = error $ <span class="hljs-string">&quot;The first element in a list must be a function. Got: &quot;</span> ++ show v
<span class="hljs-title">eval</span> (<span class="hljs-type">Paren</span> []) = error <span class="hljs-string">&quot;List must not be empty!&quot;</span>
</code></div></pre>
<p>프로젝트의 전체 코드는 <a href="https://github.com/pacokwon/whisper" class="css-1bas2qp">https://github.com/pacokwon/whisper</a> 에서 확인할 수 있다.</p></div></div></div><div id="utterances-comments" class="css-18bh6q1"></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"id":"20230618-haskell-lisp-eval","content":"\n[1부](./20230616-haskell-lisp-parsing)에서는 S-Expression을 파싱하는 법에 대해 간단하게 알아보았다. 이번 포스트에서는 파싱한 결과물을 실행시켜볼 것이다.\n\n먼저 `src/Eval.hs` 파일을 만들자. 거의 모든 작업을 이 파일에서 진행할 것이다. 이 글에서 최종 목표는 아래 두 함수를 완성시키는 것이다.\n\n```haskell\neval :: Sexpr -\u003e Value\nrepl :: IO ()\n```\n\n위 `eval` 함수부터 구현해보자. `eval`은 S-Expression 트리를 입력으로 받고 결과값을 돌려준다.\n\n먼저 결과값인 `Value` 타입을 정의해보자. 일단 숫자는 결과로 나올 것이 당연해 보이니, 우선 `Value`의 종류는 `Int`하나로 정의하고 구현을 하며 점진적으로 그 종류를 늘려가자.\n\n```haskell\ndata Value = NumV Int\n```\n\n이제 가능한 S-Expression을 형태별로 평가해볼 것이다.\n\n### 숫자 평가\n\n숫자 평가는 간단하다. 생성자에 들어있는 값을 꺼내기만 하면 된다.\n\n```haskell\neval (Number n) = n\n```\n\n### 식별자 평가\n\n식별자 평가는 애매하다. 아직 언어에 *변수가 없기 때문*이다. 때문에 현재 식별자가 이용될만한 곳은 리스트의 가장 앞쪽에 있는 경우, 즉 함수로 사용되는 경우이다. 아래와 같은 코드가 해당한다.\n\n```lisp\n(+ 1 2) ; 3\n\n(max 30 42 7) ; 42\n```\n\n가장 앞에 있는 것이 식별자로 파싱이 된다.\n\n근데 또 문제가 있다. 누가 `+`를 더하기 함수로, `max`를 최대값 함수로 정의하는 것일까? 저런 코드가 예상대로 작동하려면, 더하기를 수행하고 최대값을 구하는 로직을 누가 심어둬야 한다. 그것은 우리의 몫이다.\n\n그러니 현재 우리가 할 수 있는 것은, 식별자를 봤을 때 기본 함수로 pre-defined된 식별자라면 함수를 돌려주고, 그렇지 않은 경우에는 에러를 발생시키는 것이다.\n\n그러기 위해서는 우선 함수 값을 만들어야 한다. 아래와 같이 `Value`를 확장시켜보자.\n\n```haskell\ndata Value = NumV Int\n           | Func ([Value] -\u003e Value)\n```\n\nLisp는 꽤 다이나믹한 언어라 `+`와 같은 함수같은 경우에는 명시된 인자 개수가 없이 몇개가 들어와도 전부 더해서 돌려준다. 물론 인자의 개수가 고정되어야 하는 함수의 경우에는 개수가 맞지 않으면 에러를 발생시킨다. 이러한 use case를 모두 커버하기 위해 우리의 함수는 인자를 리스트로 받도록 만들었다.\n\n`+` 함수를 구현해보자. 아래와 같이 짜볼 수 있을 것이다.\n\n```haskell\neval (Ident \"+\") = Func func\n    where\n        func = NumV . sum . map mapping\n        mapping (NumV n) = n\n        mapping _ = error \"\\\"+\\\" expects a number as argument\"\n```\n\n하스켈의 `sum` 함수를 활용하니 꽤 간단하다!\n\n`max`도 구현해보자. 마찬가지로 꽤 간단하다.\n\n```haskell\neval (Ident \"max\") = Func func\n    where\n        func = NumV . maximum . map mapping\n        mapping (NumV n) = n\n        mapping _ = error \"\\\"max\\\" expects a number as argument\"\n```\n\n다른 식별자를 마주쳤을 때는 에러를 발생시키자. 또 위에 중복되는 `mapping` 함수를 밖으로 뽑아내었다.\n\n```haskell\ngetNum :: Value -\u003e Int\ngetNum (NumV n) = n\ngetNum x = error (\"Value must be a NumV value. Got: \" ++ show x)\n\neval :: Sexpr -\u003e Value\neval (Number n) = NumV n\neval (Ident \"+\") = Func func\n    where\n        func = NumV . sum . map getNum\neval (Ident \"max\") = Func func\n    where\n        func = NumV . maximum . map getNum\neval (Ident x) = error $ \"Unknown identifier \" ++ x\n```\n\n### 리스트 평가\n\n우리는 리스트에서 첫 번째 요소가 \"함수\"이기를 기대하고 있다. `(+ 1 2 3)` 에서 `+`처럼 말이다. 그 다음은 나머지 요소들을 함수에 넘기기만 하면 되는데, 그 전에 평가를 하고 넘기는 것이 중요하다. 우리 함수는 `Sexpr`이 아닌 `Value` 타입의 인자를 받는다는 것을 기억하자.\n\n다음은 리스트 평가 코드이다.\n\n```haskell\neval (Paren (x:xs)) = getFunc (eval x) (map eval xs)\n    where\n        getFunc (Func f) = f\n        getFunc v = error $ \"The first element in a list must be a function. Got: \" ++ show v\neval (Paren []) = error \"List must not be empty!\"\n```\n\n비어있는 리스트의 경우 에러를 발생시키고 있다.\n\n## 파서와 합치기\n\n이번 포스트에서는 간단한 평가 로직까지 작성해 보았다. 1부에서 만든 파서와 합쳐서, 임의의 S-Expression을 받아 평가해주는 REPL을 만들어 보자.\n\n### REPL\n\n우선 REPL 코드를 짜보자. 하스켈은 다른 언어와 다르게 IO 처리가 특이해서 먼저 틀을 잡고 가는 것이 편할 것 같다.\n\n가장 먼저 에코 REPL을 만들어볼 것이다. 에코 REPL은 사용자가 입력한 것을 똑같이 출력해주는 REPL이다.\n\n```haskell\nimport System.IO (hFlush, stdout)\n\nrepl :: IO ()\nrepl = do\n    putStr \"\u003e\u003e \"\n    hFlush stdout\n    input \u003c- getLine\n    putStrLn $ \"You entered \" ++ input\n    repl\n```\n\n위 코드가 하는 일은 다음과 같다.\n\n1.  `\u003e\u003e `를 먼저 출력한다. 이는 사용자가 REPL에 들어와 있음을 잘 명시해준다.\n2.  `hFlush` 함수를 이용하여 현재 버퍼에 있는 내용을 `stdout`으로 보내버린다. 많은 언어들의 표준 라이브러리가 buffered IO를 사용하기 때문에 `stdout`으로 출력을 하더라도 버퍼에 쌓이기만 하여 나중에 출력 순서가 섞이는 경우가 있다.\n3.  `getLine`을 통해 사용자에게서 문자열 입력을 받는다.\n4.  입력으로 받은 문자열을 출력한다.\n5.  `repl`을 다시 호출하여 `1`~`4`의 과정을 반복한다.\n\n이제 사용자가 `exit`을 입력하면 루프를 종료하는 기능을 추가해보자.\n\n```haskell\nimport System.IO (hFlush, stdout)\n\nrepl :: IO ()\nrepl = do\n    putStr \"\u003e\u003e \"\n    hFlush stdout\n    input \u003c- getLine\n    if input == \"exit\" then\n        putStrLn \"Bye!\"\n    else do\n        putStrLn $ \"You entered \" ++ input\n        repl\n```\n\n위에서 하는 일은 간단하다. `input`이 `\"exit\"` 문자열인 경우에는 재귀호출을 하지 않으면 된다. 이렇게 REPL의 틀을 완성했다!\n\n### 합치기\n\n이제 진짜 합칠 때가 되었다.\n\n사실 아직 안되었다. 유틸리티 함수를 하나만 더 만들겠다. 이건 1부에서 했어야 하는 일이었는데, 바로 사용하기 편리한 `parse` 함수를 만드는 것이다. 이전 포스트에서는 `parseTest`라는 `megaparsec`의 함수를 사용해서 우리의 파서를 편리하게 테스트할 수 있었다. 하지만 그것은 `stdout`에 출력을 가정하는, 말 그대로 테스트용 헬퍼 함수이기 때문에 실제로 결과값만 가져오고 싶은 경우에는 `runParser`를 사용해야 한다.\n\n```haskell\nrunParser :: Parsec e s a-- Parser to run\n    -\u003e String -- Name of source file\n    -\u003e s -- Input for parser\n    -\u003e Either (ParseErrorBundle s e) a -- Parsed result\n```\n\n`runParser`의 시그니처는 위와 같은데, 그냥 사용하기 가장 불편한 이유는 에러 처리와 소스 파일명 인자가 있어서 그렇다. 우리가 어떤 파서를 실행시키고 싶은지(`sexpr`)는 꽤 명확하기도 하다. 이를 둘 다 처리해주는 유틸리티 함수를 `src/Parser.hs`에 아래와 같이 만들었다.\n\n```haskell\nparse :: Text -\u003e Sexpr\nparse input = case runParser sexpr \"\" input of\n  Right s -\u003e s\n  Left e -\u003e error . show $ e\n```\n\n이제 모든 조각이 완성되었으니, REPL 안에 합쳐보자.\n\n```haskell\nrepl :: IO ()\nrepl = do\n    putStr \"\u003e\u003e \"\n    hFlush stdout\n    input \u003c- getLine\n    if input == \"exit\" then\n        putStrLn \"Bye!\"\n    else do\n        print . eval . parse $ input\n        repl\n```\n\n이제 실행시켜보자!\n\n```plaintext\n$ stack exec whisper-exe\n\u003e\u003e (+ 1 2)\n3\n\u003e\u003e (max 2 5 10)\n10\n\u003e\u003e (max 2 10 (+ 10 2))\n12\n\u003e\u003e (+ 5 (max 3 7 1))\n12\n\u003e\u003e exit\nBye!\n```\n\n이렇게 그럴듯한 REPL이 완성되었다! 아래는 이번 포스트에서 작업을 했던 `src/Eval.hs`의 전체 코드다.\n\n```haskell\n-- src/Eval.hs\nmodule Eval (eval) where\n\nimport Parser (Sexpr (..))\n\ndata Value = NumV Int\n           | Func ([Value] -\u003e Value)\n\ninstance Show Value where\n    show (NumV n) = show n\n    show (Func _) = \"\u003cfunction\u003e\"\n\ngetNum :: Value -\u003e Int\ngetNum (NumV n) = n\ngetNum x = error $ \"Value must be a NumV value. Got: \" ++ show x\n\neval :: Sexpr -\u003e Value\neval (Number n) = NumV n\neval (Ident \"+\") = Func func\n    where\n        func = NumV . sum . map getNum\neval (Ident \"max\") = Func func\n    where\n        func = NumV . maximum . map getNum\neval (Ident x) = error $ \"Unknown identifier \" ++ x\neval (Paren (x:xs)) = getFunc (eval x) (map eval xs)\n    where\n        getFunc (Func f) = f\n        getFunc v = error $ \"The first element in a list must be a function. Got: \" ++ show v\neval (Paren []) = error \"List must not be empty!\"\n```\n\n프로젝트의 전체 코드는 https://github.com/pacokwon/whisper 에서 확인할 수 있다.\n","title":"하스켈로 간단한 Lisp 만들기 - 평가","tags":["ko","haskell"],"date":"2023-06-18"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"20230618-haskell-lisp-eval"},"buildId":"ScjPqQVmosJHdyaFeeBfu","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>